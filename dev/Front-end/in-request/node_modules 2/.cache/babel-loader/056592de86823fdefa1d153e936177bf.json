{"ast":null,"code":"var toString = Object.prototype.toString;\nvar isModern = typeof Buffer.alloc === 'function' && typeof Buffer.allocUnsafe === 'function' && typeof Buffer.from === 'function';\n\nfunction isArrayBuffer(input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer';\n}\n\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  byteOffset >>>= 0;\n  var maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\");\n  }\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    length >>>= 0;\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\");\n    }\n  }\n\n  return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));\n}\n\nfunction fromString(string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);\n}\n\nfunction bufferFrom(value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset);\n  }\n\n  return isModern ? Buffer.from(value) : new Buffer(value);\n}\n\nmodule.exports = bufferFrom;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/buffer-from/index.js"],"names":["toString","Object","prototype","isModern","Buffer","alloc","allocUnsafe","from","isArrayBuffer","input","call","slice","fromArrayBuffer","obj","byteOffset","length","maxLength","byteLength","RangeError","undefined","Uint8Array","fromString","string","encoding","isEncoding","TypeError","bufferFrom","value","encodingOrOffset","module","exports"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,SAAP,CAAiBF,QAAhC;AAEA,IAAIG,QAAQ,GACV,OAAOC,MAAM,CAACC,KAAd,KAAwB,UAAxB,IACA,OAAOD,MAAM,CAACE,WAAd,KAA8B,UAD9B,IAEA,OAAOF,MAAM,CAACG,IAAd,KAAuB,UAHzB;;AAMA,SAASC,aAAT,CAAwBC,KAAxB,EAA+B;AAC7B,SAAOT,QAAQ,CAACU,IAAT,CAAcD,KAAd,EAAqBE,KAArB,CAA2B,CAA3B,EAA8B,CAAC,CAA/B,MAAsC,aAA7C;AACD;;AAED,SAASC,eAAT,CAA0BC,GAA1B,EAA+BC,UAA/B,EAA2CC,MAA3C,EAAmD;AACjDD,EAAAA,UAAU,MAAM,CAAhB;AAEA,MAAIE,SAAS,GAAGH,GAAG,CAACI,UAAJ,GAAiBH,UAAjC;;AAEA,MAAIE,SAAS,GAAG,CAAhB,EAAmB;AACjB,UAAM,IAAIE,UAAJ,CAAe,2BAAf,CAAN;AACD;;AAED,MAAIH,MAAM,KAAKI,SAAf,EAA0B;AACxBJ,IAAAA,MAAM,GAAGC,SAAT;AACD,GAFD,MAEO;AACLD,IAAAA,MAAM,MAAM,CAAZ;;AAEA,QAAIA,MAAM,GAAGC,SAAb,EAAwB;AACtB,YAAM,IAAIE,UAAJ,CAAe,2BAAf,CAAN;AACD;AACF;;AAED,SAAOf,QAAQ,GACXC,MAAM,CAACG,IAAP,CAAYM,GAAG,CAACF,KAAJ,CAAUG,UAAV,EAAsBA,UAAU,GAAGC,MAAnC,CAAZ,CADW,GAEX,IAAIX,MAAJ,CAAW,IAAIgB,UAAJ,CAAeP,GAAG,CAACF,KAAJ,CAAUG,UAAV,EAAsBA,UAAU,GAAGC,MAAnC,CAAf,CAAX,CAFJ;AAGD;;AAED,SAASM,UAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuC;AACrC,MAAI,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,EAAjD,EAAqD;AACnDA,IAAAA,QAAQ,GAAG,MAAX;AACD;;AAED,MAAI,CAACnB,MAAM,CAACoB,UAAP,CAAkBD,QAAlB,CAAL,EAAkC;AAChC,UAAM,IAAIE,SAAJ,CAAc,4CAAd,CAAN;AACD;;AAED,SAAOtB,QAAQ,GACXC,MAAM,CAACG,IAAP,CAAYe,MAAZ,EAAoBC,QAApB,CADW,GAEX,IAAInB,MAAJ,CAAWkB,MAAX,EAAmBC,QAAnB,CAFJ;AAGD;;AAED,SAASG,UAAT,CAAqBC,KAArB,EAA4BC,gBAA5B,EAA8Cb,MAA9C,EAAsD;AACpD,MAAI,OAAOY,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAIF,SAAJ,CAAc,uCAAd,CAAN;AACD;;AAED,MAAIjB,aAAa,CAACmB,KAAD,CAAjB,EAA0B;AACxB,WAAOf,eAAe,CAACe,KAAD,EAAQC,gBAAR,EAA0Bb,MAA1B,CAAtB;AACD;;AAED,MAAI,OAAOY,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAON,UAAU,CAACM,KAAD,EAAQC,gBAAR,CAAjB;AACD;;AAED,SAAOzB,QAAQ,GACXC,MAAM,CAACG,IAAP,CAAYoB,KAAZ,CADW,GAEX,IAAIvB,MAAJ,CAAWuB,KAAX,CAFJ;AAGD;;AAEDE,MAAM,CAACC,OAAP,GAAiBJ,UAAjB","sourcesContent":["var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n"]},"metadata":{},"sourceType":"script"}