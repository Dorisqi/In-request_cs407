{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http2 = require(\"http2\");\n\nconst tls_1 = require(\"tls\");\n\nconst channel_1 = require(\"./channel\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst net = require(\"net\");\n\nconst {\n  version: clientVersion\n} = require('../../package.json');\n\nconst TRACER_NAME = 'subchannel';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\n\nfunction isTcpSubchannelAddress(address) {\n  return 'port' in address;\n}\n\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\n\nfunction subchannelAddressEqual(address1, address2) {\n  if (isTcpSubchannelAddress(address1)) {\n    return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\n\nexports.subchannelAddressEqual = subchannelAddressEqual;\n\nfunction subchannelAddressToString(address) {\n  if (isTcpSubchannelAddress(address)) {\n    return address.host + ':' + address.port;\n  } else {\n    return address.path;\n  }\n}\n\nexports.subchannelAddressToString = subchannelAddressToString;\n\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n\n    this.connectivityState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n\n    this.disconnectListeners = [];\n    /**\n     * The amount of time in between sending pings\n     */\n\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n\n    this.refcount = 0; // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueConnecting) {\n        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.CONNECTING);\n      } else {\n        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.IDLE);\n      }\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n\n\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  sendPing() {\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n    }, this.keepaliveTimeoutMs);\n    this.session.ping((err, duration, payload) => {\n      clearTimeout(this.keepaliveTimeoutId);\n    });\n  }\n\n  startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.sendPing();\n  }\n\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  startConnectingInternal() {\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    let addressScheme = 'http://';\n\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://'; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        connectionOptions.servername = resolver_1.getDefaultAuthority(this.channelTarget);\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        /* net.NetConnectOpts is declared in a way that is more restrictive\n         * than what net.connect will actually accept, so we use the type\n         * assertion to work around that. */\n        return net.connect(this.subchannelAddress);\n      };\n    }\n\n    connectionOptions = Object.assign(connectionOptions, this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n\n    const session = http2.connect(addressScheme + resolver_1.getDefaultAuthority(this.channelTarget), connectionOptions);\n    this.session = session;\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n\n        this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${this.channelTarget} rejected by server because of excess pings`);\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n        }\n\n        this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      trace(this.subchannelAddressString + ' connection closed with error ' + error.message);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n\n\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n\n    trace(this.subchannelAddressString + ' ' + channel_1.ConnectivityState[this.connectivityState] + ' -> ' + channel_1.ConnectivityState[newState]);\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n\n    switch (newState) {\n      case channel_1.ConnectivityState.READY:\n        this.stopBackoff();\n        this.session.socket.once('close', () => {\n          for (const listener of this.disconnectListeners) {\n            listener();\n          }\n        });\n        break;\n\n      case channel_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n\n      case channel_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.stopKeepalivePings();\n        break;\n\n      case channel_1.ConnectivityState.IDLE:\n        /* Stopping the backoff timer here is probably redundant because we\n         * should only transition to the IDLE state as a result of the timer\n         * ending, but we still want to reset the backoff timeout. */\n        this.stopBackoff();\n\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.stopKeepalivePings();\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n\n\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n\n\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.IDLE, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n\n  callRef() {\n    trace(this.subchannelAddressString + ' callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n\n      this.startKeepalivePings();\n    }\n\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    trace(this.subchannelAddressString + ' callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n\n      this.stopKeepalivePings();\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    trace(this.subchannelAddressString + ' refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    trace(this.subchannelAddressString + ' refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n\n\n  startCallStream(metadata, callStream) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    const http2Stream = this.session.request(headers);\n    callStream.attachHttp2Stream(http2Stream, this);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n\n\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n\n\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);\n  }\n\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n\n}\n\nexports.Subchannel = Subchannel;","map":{"version":3,"sources":["../../src/subchannel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst channel_1 = require(\"./channel\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst net = require(\"net\");\nconst { version: clientVersion } = require('../../package.json');\nconst TRACER_NAME = 'subchannel';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nfunction isTcpSubchannelAddress(address) {\n    return 'port' in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (isTcpSubchannelAddress(address1)) {\n        return (isTcpSubchannelAddress(address2) &&\n            address1.host === address2.host &&\n            address1.port === address2.port);\n    }\n    else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + ':' + address.port;\n    }\n    else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials) {\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = channel_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.session = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = [];\n        /**\n         * A list of listener functions that will be called when the underlying\n         * socket disconnects. Used for ending active calls with an UNAVAILABLE\n         * status.\n         */\n        this.disconnectListeners = [];\n        /**\n         * The amount of time in between sending pings\n         */\n        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Tracks calls with references to this subchannel\n         */\n        this.callRefcount = 0;\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter(e => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        this.keepaliveIntervalId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveIntervalId);\n        this.keepaliveTimeoutId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveTimeoutId);\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueConnecting) {\n                this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.CONNECTING);\n            }\n            else {\n                this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.IDLE);\n            }\n        }, backoffOptions);\n        this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    sendPing() {\n        this.keepaliveTimeoutId = setTimeout(() => {\n            this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n        }, this.keepaliveTimeoutMs);\n        this.session.ping((err, duration, payload) => {\n            clearTimeout(this.keepaliveTimeoutId);\n        });\n    }\n    startKeepalivePings() {\n        this.keepaliveIntervalId = setInterval(() => {\n            this.sendPing();\n        }, this.keepaliveTimeMs);\n        this.sendPing();\n    }\n    stopKeepalivePings() {\n        clearInterval(this.keepaliveIntervalId);\n        clearTimeout(this.keepaliveTimeoutId);\n    }\n    startConnectingInternal() {\n        let connectionOptions = this.credentials._getConnectionOptions() || {};\n        let addressScheme = 'http://';\n        if ('secureContext' in connectionOptions) {\n            addressScheme = 'https://';\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                connectionOptions.servername = resolver_1.getDefaultAuthority(this.channelTarget);\n            }\n        }\n        else {\n            /* In all but the most recent versions of Node, http2.connect does not use\n             * the options when establishing plaintext connections, so we need to\n             * establish that connection explicitly. */\n            connectionOptions.createConnection = (authority, option) => {\n                /* net.NetConnectOpts is declared in a way that is more restrictive\n                 * than what net.connect will actually accept, so we use the type\n                 * assertion to work around that. */\n                return net.connect(this.subchannelAddress);\n            };\n        }\n        connectionOptions = Object.assign(connectionOptions, this.subchannelAddress);\n        /* http2.connect uses the options here:\n         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n         * The spread operator overides earlier values with later ones, so any port\n         * or host values in the options will be used rather than any values extracted\n         * from the first argument. In addition, the path overrides the host and port,\n         * as documented for plaintext connections here:\n         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n         * and for TLS connections here:\n         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n         * earlier versions of Node, http2.connect passes these options to\n         * tls.connect but not net.connect, so in the insecure case we still need\n         * to set the createConnection option above to create the connection\n         * explicitly. We cannot do that in the TLS case because http2.connect\n         * passes necessary additional options to tls.connect.\n         * The first argument just needs to be parseable as a URL and the scheme\n         * determines whether the connection will be established over TLS or not.\n         */\n        const session = http2.connect(addressScheme + resolver_1.getDefaultAuthority(this.channelTarget), connectionOptions);\n        this.session = session;\n        session.unref();\n        /* For all of these events, check if the session at the time of the event\n         * is the same one currently attached to this subchannel, to ensure that\n         * old events from previous connection attempts cannot cause invalid state\n         * transitions. */\n        session.once('connect', () => {\n            if (this.session === session) {\n                this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);\n            }\n        });\n        session.once('close', () => {\n            if (this.session === session) {\n                this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n                /* Transitioning directly to IDLE here should be OK because we are not\n                 * doing any backoff, because a connection was established at some\n                 * point */\n                this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            if (this.session === session) {\n                /* See the last paragraph of\n                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n                if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                    opaqueData.equals(tooManyPingsData)) {\n                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${this.channelTarget} rejected by server because of excess pings`);\n                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n                }\n                this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('error', error => {\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */\n            trace(this.subchannelAddressString +\n                ' connection closed with error ' +\n                error.message);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        trace(this.subchannelAddressString +\n            ' ' +\n            channel_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            channel_1.ConnectivityState[newState]);\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case channel_1.ConnectivityState.READY:\n                this.stopBackoff();\n                this.session.socket.once('close', () => {\n                    for (const listener of this.disconnectListeners) {\n                        listener();\n                    }\n                });\n                break;\n            case channel_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case channel_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.stopKeepalivePings();\n                break;\n            case channel_1.ConnectivityState.IDLE:\n                /* Stopping the backoff timer here is probably redundant because we\n                 * should only transition to the IDLE state as a result of the timer\n                 * ending, but we still want to reset the backoff timeout. */\n                this.stopBackoff();\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.stopKeepalivePings();\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        /* We use a shallow copy of the stateListeners array in case a listener\n         * is removed during this iteration */\n        for (const listener of [...this.stateListeners]) {\n            listener(this, previousState, newState);\n        }\n        return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */\n    checkBothRefcounts() {\n        /* If no calls, channels, or subchannel pools have any more references to\n         * this subchannel, we can be sure it will never be used again. */\n        if (this.callRefcount === 0 && this.refcount === 0) {\n            this.transitionToState([\n                channel_1.ConnectivityState.CONNECTING,\n                channel_1.ConnectivityState.IDLE,\n                channel_1.ConnectivityState.READY,\n            ], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    callRef() {\n        trace(this.subchannelAddressString +\n            ' callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount + 1));\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.ref();\n            }\n            this.startKeepalivePings();\n        }\n        this.callRefcount += 1;\n    }\n    callUnref() {\n        trace(this.subchannelAddressString +\n            ' callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount - 1));\n        this.callRefcount -= 1;\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.unref();\n            }\n            this.stopKeepalivePings();\n            this.checkBothRefcounts();\n        }\n    }\n    ref() {\n        trace(this.subchannelAddressString +\n            ' refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        trace(this.subchannelAddressString +\n            ' refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount - 1));\n        this.refcount -= 1;\n        this.checkBothRefcounts();\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */\n    startCallStream(metadata, callStream) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        const http2Stream = this.session.request(headers);\n        callStream.attachHttp2Stream(http2Stream, this);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        /* First, try to transition from IDLE to connecting. If that doesn't happen\n         * because the state is not currently IDLE, check if it is\n         * TRANSIENT_FAILURE, and if so indicate that it should go back to\n         * connecting after the backoff timer ends. Otherwise do nothing */\n        if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {\n            if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.continueConnecting = true;\n            }\n        }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    removeDisconnectListener(listener) {\n        const listenerIndex = this.disconnectListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.disconnectListeners.splice(listenerIndex, 1);\n        }\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map"]},"metadata":{},"sourceType":"script"}