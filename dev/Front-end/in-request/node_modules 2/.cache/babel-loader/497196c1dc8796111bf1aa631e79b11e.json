{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst channel_1 = require(\"./channel\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst picker_1 = require(\"./picker\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, defaultServiceConfig) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.defaultServiceConfig = defaultServiceConfig;\n    /**\n     * Current internal load balancer used for handling calls.\n     * Invariant: innerLoadBalancer === null => pendingReplacementLoadBalancer === null.\n     */\n\n    this.innerLoadBalancer = null;\n    /**\n     * The load balancer instance that will be used in place of the current\n     * `innerLoadBalancer` once either that load balancer loses its connection\n     * or this one establishes a connection. For use when a new name resolution\n     * result comes in with a different load balancing configuration, and the\n     * current `innerLoadBalancer` is still connected.\n     */\n\n    this.pendingReplacementLoadBalancer = null;\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of undefined indicates that there has not yet\n     * been a successful resolution. A value of null indicates that the last\n     * successful resolution explicitly provided a null service config.\n     */\n\n    this.previousServiceConfig = undefined;\n    /**\n     * The most recently reported connectivity state of the `innerLoadBalancer`.\n     */\n\n    this.innerBalancerState = channel_1.ConnectivityState.IDLE;\n    this.innerBalancerPicker = new picker_1.UnavailablePicker();\n    /**\n     * The most recent reported state of the pendingReplacementLoadBalancer.\n     * Starts at IDLE for type simplicity. This should get updated as soon as the\n     * pendingReplacementLoadBalancer gets constructed.\n     */\n\n    this.replacementBalancerState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The picker associated with the replacementBalancerState. Starts as an\n     * UnavailablePicker for type simplicity. This should get updated as soon as\n     * the pendingReplacementLoadBalancer gets constructed.\n     */\n\n    this.replacementBalancerPicker = new picker_1.UnavailablePicker();\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n\n    this.continueResolving = false;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = serviceConfig;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === undefined) {\n              // Step 4.ii\n              if (this.defaultServiceConfig === null) {\n                // Step 4.ii.b\n                this.handleResolutionFailure(serviceConfigError);\n              } else {\n                // Step 4.ii.a\n                workingServiceConfig = this.defaultServiceConfig;\n              }\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n\n        let loadBalancerName = null;\n        let loadBalancingConfig = null;\n\n        if (workingServiceConfig === null || workingServiceConfig.loadBalancingConfig.length === 0) {\n          loadBalancerName = DEFAULT_LOAD_BALANCER_NAME;\n        } else {\n          for (const lbConfig of workingServiceConfig.loadBalancingConfig) {\n            // Iterating through a oneof looking for whichever one is populated\n            for (const key in lbConfig) {\n              if (Object.prototype.hasOwnProperty.call(lbConfig, key)) {\n                if (load_balancer_1.isLoadBalancerNameRegistered(key)) {\n                  loadBalancerName = key;\n                  loadBalancingConfig = lbConfig;\n                  break;\n                }\n              }\n            }\n\n            if (loadBalancerName !== null) {\n              break;\n            }\n          }\n\n          if (loadBalancerName === null) {\n            // There were load balancing configs but none are supported. This counts as a resolution failure\n            this.handleResolutionFailure({\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'All load balancer options in service config are not compatible',\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n        }\n\n        if (this.innerLoadBalancer === null) {\n          this.innerLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, this.innerChannelControlHelper);\n          this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        } else if (this.innerLoadBalancer.getTypeName() === loadBalancerName) {\n          this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        } else {\n          if (this.pendingReplacementLoadBalancer === null || this.pendingReplacementLoadBalancer.getTypeName() !== loadBalancerName) {\n            if (this.pendingReplacementLoadBalancer !== null) {\n              this.pendingReplacementLoadBalancer.destroy();\n            }\n\n            this.pendingReplacementLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, this.replacementChannelControlHelper);\n          }\n\n          this.pendingReplacementLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        }\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    });\n    this.innerChannelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      },\n      updateState: (connectivityState, picker) => {\n        this.innerBalancerState = connectivityState;\n\n        if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          picker = new picker_1.QueuePicker(this);\n        }\n\n        this.innerBalancerPicker = picker;\n\n        if (connectivityState !== channel_1.ConnectivityState.READY && this.pendingReplacementLoadBalancer !== null) {\n          this.switchOverReplacementBalancer();\n        } else {\n          if (connectivityState === channel_1.ConnectivityState.IDLE) {\n            if (this.innerLoadBalancer) {\n              this.innerLoadBalancer.destroy();\n              this.innerLoadBalancer = null;\n            }\n          }\n\n          this.updateState(connectivityState, picker);\n        }\n      },\n      requestReresolution: () => {\n        if (this.pendingReplacementLoadBalancer === null) {\n          /* If the backoffTimeout is running, we're still backing off from\n           * making resolve requests, so we shouldn't make another one here.\n           * In that case, the backoff timer callback will call\n           * updateResolution */\n          if (this.backoffTimeout.isRunning()) {\n            this.continueResolving = true;\n          } else {\n            this.updateResolution();\n          }\n        }\n      }\n    };\n    this.replacementChannelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      },\n      updateState: (connectivityState, picker) => {\n        if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          picker = new picker_1.QueuePicker(this);\n        }\n\n        this.replacementBalancerState = connectivityState;\n        this.replacementBalancerPicker = picker;\n\n        if (connectivityState === channel_1.ConnectivityState.READY) {\n          this.switchOverReplacementBalancer();\n        } else if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          if (this.pendingReplacementLoadBalancer) {\n            this.pendingReplacementLoadBalancer.destroy();\n            this.pendingReplacementLoadBalancer = null;\n          }\n        }\n      },\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      }\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        if (this.innerLoadBalancer === null) {\n          this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        } else {\n          this.updateState(this.innerBalancerState, this.innerBalancerPicker);\n        }\n      }\n    });\n  }\n\n  updateResolution() {\n    this.innerResolver.updateResolution();\n\n    if (this.innerLoadBalancer === null || this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n      this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateState(connectivitystate, picker) {\n    trace(this.target + ' ' + channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[connectivitystate]);\n    this.currentState = connectivitystate;\n    this.channelControlHelper.updateState(connectivitystate, picker);\n  }\n  /**\n   * Stop using the current innerLoadBalancer and replace it with the\n   * pendingReplacementLoadBalancer. Must only be called if both of\n   * those are currently not null.\n   */\n\n\n  switchOverReplacementBalancer() {\n    this.innerLoadBalancer.destroy();\n    this.innerLoadBalancer = this.pendingReplacementLoadBalancer;\n    this.innerLoadBalancer.replaceChannelControlHelper(this.innerChannelControlHelper);\n    this.pendingReplacementLoadBalancer = null;\n    this.innerBalancerState = this.replacementBalancerState;\n    this.innerBalancerPicker = this.replacementBalancerPicker;\n    this.updateState(this.replacementBalancerState, this.replacementBalancerPicker);\n  }\n\n  handleResolutionFailure(error) {\n    if (this.innerLoadBalancer === null || this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n      this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n    }\n\n    this.backoffTimeout.runOnce();\n  }\n\n  exitIdle() {\n    if (this.innerLoadBalancer !== null) {\n      this.innerLoadBalancer.exitIdle();\n    }\n\n    if (this.currentState === channel_1.ConnectivityState.IDLE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n\n      this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n\n    if (this.innerLoadBalancer !== null) {\n      this.innerLoadBalancer.resetBackoff();\n    }\n\n    if (this.pendingReplacementLoadBalancer !== null) {\n      this.pendingReplacementLoadBalancer.resetBackoff();\n    }\n  }\n\n  destroy() {\n    if (this.innerLoadBalancer !== null) {\n      this.innerLoadBalancer.destroy();\n      this.innerLoadBalancer = null;\n    }\n\n    if (this.pendingReplacementLoadBalancer !== null) {\n      this.pendingReplacementLoadBalancer.destroy();\n      this.pendingReplacementLoadBalancer = null;\n    }\n\n    this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n\n  replaceChannelControlHelper(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n  }\n\n}\n\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":{"version":3,"sources":["../../src/resolving-load-balancer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst load_balancer_1 = require(\"./load-balancer\");\nconst channel_1 = require(\"./channel\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, defaultServiceConfig) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.defaultServiceConfig = defaultServiceConfig;\n        /**\n         * Current internal load balancer used for handling calls.\n         * Invariant: innerLoadBalancer === null => pendingReplacementLoadBalancer === null.\n         */\n        this.innerLoadBalancer = null;\n        /**\n         * The load balancer instance that will be used in place of the current\n         * `innerLoadBalancer` once either that load balancer loses its connection\n         * or this one establishes a connection. For use when a new name resolution\n         * result comes in with a different load balancing configuration, and the\n         * current `innerLoadBalancer` is still connected.\n         */\n        this.pendingReplacementLoadBalancer = null;\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = channel_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of undefined indicates that there has not yet\n         * been a successful resolution. A value of null indicates that the last\n         * successful resolution explicitly provided a null service config.\n         */\n        this.previousServiceConfig = undefined;\n        /**\n         * The most recently reported connectivity state of the `innerLoadBalancer`.\n         */\n        this.innerBalancerState = channel_1.ConnectivityState.IDLE;\n        this.innerBalancerPicker = new picker_1.UnavailablePicker();\n        /**\n         * The most recent reported state of the pendingReplacementLoadBalancer.\n         * Starts at IDLE for type simplicity. This should get updated as soon as the\n         * pendingReplacementLoadBalancer gets constructed.\n         */\n        this.replacementBalancerState = channel_1.ConnectivityState.IDLE;\n        /**\n         * The picker associated with the replacementBalancerState. Starts as an\n         * UnavailablePicker for type simplicity. This should get updated as soon as\n         * the pendingReplacementLoadBalancer gets constructed.\n         */\n        this.replacementBalancerPicker = new picker_1.UnavailablePicker();\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = serviceConfig;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === undefined) {\n                            // Step 4.ii\n                            if (this.defaultServiceConfig === null) {\n                                // Step 4.ii.b\n                                this.handleResolutionFailure(serviceConfigError);\n                            }\n                            else {\n                                // Step 4.ii.a\n                                workingServiceConfig = this.defaultServiceConfig;\n                            }\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                let loadBalancerName = null;\n                let loadBalancingConfig = null;\n                if (workingServiceConfig === null ||\n                    workingServiceConfig.loadBalancingConfig.length === 0) {\n                    loadBalancerName = DEFAULT_LOAD_BALANCER_NAME;\n                }\n                else {\n                    for (const lbConfig of workingServiceConfig.loadBalancingConfig) {\n                        // Iterating through a oneof looking for whichever one is populated\n                        for (const key in lbConfig) {\n                            if (Object.prototype.hasOwnProperty.call(lbConfig, key)) {\n                                if (load_balancer_1.isLoadBalancerNameRegistered(key)) {\n                                    loadBalancerName = key;\n                                    loadBalancingConfig = lbConfig;\n                                    break;\n                                }\n                            }\n                        }\n                        if (loadBalancerName !== null) {\n                            break;\n                        }\n                    }\n                    if (loadBalancerName === null) {\n                        // There were load balancing configs but none are supported. This counts as a resolution failure\n                        this.handleResolutionFailure({\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: 'All load balancer options in service config are not compatible',\n                            metadata: new metadata_1.Metadata(),\n                        });\n                        return;\n                    }\n                }\n                if (this.innerLoadBalancer === null) {\n                    this.innerLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, this.innerChannelControlHelper);\n                    this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n                }\n                else if (this.innerLoadBalancer.getTypeName() === loadBalancerName) {\n                    this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n                }\n                else {\n                    if (this.pendingReplacementLoadBalancer === null ||\n                        this.pendingReplacementLoadBalancer.getTypeName() !==\n                            loadBalancerName) {\n                        if (this.pendingReplacementLoadBalancer !== null) {\n                            this.pendingReplacementLoadBalancer.destroy();\n                        }\n                        this.pendingReplacementLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, this.replacementChannelControlHelper);\n                    }\n                    this.pendingReplacementLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n                }\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        });\n        this.innerChannelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                return this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            },\n            updateState: (connectivityState, picker) => {\n                this.innerBalancerState = connectivityState;\n                if (connectivityState === channel_1.ConnectivityState.IDLE) {\n                    picker = new picker_1.QueuePicker(this);\n                }\n                this.innerBalancerPicker = picker;\n                if (connectivityState !== channel_1.ConnectivityState.READY &&\n                    this.pendingReplacementLoadBalancer !== null) {\n                    this.switchOverReplacementBalancer();\n                }\n                else {\n                    if (connectivityState === channel_1.ConnectivityState.IDLE) {\n                        if (this.innerLoadBalancer) {\n                            this.innerLoadBalancer.destroy();\n                            this.innerLoadBalancer = null;\n                        }\n                    }\n                    this.updateState(connectivityState, picker);\n                }\n            },\n            requestReresolution: () => {\n                if (this.pendingReplacementLoadBalancer === null) {\n                    /* If the backoffTimeout is running, we're still backing off from\n                     * making resolve requests, so we shouldn't make another one here.\n                     * In that case, the backoff timer callback will call\n                     * updateResolution */\n                    if (this.backoffTimeout.isRunning()) {\n                        this.continueResolving = true;\n                    }\n                    else {\n                        this.updateResolution();\n                    }\n                }\n            },\n        };\n        this.replacementChannelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                return this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            },\n            updateState: (connectivityState, picker) => {\n                if (connectivityState === channel_1.ConnectivityState.IDLE) {\n                    picker = new picker_1.QueuePicker(this);\n                }\n                this.replacementBalancerState = connectivityState;\n                this.replacementBalancerPicker = picker;\n                if (connectivityState === channel_1.ConnectivityState.READY) {\n                    this.switchOverReplacementBalancer();\n                }\n                else if (connectivityState === channel_1.ConnectivityState.IDLE) {\n                    if (this.pendingReplacementLoadBalancer) {\n                        this.pendingReplacementLoadBalancer.destroy();\n                        this.pendingReplacementLoadBalancer = null;\n                    }\n                }\n            },\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                if (this.innerLoadBalancer === null) {\n                    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n                else {\n                    this.updateState(this.innerBalancerState, this.innerBalancerPicker);\n                }\n            }\n        });\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.innerLoadBalancer === null ||\n            this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(connectivitystate, picker) {\n        trace(this.target +\n            ' ' +\n            channel_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            channel_1.ConnectivityState[connectivitystate]);\n        this.currentState = connectivitystate;\n        this.channelControlHelper.updateState(connectivitystate, picker);\n    }\n    /**\n     * Stop using the current innerLoadBalancer and replace it with the\n     * pendingReplacementLoadBalancer. Must only be called if both of\n     * those are currently not null.\n     */\n    switchOverReplacementBalancer() {\n        this.innerLoadBalancer.destroy();\n        this.innerLoadBalancer = this.pendingReplacementLoadBalancer;\n        this.innerLoadBalancer.replaceChannelControlHelper(this.innerChannelControlHelper);\n        this.pendingReplacementLoadBalancer = null;\n        this.innerBalancerState = this.replacementBalancerState;\n        this.innerBalancerPicker = this.replacementBalancerPicker;\n        this.updateState(this.replacementBalancerState, this.replacementBalancerPicker);\n    }\n    handleResolutionFailure(error) {\n        if (this.innerLoadBalancer === null ||\n            this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    exitIdle() {\n        if (this.innerLoadBalancer !== null) {\n            this.innerLoadBalancer.exitIdle();\n        }\n        if (this.currentState === channel_1.ConnectivityState.IDLE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        if (this.innerLoadBalancer !== null) {\n            this.innerLoadBalancer.resetBackoff();\n        }\n        if (this.pendingReplacementLoadBalancer !== null) {\n            this.pendingReplacementLoadBalancer.resetBackoff();\n        }\n    }\n    destroy() {\n        if (this.innerLoadBalancer !== null) {\n            this.innerLoadBalancer.destroy();\n            this.innerLoadBalancer = null;\n        }\n        if (this.pendingReplacementLoadBalancer !== null) {\n            this.pendingReplacementLoadBalancer.destroy();\n            this.pendingReplacementLoadBalancer = null;\n        }\n        this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n    replaceChannelControlHelper(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map"]},"metadata":{},"sourceType":"script"}