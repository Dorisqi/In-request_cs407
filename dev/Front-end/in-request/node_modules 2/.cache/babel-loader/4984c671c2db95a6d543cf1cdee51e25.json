{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n\n/* tslint:disable:no-any */\n\nconst lbconfig = require(\"./load-balancing-config\");\n\nconst os = require(\"os\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\n\n\nconst TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\n\nconst CLIENT_LANGUAGE_STRING = 'node';\n\nfunction validateName(obj) {\n  if (!('service' in obj) || typeof obj.service !== 'string') {\n    throw new Error('Invalid method config name: invalid service');\n  }\n\n  const result = {\n    service: obj.service\n  };\n\n  if ('method' in obj) {\n    if (typeof obj.method === 'string') {\n      result.method = obj.method;\n    } else {\n      throw new Error('Invalid method config name: invalid method');\n    }\n  }\n\n  return result;\n}\n\nfunction validateMethodConfig(obj) {\n  const result = {\n    name: []\n  };\n\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n\n    result.waitForReady = obj.waitForReady;\n  }\n\n  if ('timeout' in obj) {\n    if (!(typeof obj.timeout === 'string') || !TIMEOUT_REGEX.test(obj.timeout)) {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n\n    result.timeout = obj.timeout;\n  }\n\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n\n  return result;\n}\n\nfunction validateServiceConfig(obj) {\n  const result = {\n    loadBalancingConfig: [],\n    methodConfig: []\n  };\n\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(lbconfig.validateConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  } // Validate method name uniqueness\n\n\n  const seenMethodNames = [];\n\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (name.service === seenName.service && name.method === seenName.method) {\n          throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n        }\n      }\n\n      seenMethodNames.push(name);\n    }\n  }\n\n  return result;\n}\n\nexports.validateServiceConfig = validateServiceConfig;\n\nfunction validateCanaryConfig(obj) {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n\n  const result = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig)\n  };\n\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n\n  if ('percentage' in obj) {\n    if (typeof obj.percentage === 'number' && 0 <= obj.percentage && obj.percentage <= 100) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  } // Validate that no unexpected fields are present\n\n\n  const allowedFields = ['clientLanguage', 'percentage', 'clientHostname', 'serviceConfig'];\n\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(`Invalid service config choice: unexpected field ${field}`);\n    }\n  }\n\n  return result;\n}\n\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n\n    if (typeof validatedConfig.percentage === 'number' && percentage > validatedConfig.percentage) {\n      continue;\n    }\n\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n\n      if (!languageMatched) {\n        continue;\n      }\n    }\n\n    return validatedConfig.serviceConfig;\n  }\n\n  throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\n\n\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n\n  return null;\n}\n\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;","map":{"version":3,"sources":["../../src/service-config.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* tslint:disable:no-any */\nconst lbconfig = require(\"./load-balancing-config\");\nconst os = require(\"os\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n    if (!('service' in obj) || typeof obj.service !== 'string') {\n        throw new Error('Invalid method config name: invalid service');\n    }\n    const result = {\n        service: obj.service,\n    };\n    if ('method' in obj) {\n        if (typeof obj.method === 'string') {\n            result.method = obj.method;\n        }\n        else {\n            throw new Error('Invalid method config name: invalid method');\n        }\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    const result = {\n        name: [],\n    };\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\n        throw new Error('Invalid method config: invalid name array');\n    }\n    for (const name of obj.name) {\n        result.name.push(validateName(name));\n    }\n    if ('waitForReady' in obj) {\n        if (typeof obj.waitForReady !== 'boolean') {\n            throw new Error('Invalid method config: invalid waitForReady');\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if ('timeout' in obj) {\n        if (!(typeof obj.timeout === 'string') ||\n            !TIMEOUT_REGEX.test(obj.timeout)) {\n            throw new Error('Invalid method config: invalid timeout');\n        }\n        result.timeout = obj.timeout;\n    }\n    if ('maxRequestBytes' in obj) {\n        if (typeof obj.maxRequestBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if ('maxResponseBytes' in obj) {\n        if (typeof obj.maxResponseBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    return result;\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n    };\n    if ('loadBalancingPolicy' in obj) {\n        if (typeof obj.loadBalancingPolicy === 'string') {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\n        }\n    }\n    if ('loadBalancingConfig' in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig) {\n                result.loadBalancingConfig.push(lbconfig.validateConfig(config));\n            }\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\n        }\n    }\n    if ('methodConfig' in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig) {\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig) {\n        for (const name of methodConfig.name) {\n            for (const seenName of seenMethodNames) {\n                if (name.service === seenName.service &&\n                    name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!('serviceConfig' in obj)) {\n        throw new Error('Invalid service config choice: missing service config');\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\n    };\n    if ('clientLanguage' in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage) {\n                if (typeof lang === 'string') {\n                    result.clientLanguage.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n    }\n    if ('clientHostname' in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname) {\n                if (typeof lang === 'string') {\n                    result.clientHostname.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientHostname');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n    }\n    if ('percentage' in obj) {\n        if (typeof obj.percentage === 'number' &&\n            0 <= obj.percentage &&\n            obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid percentage');\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        'clientLanguage',\n        'percentage',\n        'clientHostname',\n        'serviceConfig',\n    ];\n    for (const field in obj) {\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error('Invalid service config list');\n    }\n    for (const config of obj) {\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */\n        if (typeof validatedConfig.percentage === 'number' &&\n            percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname) {\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage) {\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord) {\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n            const recordString = record.join('').substring('grpc_config='.length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n//# sourceMappingURL=service-config.js.map"]},"metadata":{},"sourceType":"script"}