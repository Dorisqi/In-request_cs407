{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nclass MetadataStatusFilter extends filter_1.BaseFilter {\n  async receiveTrailers(status) {\n    // tslint:disable-next-line:prefer-const\n    let {\n      code,\n      details,\n      metadata\n    } = await status;\n\n    if (code !== constants_1.Status.UNKNOWN) {\n      // we already have a known status, so don't assign a new one.\n      return {\n        code,\n        details,\n        metadata\n      };\n    }\n\n    const metadataMap = metadata.getMap();\n\n    if (typeof metadataMap['grpc-status'] === 'string') {\n      const receivedCode = Number(metadataMap['grpc-status']);\n\n      if (receivedCode in constants_1.Status) {\n        code = receivedCode;\n      }\n\n      metadata.remove('grpc-status');\n    }\n\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      details = decodeURI(metadataMap['grpc-message']);\n      metadata.remove('grpc-message');\n    }\n\n    return {\n      code,\n      details,\n      metadata\n    };\n  }\n\n}\n\nexports.MetadataStatusFilter = MetadataStatusFilter;\n\nclass MetadataStatusFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new MetadataStatusFilter();\n  }\n\n}\n\nexports.MetadataStatusFilterFactory = MetadataStatusFilterFactory;","map":{"version":3,"sources":["../../src/metadata-status-filter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAoBA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,oBAAb,SAA0C,QAAA,CAAA,UAA1C,CAAoD;AAClD,QAAM,eAAN,CAAsB,MAAtB,EAAmD;AACjD;AACA,QAAI;AAAE,MAAA,IAAF;AAAQ,MAAA,OAAR;AAAiB,MAAA;AAAjB,QAA8B,MAAM,MAAxC;;AACA,QAAI,IAAI,KAAK,WAAA,CAAA,MAAA,CAAO,OAApB,EAA6B;AAC3B;AACA,aAAO;AAAE,QAAA,IAAF;AAAQ,QAAA,OAAR;AAAiB,QAAA;AAAjB,OAAP;AACD;;AACD,UAAM,WAAW,GAAG,QAAQ,CAAC,MAAT,EAApB;;AACA,QAAI,OAAO,WAAW,CAAC,aAAD,CAAlB,KAAsC,QAA1C,EAAoD;AAClD,YAAM,YAAY,GAAG,MAAM,CAAC,WAAW,CAAC,aAAD,CAAZ,CAA3B;;AACA,UAAI,YAAY,IAAI,WAAA,CAAA,MAApB,EAA4B;AAC1B,QAAA,IAAI,GAAG,YAAP;AACD;;AACD,MAAA,QAAQ,CAAC,MAAT,CAAgB,aAAhB;AACD;;AACD,QAAI,OAAO,WAAW,CAAC,cAAD,CAAlB,KAAuC,QAA3C,EAAqD;AACnD,MAAA,OAAO,GAAG,SAAS,CAAC,WAAW,CAAC,cAAD,CAAZ,CAAnB;AACA,MAAA,QAAQ,CAAC,MAAT,CAAgB,cAAhB;AACD;;AACD,WAAO;AAAE,MAAA,IAAF;AAAQ,MAAA,OAAR;AAAiB,MAAA;AAAjB,KAAP;AACD;;AArBiD;;AAApD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAwBA,MAAa,2BAAb,CAAwC;AAEtC,EAAA,WAAA,CAA6B,OAA7B,EAA6C;AAAhB,SAAA,OAAA,GAAA,OAAA;AAAoB;;AACjD,EAAA,YAAY,CAAC,UAAD,EAAiB;AAC3B,WAAO,IAAI,oBAAJ,EAAP;AACD;;AALqC;;AAAxC,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nclass MetadataStatusFilter extends filter_1.BaseFilter {\n    async receiveTrailers(status) {\n        // tslint:disable-next-line:prefer-const\n        let { code, details, metadata } = await status;\n        if (code !== constants_1.Status.UNKNOWN) {\n            // we already have a known status, so don't assign a new one.\n            return { code, details, metadata };\n        }\n        const metadataMap = metadata.getMap();\n        if (typeof metadataMap['grpc-status'] === 'string') {\n            const receivedCode = Number(metadataMap['grpc-status']);\n            if (receivedCode in constants_1.Status) {\n                code = receivedCode;\n            }\n            metadata.remove('grpc-status');\n        }\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            details = decodeURI(metadataMap['grpc-message']);\n            metadata.remove('grpc-message');\n        }\n        return { code, details, metadata };\n    }\n}\nexports.MetadataStatusFilter = MetadataStatusFilter;\nclass MetadataStatusFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new MetadataStatusFilter();\n    }\n}\nexports.MetadataStatusFilterFactory = MetadataStatusFilterFactory;\n//# sourceMappingURL=metadata-status-filter.js.map"]},"metadata":{},"sourceType":"script"}