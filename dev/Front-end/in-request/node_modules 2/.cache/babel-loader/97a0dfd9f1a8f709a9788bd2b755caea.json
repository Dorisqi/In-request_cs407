{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.memoizerific = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      module.exports = function (forceSimilar) {\n        if (typeof Map !== 'function' || forceSimilar) {\n          var Similar = _dereq_('./similar');\n\n          return new Similar();\n        } else {\n          return new Map();\n        }\n      };\n    }, {\n      \"./similar\": 2\n    }],\n    2: [function (_dereq_, module, exports) {\n      function Similar() {\n        this.list = [];\n        this.lastItem = undefined;\n        this.size = 0;\n        return this;\n      }\n\n      Similar.prototype.get = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          return this.lastItem.val;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          return this.list[index].val;\n        }\n\n        return undefined;\n      };\n\n      Similar.prototype.set = function (key, val) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          this.lastItem.val = val;\n          return this;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          this.list[index].val = val;\n          return this;\n        }\n\n        this.lastItem = {\n          key: key,\n          val: val\n        };\n        this.list.push(this.lastItem);\n        this.size++;\n        return this;\n      };\n\n      Similar.prototype.delete = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          this.lastItem = undefined;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.size--;\n          return this.list.splice(index, 1)[0];\n        }\n\n        return undefined;\n      }; // important that has() doesn't use get() in case an existing key has a falsy value, in which case has() would return false\n\n\n      Similar.prototype.has = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          return true;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          return true;\n        }\n\n        return false;\n      };\n\n      Similar.prototype.forEach = function (callback, thisArg) {\n        var i;\n\n        for (i = 0; i < this.size; i++) {\n          callback.call(thisArg || this, this.list[i].val, this.list[i].key, this);\n        }\n      };\n\n      Similar.prototype.indexOf = function (key) {\n        var i;\n\n        for (i = 0; i < this.size; i++) {\n          if (this.isEqual(this.list[i].key, key)) {\n            return i;\n          }\n        }\n\n        return -1;\n      }; // check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\n\n\n      Similar.prototype.isEqual = function (val1, val2) {\n        return val1 === val2 || val1 !== val1 && val2 !== val2;\n      };\n\n      module.exports = Similar;\n    }, {}],\n    3: [function (_dereq_, module, exports) {\n      var MapOrSimilar = _dereq_('map-or-similar');\n\n      module.exports = function (limit) {\n        var cache = new MapOrSimilar(undefined === 'true'),\n            lru = [];\n        return function (fn) {\n          var memoizerific = function () {\n            var currentCache = cache,\n                newMap,\n                fnResult,\n                argsLengthMinusOne = arguments.length - 1,\n                lruPath = Array(argsLengthMinusOne + 1),\n                isMemoized = true,\n                i;\n\n            if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {\n              throw new Error('Memoizerific functions should always be called with the same number of arguments');\n            } // loop through each argument to traverse the map tree\n\n\n            for (i = 0; i < argsLengthMinusOne; i++) {\n              lruPath[i] = {\n                cacheItem: currentCache,\n                arg: arguments[i]\n              }; // climb through the hierarchical map tree until the second-last argument has been found, or an argument is missing.\n              // if all arguments up to the second-last have been found, this will potentially be a cache hit (determined later)\n\n              if (currentCache.has(arguments[i])) {\n                currentCache = currentCache.get(arguments[i]);\n                continue;\n              }\n\n              isMemoized = false; // make maps until last value\n\n              newMap = new MapOrSimilar(undefined === 'true');\n              currentCache.set(arguments[i], newMap);\n              currentCache = newMap;\n            } // we are at the last arg, check if it is really memoized\n\n\n            if (isMemoized) {\n              if (currentCache.has(arguments[argsLengthMinusOne])) {\n                fnResult = currentCache.get(arguments[argsLengthMinusOne]);\n              } else {\n                isMemoized = false;\n              }\n            }\n\n            if (!isMemoized) {\n              fnResult = fn.apply(null, arguments);\n              currentCache.set(arguments[argsLengthMinusOne], fnResult);\n            }\n\n            if (limit > 0) {\n              lruPath[argsLengthMinusOne] = {\n                cacheItem: currentCache,\n                arg: arguments[argsLengthMinusOne]\n              };\n\n              if (isMemoized) {\n                moveToMostRecentLru(lru, lruPath);\n              } else {\n                lru.push(lruPath);\n              }\n\n              if (lru.length > limit) {\n                removeCachedResult(lru.shift());\n              }\n            }\n\n            memoizerific.wasMemoized = isMemoized;\n            memoizerific.numArgs = argsLengthMinusOne + 1;\n            return fnResult;\n          };\n\n          memoizerific.limit = limit;\n          memoizerific.wasMemoized = false;\n          memoizerific.cache = cache;\n          memoizerific.lru = lru;\n          return memoizerific;\n        };\n      }; // move current args to most recent position\n\n\n      function moveToMostRecentLru(lru, lruPath) {\n        var lruLen = lru.length,\n            lruPathLen = lruPath.length,\n            isMatch,\n            i,\n            ii;\n\n        for (i = 0; i < lruLen; i++) {\n          isMatch = true;\n\n          for (ii = 0; ii < lruPathLen; ii++) {\n            if (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {\n              isMatch = false;\n              break;\n            }\n          }\n\n          if (isMatch) {\n            break;\n          }\n        }\n\n        lru.push(lru.splice(i, 1)[0]);\n      } // remove least recently used cache item and all dead branches\n\n\n      function removeCachedResult(removedLru) {\n        var removedLruLen = removedLru.length,\n            currentLru = removedLru[removedLruLen - 1],\n            tmp,\n            i;\n        currentLru.cacheItem.delete(currentLru.arg); // walk down the tree removing dead branches (size 0) along the way\n\n        for (i = removedLruLen - 2; i >= 0; i--) {\n          currentLru = removedLru[i];\n          tmp = currentLru.cacheItem.get(currentLru.arg);\n\n          if (!tmp || !tmp.size) {\n            currentLru.cacheItem.delete(currentLru.arg);\n          } else {\n            break;\n          }\n        }\n      } // check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\n\n\n      function isEqual(val1, val2) {\n        return val1 === val2 || val1 !== val1 && val2 !== val2;\n      }\n    }, {\n      \"map-or-similar\": 1\n    }]\n  }, {}, [3])(3);\n});","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/memoizerific/memoizerific.js"],"names":["f","exports","module","define","amd","g","window","global","self","memoizerific","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","_dereq_","forceSimilar","Map","Similar","list","lastItem","undefined","size","prototype","get","key","index","isEqual","val","indexOf","set","push","delete","splice","has","forEach","callback","thisArg","val1","val2","MapOrSimilar","limit","cache","lru","fn","currentCache","newMap","fnResult","argsLengthMinusOne","arguments","lruPath","Array","isMemoized","numArgs","cacheItem","arg","apply","moveToMostRecentLru","removeCachedResult","shift","wasMemoized","lruLen","lruPathLen","isMatch","ii","removedLru","removedLruLen","currentLru","tmp"],"mappings":"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","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.memoizerific = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports = function(forceSimilar) {\n\tif (typeof Map !== 'function' || forceSimilar) {\n\t\tvar Similar = _dereq_('./similar');\n\t\treturn new Similar();\n\t}\n\telse {\n\t\treturn new Map();\n\t}\n}\n\n},{\"./similar\":2}],2:[function(_dereq_,module,exports){\nfunction Similar() {\n\tthis.list = [];\n\tthis.lastItem = undefined;\n\tthis.size = 0;\n\n\treturn this;\n}\n\nSimilar.prototype.get = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\treturn this.lastItem.val;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\treturn this.list[index].val;\n\t}\n\n\treturn undefined;\n};\n\nSimilar.prototype.set = function(key, val) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\tthis.lastItem.val = val;\n\t\treturn this;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\tthis.list[index].val = val;\n\t\treturn this;\n\t}\n\n\tthis.lastItem = { key: key, val: val };\n\tthis.list.push(this.lastItem);\n\tthis.size++;\n\n\treturn this;\n};\n\nSimilar.prototype.delete = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\tthis.lastItem = undefined;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.size--;\n\t\treturn this.list.splice(index, 1)[0];\n\t}\n\n\treturn undefined;\n};\n\n\n// important that has() doesn't use get() in case an existing key has a falsy value, in which case has() would return false\nSimilar.prototype.has = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\treturn true;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nSimilar.prototype.forEach = function(callback, thisArg) {\n\tvar i;\n\tfor (i = 0; i < this.size; i++) {\n\t\tcallback.call(thisArg || this, this.list[i].val, this.list[i].key, this);\n\t}\n};\n\nSimilar.prototype.indexOf = function(key) {\n\tvar i;\n\tfor (i = 0; i < this.size; i++) {\n\t\tif (this.isEqual(this.list[i].key, key)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n// check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\nSimilar.prototype.isEqual = function(val1, val2) {\n\treturn val1 === val2 || (val1 !== val1 && val2 !== val2);\n};\n\nmodule.exports = Similar;\n},{}],3:[function(_dereq_,module,exports){\nvar MapOrSimilar = _dereq_('map-or-similar');\n\nmodule.exports = function (limit) {\n\tvar cache = new MapOrSimilar(undefined === 'true'),\n\t\tlru = [];\n\n\treturn function (fn) {\n\t\tvar memoizerific = function () {\n\t\t\tvar currentCache = cache,\n\t\t\t\tnewMap,\n\t\t\t\tfnResult,\n\t\t\t\targsLengthMinusOne = arguments.length - 1,\n\t\t\t\tlruPath = Array(argsLengthMinusOne + 1),\n\t\t\t\tisMemoized = true,\n\t\t\t\ti;\n\n\t\t\tif ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {\n\t\t\t\tthrow new Error('Memoizerific functions should always be called with the same number of arguments');\n\t\t\t}\n\n\t\t\t// loop through each argument to traverse the map tree\n\t\t\tfor (i = 0; i < argsLengthMinusOne; i++) {\n\t\t\t\tlruPath[i] = {\n\t\t\t\t\tcacheItem: currentCache,\n\t\t\t\t\targ: arguments[i]\n\t\t\t\t};\n\n\t\t\t\t// climb through the hierarchical map tree until the second-last argument has been found, or an argument is missing.\n\t\t\t\t// if all arguments up to the second-last have been found, this will potentially be a cache hit (determined later)\n\t\t\t\tif (currentCache.has(arguments[i])) {\n\t\t\t\t\tcurrentCache = currentCache.get(arguments[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tisMemoized = false;\n\n\t\t\t\t// make maps until last value\n\t\t\t\tnewMap = new MapOrSimilar(undefined === 'true');\n\t\t\t\tcurrentCache.set(arguments[i], newMap);\n\t\t\t\tcurrentCache = newMap;\n\t\t\t}\n\n\t\t\t// we are at the last arg, check if it is really memoized\n\t\t\tif (isMemoized) {\n\t\t\t\tif (currentCache.has(arguments[argsLengthMinusOne])) {\n\t\t\t\t\tfnResult = currentCache.get(arguments[argsLengthMinusOne]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisMemoized = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isMemoized) {\n\t\t\t\tfnResult = fn.apply(null, arguments);\n\t\t\t\tcurrentCache.set(arguments[argsLengthMinusOne], fnResult);\n\t\t\t}\n\n\t\t\tif (limit > 0) {\n\t\t\t\tlruPath[argsLengthMinusOne] = {\n\t\t\t\t\tcacheItem: currentCache,\n\t\t\t\t\targ: arguments[argsLengthMinusOne]\n\t\t\t\t};\n\n\t\t\t\tif (isMemoized) {\n\t\t\t\t\tmoveToMostRecentLru(lru, lruPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlru.push(lruPath);\n\t\t\t\t}\n\n\t\t\t\tif (lru.length > limit) {\n\t\t\t\t\tremoveCachedResult(lru.shift());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemoizerific.wasMemoized = isMemoized;\n\t\t\tmemoizerific.numArgs = argsLengthMinusOne + 1;\n\n\t\t\treturn fnResult;\n\t\t};\n\n\t\tmemoizerific.limit = limit;\n\t\tmemoizerific.wasMemoized = false;\n\t\tmemoizerific.cache = cache;\n\t\tmemoizerific.lru = lru;\n\n\t\treturn memoizerific;\n\t};\n};\n\n// move current args to most recent position\nfunction moveToMostRecentLru(lru, lruPath) {\n\tvar lruLen = lru.length,\n\t\tlruPathLen = lruPath.length,\n\t\tisMatch,\n\t\ti, ii;\n\n\tfor (i = 0; i < lruLen; i++) {\n\t\tisMatch = true;\n\t\tfor (ii = 0; ii < lruPathLen; ii++) {\n\t\t\tif (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {\n\t\t\t\tisMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlru.push(lru.splice(i, 1)[0]);\n}\n\n// remove least recently used cache item and all dead branches\nfunction removeCachedResult(removedLru) {\n\tvar removedLruLen = removedLru.length,\n\t\tcurrentLru = removedLru[removedLruLen - 1],\n\t\ttmp,\n\t\ti;\n\n\tcurrentLru.cacheItem.delete(currentLru.arg);\n\n\t// walk down the tree removing dead branches (size 0) along the way\n\tfor (i = removedLruLen - 2; i >= 0; i--) {\n\t\tcurrentLru = removedLru[i];\n\t\ttmp = currentLru.cacheItem.get(currentLru.arg);\n\n\t\tif (!tmp || !tmp.size) {\n\t\t\tcurrentLru.cacheItem.delete(currentLru.arg);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\nfunction isEqual(val1, val2) {\n\treturn val1 === val2 || (val1 !== val1 && val2 !== val2);\n}\n},{\"map-or-similar\":1}]},{},[3])(3)\n});"]},"metadata":{},"sourceType":"script"}