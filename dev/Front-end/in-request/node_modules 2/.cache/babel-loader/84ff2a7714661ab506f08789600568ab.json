{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst call_1 = require(\"./call\");\n\nconst channel_1 = require(\"./channel\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst CHANNEL_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\nclass Client {\n  constructor(address, credentials, options = {}) {\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      this[CHANNEL_SYMBOL] = options.channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n\n      let newState;\n\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n\n      if (newState === channel_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n\n    setImmediate(checkState);\n  }\n\n  handleUnaryResponse(call, deserialize, callback) {\n    let responseMessage = null;\n    call.on('data', data => {\n      if (responseMessage != null) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n      }\n\n      try {\n        responseMessage = deserialize(data);\n      } catch (e) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      }\n    });\n    call.on('status', status => {\n      /* We assume that call emits status after it emits end, and that it\n       * accounts for any cancelWithStatus calls up until it emits status.\n       * Therefore, considering the above event handlers, status.code should be\n       * OK if and only if we have a non-null responseMessage */\n      if (status.code === constants_1.Status.OK) {\n        callback(null, responseMessage);\n      } else {\n        callback(call_1.callErrorFromStatus(status));\n      }\n    });\n  }\n\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (arg1 instanceof Function) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (arg2 instanceof Function) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n        throw new Error('Incorrect arguments passed');\n      }\n\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    ({\n      metadata,\n      options,\n      callback\n    } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientUnaryCallImpl(call);\n  }\n\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    ({\n      metadata,\n      options,\n      callback\n    } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    call.sendMetadata(metadata);\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientWritableStreamImpl(call, serialize);\n  }\n\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n\n      metadata = new metadata_1.Metadata();\n    }\n\n    return {\n      metadata,\n      options\n    };\n  }\n\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    ({\n      metadata,\n      options\n    } = this.checkMetadataAndOptions(metadata, options));\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    return new call_1.ClientReadableStreamImpl(call, deserialize);\n  }\n\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    ({\n      metadata,\n      options\n    } = this.checkMetadataAndOptions(metadata, options));\n    const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n\n    call.sendMetadata(metadata);\n    return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n  }\n\n}\n\nexports.Client = Client;","map":{"version":3,"sources":["../../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst CHANNEL_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            this[CHANNEL_SYMBOL] = options.channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === channel_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    handleUnaryResponse(call, deserialize, callback) {\n        let responseMessage = null;\n        call.on('data', (data) => {\n            if (responseMessage != null) {\n                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n            }\n            try {\n                responseMessage = deserialize(data);\n            }\n            catch (e) {\n                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n            }\n        });\n        call.on('status', (status) => {\n            /* We assume that call emits status after it emits end, and that it\n             * accounts for any cancelWithStatus calls up until it emits status.\n             * Therefore, considering the above event handlers, status.code should be\n             * OK if and only if we have a non-null responseMessage */\n            if (status.code === constants_1.Status.OK) {\n                callback(null, responseMessage);\n            }\n            else {\n                callback(call_1.callErrorFromStatus(status));\n            }\n        });\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (arg1 instanceof Function) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (arg2 instanceof Function) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                arg3 instanceof Function)) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        ({ metadata, options, callback } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        const message = serialize(argument);\n        const writeObj = { message };\n        call.sendMetadata(metadata);\n        call.write(writeObj);\n        call.end();\n        this.handleUnaryResponse(call, deserialize, callback);\n        return new call_1.ClientUnaryCallImpl(call);\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        ({ metadata, options, callback } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        call.sendMetadata(metadata);\n        this.handleUnaryResponse(call, deserialize, callback);\n        return new call_1.ClientWritableStreamImpl(call, serialize);\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));\n        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        const message = serialize(argument);\n        const writeObj = { message };\n        call.sendMetadata(metadata);\n        call.write(writeObj);\n        call.end();\n        return new call_1.ClientReadableStreamImpl(call, deserialize);\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));\n        const call = this[CHANNEL_SYMBOL].createCall(method, options.deadline, options.host, null, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        call.sendMetadata(metadata);\n        return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}