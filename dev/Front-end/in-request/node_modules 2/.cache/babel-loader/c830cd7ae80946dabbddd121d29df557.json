{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst zlib = require(\"zlib\");\n\nconst filter_1 = require(\"./filter\");\n\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message, compress) {\n    let messageBuffer = message;\n\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n\n\n  async readMessage(data) {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n\n    return messageBuffer;\n  }\n\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message) {\n    return message;\n  }\n\n  async writeMessage(message, compress) {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n\n}\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor() {\n    super(...arguments);\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n  }\n\n  async sendMetadata(metadata) {\n    const headers = await metadata;\n    headers.set('grpc-encoding', 'identity');\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    return headers;\n  }\n\n  async receiveMetadata(metadata) {\n    const headers = await metadata;\n    const receiveEncoding = headers.get('grpc-encoding');\n\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n\n    headers.remove('grpc-encoding');\n    headers.remove('grpc-accept-encoding');\n    return headers;\n  }\n\n  async sendMessage(message) {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage = await message;\n    const compress = resolvedMessage.flags === undefined ? false : (resolvedMessage.flags & 2\n    /* NoCompress */\n    ) === 0;\n    return {\n      message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n      flags: resolvedMessage.flags\n    };\n  }\n\n  async receiveMessage(message) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage((await message));\n  }\n\n}\n\nexports.CompressionFilter = CompressionFilter;\n\nclass CompressionFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new CompressionFilter();\n  }\n\n}\n\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":{"version":3,"sources":["../../src/compression-filter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst zlib = require(\"zlib\");\nconst filter_1 = require(\"./filter\");\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.inflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.unzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler();\n        case 'gzip':\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor() {\n        super(...arguments);\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-encoding', 'identity');\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        return headers;\n    }\n    async receiveMetadata(metadata) {\n        const headers = await metadata;\n        const receiveEncoding = headers.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        headers.remove('grpc-encoding');\n        headers.remove('grpc-accept-encoding');\n        return headers;\n    }\n    async sendMessage(message) {\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        const compress = resolvedMessage.flags === undefined\n            ? false\n            : (resolvedMessage.flags & 2 /* NoCompress */) === 0;\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CompressionFilter();\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map"]},"metadata":{},"sourceType":"script"}