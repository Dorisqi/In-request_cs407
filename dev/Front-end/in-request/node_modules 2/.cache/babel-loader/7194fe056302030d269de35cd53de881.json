{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Path template utility.\n */\n\nconst has = require(\"lodash.has\");\n\nconst util = require(\"util\");\n\nconst extras = require(\"./parserExtras\");\n\nconst parser = require('./pathTemplateParser');\n\nclass PathTemplate {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.parseResult = extras.finishParse(parser.parse(data));\n  }\n\n  get size() {\n    return this.parseResult.size;\n  }\n\n  get segments() {\n    return this.parseResult.segments;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  match(path) {\n    const pathSegments = path.split('/');\n    const bindings = {};\n    let segmentCount = this.size;\n    let current;\n    let index = 0;\n    this.segments.forEach(segment => {\n      if (index > pathSegments.length) {\n        return;\n      }\n\n      if (segment.kind === extras.BINDING) {\n        current = segment.literal;\n      } else if (segment.kind === extras.TERMINAL) {\n        if (segment.literal === '*') {\n          bindings[current] = pathSegments[index];\n          index += 1;\n        } else if (segment.literal === '**') {\n          const size = pathSegments.length - segmentCount + 1;\n          segmentCount += size - 1;\n          bindings[current] = pathSegments.slice(index, index + size).join('/');\n          index += size;\n        } else if (segment.literal === pathSegments[index]) {\n          index += 1;\n        } else {\n          const msg = util.format(\"mismatched literal (index=%d): '%s' != '%s'\", index, segment.literal, pathSegments[index]);\n          throw new TypeError(msg);\n        }\n      }\n    });\n\n    if (index !== pathSegments.length || index !== segmentCount) {\n      const msg = util.format('match error: could not instantiate a path template from %s', path);\n      throw new TypeError(msg);\n    }\n\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n\n\n  render(bindings) {\n    const out = [];\n    let inABinding = false;\n    this.segments.forEach(segment => {\n      if (segment.kind === extras.BINDING) {\n        if (!has(bindings, segment.literal)) {\n          const msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n          throw new TypeError(msg);\n        }\n\n        const tmp = new PathTemplate(bindings[segment.literal]);\n        Array.prototype.push.apply(out, tmp.segments);\n        inABinding = true;\n      } else if (segment.kind === extras.END_BINDING) {\n        inABinding = false;\n      } else if (inABinding) {\n        return;\n      } else {\n        out.push(segment);\n      }\n    });\n    const result = formatSegments(out);\n    this.match(result);\n    return result;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n\n\n  inspect() {\n    return formatSegments(this.segments);\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\n\nfunction formatSegments(segments) {\n  let out = '';\n  let slash = true;\n  segments.forEach(segment => {\n    if (segment.kind === extras.TERMINAL) {\n      if (slash) {\n        out += '/';\n      }\n\n      out += segment.literal;\n      return;\n    }\n\n    slash = true;\n\n    if (segment.kind === extras.BINDING) {\n      out += '/{' + segment.literal + '=';\n      slash = false;\n    } else {\n      out += segment.literal + '}';\n    }\n  });\n  return out.substring(1);\n}","map":{"version":3,"sources":["../../src/pathTemplate.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAgBA;;;;AAIA,MAAA,GAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAM,MAAM,GAAG,OAAO,CAAC,sBAAD,CAAtB;;AAgBA,MAAa,YAAb,CAAyB;AAWvB;;;;;AAKA,EAAA,WAAA,CAAY,IAAZ,EAAwB;AACtB,SAAK,WAAL,GAAmB,MAAM,CAAC,WAAP,CAAmB,MAAM,CAAC,KAAP,CAAa,IAAb,CAAnB,CAAnB;AACD;;AAfD,MAAI,IAAJ,GAAQ;AACN,WAAO,KAAK,WAAL,CAAiB,IAAxB;AACD;;AAED,MAAI,QAAJ,GAAY;AACV,WAAO,KAAK,WAAL,CAAiB,QAAxB;AACD;AAWD;;;;;;;;;AAOA,EAAA,KAAK,CAAC,IAAD,EAAa;AAChB,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAArB;AACA,UAAM,QAAQ,GAAa,EAA3B;AACA,QAAI,YAAY,GAAG,KAAK,IAAxB;AACA,QAAI,OAAJ;AACA,QAAI,KAAK,GAAG,CAAZ;AACA,SAAK,QAAL,CAAc,OAAd,CAAsB,OAAO,IAAG;AAC9B,UAAI,KAAK,GAAG,YAAY,CAAC,MAAzB,EAAiC;AAC/B;AACD;;AACD,UAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,OAA5B,EAAqC;AACnC,QAAA,OAAO,GAAG,OAAO,CAAC,OAAlB;AACD,OAFD,MAEO,IAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,QAA5B,EAAsC;AAC3C,YAAI,OAAO,CAAC,OAAR,KAAoB,GAAxB,EAA6B;AAC3B,UAAA,QAAQ,CAAC,OAAD,CAAR,GAAoB,YAAY,CAAC,KAAD,CAAhC;AACA,UAAA,KAAK,IAAI,CAAT;AACD,SAHD,MAGO,IAAI,OAAO,CAAC,OAAR,KAAoB,IAAxB,EAA8B;AACnC,gBAAM,IAAI,GAAG,YAAY,CAAC,MAAb,GAAsB,YAAtB,GAAqC,CAAlD;AACA,UAAA,YAAY,IAAI,IAAI,GAAG,CAAvB;AACA,UAAA,QAAQ,CAAC,OAAD,CAAR,GAAoB,YAAY,CAAC,KAAb,CAAmB,KAAnB,EAA0B,KAAK,GAAG,IAAlC,EAAwC,IAAxC,CAA6C,GAA7C,CAApB;AACA,UAAA,KAAK,IAAI,IAAT;AACD,SALM,MAKA,IAAI,OAAO,CAAC,OAAR,KAAoB,YAAY,CAAC,KAAD,CAApC,EAA6C;AAClD,UAAA,KAAK,IAAI,CAAT;AACD,SAFM,MAEA;AACL,gBAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CACV,6CADU,EAEV,KAFU,EAGV,OAAO,CAAC,OAHE,EAIV,YAAY,CAAC,KAAD,CAJF,CAAZ;AAMA,gBAAM,IAAI,SAAJ,CAAc,GAAd,CAAN;AACD;AACF;AACF,KA3BD;;AA4BA,QAAI,KAAK,KAAK,YAAY,CAAC,MAAvB,IAAiC,KAAK,KAAK,YAA/C,EAA6D;AAC3D,YAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CACV,4DADU,EAEV,IAFU,CAAZ;AAIA,YAAM,IAAI,SAAJ,CAAc,GAAd,CAAN;AACD;;AACD,WAAO,QAAP;AACD;AAED;;;;;;;;;;AAQA,EAAA,MAAM,CAAC,QAAD,EAAmB;AACvB,UAAM,GAAG,GAAc,EAAvB;AACA,QAAI,UAAU,GAAG,KAAjB;AACA,SAAK,QAAL,CAAc,OAAd,CAAsB,OAAO,IAAG;AAC9B,UAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,OAA5B,EAAqC;AACnC,YAAI,CAAC,GAAG,CAAC,QAAD,EAAW,OAAO,CAAC,OAAnB,CAAR,EAAqC;AACnC,gBAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CACV,wCADU,EAEV,OAAO,CAAC,OAFE,EAGV,QAHU,CAAZ;AAKA,gBAAM,IAAI,SAAJ,CAAc,GAAd,CAAN;AACD;;AACD,cAAM,GAAG,GAAG,IAAI,YAAJ,CAAiB,QAAQ,CAAC,OAAO,CAAC,OAAT,CAAzB,CAAZ;AACA,QAAA,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,KAArB,CAA2B,GAA3B,EAAgC,GAAG,CAAC,QAApC;AACA,QAAA,UAAU,GAAG,IAAb;AACD,OAZD,MAYO,IAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,WAA5B,EAAyC;AAC9C,QAAA,UAAU,GAAG,KAAb;AACD,OAFM,MAEA,IAAI,UAAJ,EAAgB;AACrB;AACD,OAFM,MAEA;AACL,QAAA,GAAG,CAAC,IAAJ,CAAS,OAAT;AACD;AACF,KApBD;AAsBA,UAAM,MAAM,GAAG,cAAc,CAAC,GAAD,CAA7B;AACA,SAAK,KAAL,CAAW,MAAX;AACA,WAAO,MAAP;AACD;AAED;;;;;;;AAKA,EAAA,OAAO,GAAA;AACL,WAAO,cAAc,CAAC,KAAK,QAAN,CAArB;AACD;;AApHsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA;AAuHA;;;;;;;AAMA,SAAS,cAAT,CAAwB,QAAxB,EAA2C;AACzC,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,KAAK,GAAG,IAAZ;AACA,EAAA,QAAQ,CAAC,OAAT,CAAiB,OAAO,IAAG;AACzB,QAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,QAA5B,EAAsC;AACpC,UAAI,KAAJ,EAAW;AACT,QAAA,GAAG,IAAI,GAAP;AACD;;AACD,MAAA,GAAG,IAAI,OAAO,CAAC,OAAf;AACA;AACD;;AACD,IAAA,KAAK,GAAG,IAAR;;AACA,QAAI,OAAO,CAAC,IAAR,KAAiB,MAAM,CAAC,OAA5B,EAAqC;AACnC,MAAA,GAAG,IAAI,OAAO,OAAO,CAAC,OAAf,GAAyB,GAAhC;AACA,MAAA,KAAK,GAAG,KAAR;AACD,KAHD,MAGO;AACL,MAAA,GAAG,IAAI,OAAO,CAAC,OAAR,GAAkB,GAAzB;AACD;AACF,GAfD;AAgBA,SAAO,GAAG,CAAC,SAAJ,CAAc,CAAd,CAAP;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Path template utility.\n */\nconst has = require(\"lodash.has\");\nconst util = require(\"util\");\nconst extras = require(\"./parserExtras\");\nconst parser = require('./pathTemplateParser');\nclass PathTemplate {\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n    constructor(data) {\n        this.parseResult = extras.finishParse(parser.parse(data));\n    }\n    get size() {\n        return this.parseResult.size;\n    }\n    get segments() {\n        return this.parseResult.segments;\n    }\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    match(path) {\n        const pathSegments = path.split('/');\n        const bindings = {};\n        let segmentCount = this.size;\n        let current;\n        let index = 0;\n        this.segments.forEach(segment => {\n            if (index > pathSegments.length) {\n                return;\n            }\n            if (segment.kind === extras.BINDING) {\n                current = segment.literal;\n            }\n            else if (segment.kind === extras.TERMINAL) {\n                if (segment.literal === '*') {\n                    bindings[current] = pathSegments[index];\n                    index += 1;\n                }\n                else if (segment.literal === '**') {\n                    const size = pathSegments.length - segmentCount + 1;\n                    segmentCount += size - 1;\n                    bindings[current] = pathSegments.slice(index, index + size).join('/');\n                    index += size;\n                }\n                else if (segment.literal === pathSegments[index]) {\n                    index += 1;\n                }\n                else {\n                    const msg = util.format(\"mismatched literal (index=%d): '%s' != '%s'\", index, segment.literal, pathSegments[index]);\n                    throw new TypeError(msg);\n                }\n            }\n        });\n        if (index !== pathSegments.length || index !== segmentCount) {\n            const msg = util.format('match error: could not instantiate a path template from %s', path);\n            throw new TypeError(msg);\n        }\n        return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n    render(bindings) {\n        const out = [];\n        let inABinding = false;\n        this.segments.forEach(segment => {\n            if (segment.kind === extras.BINDING) {\n                if (!has(bindings, segment.literal)) {\n                    const msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n                    throw new TypeError(msg);\n                }\n                const tmp = new PathTemplate(bindings[segment.literal]);\n                Array.prototype.push.apply(out, tmp.segments);\n                inABinding = true;\n            }\n            else if (segment.kind === extras.END_BINDING) {\n                inABinding = false;\n            }\n            else if (inABinding) {\n                return;\n            }\n            else {\n                out.push(segment);\n            }\n        });\n        const result = formatSegments(out);\n        this.match(result);\n        return result;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n    inspect() {\n        return formatSegments(this.segments);\n    }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\nfunction formatSegments(segments) {\n    let out = '';\n    let slash = true;\n    segments.forEach(segment => {\n        if (segment.kind === extras.TERMINAL) {\n            if (slash) {\n                out += '/';\n            }\n            out += segment.literal;\n            return;\n        }\n        slash = true;\n        if (segment.kind === extras.BINDING) {\n            out += '/{' + segment.literal + '=';\n            slash = false;\n        }\n        else {\n            out += segment.literal + '}';\n        }\n    });\n    return out.substring(1);\n}\n//# sourceMappingURL=pathTemplate.js.map"]},"metadata":{},"sourceType":"script"}