{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http2 = require(\"http2\");\n\nconst url_1 = require(\"url\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst server_call_1 = require(\"./server-call\");\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n} // tslint:enable:no-any\n\n\nclass Server {\n  constructor(options) {\n    this.http2Server = null;\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(service, implementation) {\n    if (this.started === true) {\n      throw new Error(\"Can't add a service to a started server.\");\n    }\n\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || typeof creds !== 'object') {\n      throw new TypeError('creds must be an object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const url = new url_1.URL(`http://${port}`);\n    const options = {\n      host: url.hostname,\n      port: +url.port\n    };\n    const serverOptions = {};\n\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n\n    if (creds._isSecure()) {\n      const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n      this.http2Server = http2.createSecureServer(secureServerOptions);\n    } else {\n      this.http2Server = http2.createServer(serverOptions);\n    }\n\n    this.http2Server.setTimeout(0, noop);\n\n    this._setupHandlers();\n\n    function onError(err) {\n      callback(err, -1);\n    }\n\n    this.http2Server.once('error', onError);\n    this.http2Server.listen(options, () => {\n      const server = this.http2Server;\n      const port = server.address().port;\n      server.removeListener('error', onError);\n      callback(null, port);\n    });\n  }\n\n  forceShutdown() {\n    // Close the server if it is still running.\n    if (this.http2Server && this.http2Server.listening) {\n      this.http2Server.close();\n    }\n\n    this.started = false; // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n    this.sessions.forEach(session => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // tslint:disable-next-line:no-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n  }\n\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type\n    });\n    return true;\n  }\n\n  start() {\n    if (this.http2Server === null || this.http2Server.listening !== true) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    this.started = true;\n  }\n\n  tryShutdown(callback) {\n    let pendingChecks = 0;\n\n    function maybeCallback() {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    } // Close the server if necessary.\n\n\n    this.started = false;\n\n    if (this.http2Server && this.http2Server.listening) {\n      pendingChecks++;\n      this.http2Server.close(maybeCallback);\n    } // If any sessions are active, close them gracefully.\n\n\n    pendingChecks += this.sessions.size;\n    this.sessions.forEach(session => {\n      session.close(maybeCallback);\n    }); // If the server is closed and there are no active sessions, just call back.\n\n    if (pendingChecks === 0) {\n      callback();\n    }\n  }\n\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n\n  _setupHandlers() {\n    if (this.http2Server === null) {\n      return;\n    }\n\n    this.http2Server.on('stream', (stream, headers) => {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return;\n      }\n\n      try {\n        const path = headers[http2.constants.HTTP2_HEADER_PATH];\n        const handler = this.handlers.get(path);\n\n        if (handler === undefined) {\n          throw getUnimplementedStatusResponse(path);\n        }\n\n        const call = new server_call_1.Http2ServerCallStream(stream, handler);\n        const metadata = call.receiveMetadata(headers);\n\n        switch (handler.type) {\n          case 'unary':\n            handleUnary(call, handler, metadata);\n            break;\n\n          case 'clientStream':\n            handleClientStreaming(call, handler, metadata);\n            break;\n\n          case 'serverStream':\n            handleServerStreaming(call, handler, metadata);\n            break;\n\n          case 'bidi':\n            handleBidiStreaming(call, handler, metadata);\n            break;\n\n          default:\n            throw new Error(`Unknown handler type: ${handler.type}`);\n        }\n      } catch (err) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null);\n\n        if (err.code === undefined) {\n          err.code = constants_1.Status.INTERNAL;\n        }\n\n        call.sendError(err);\n      }\n    });\n    this.http2Server.on('session', session => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      this.sessions.add(session);\n    });\n  }\n\n}\n\nexports.Server = Server;\n\nasync function handleUnary(call, handler, metadata) {\n  const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n  const request = await call.receiveUnaryMessage();\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  emitter.request = request;\n  handler.func(emitter, (err, value, trailer, flags) => {\n    call.sendUnaryMessage(err, value, trailer, flags);\n  });\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nasync function handleServerStreaming(call, handler, metadata) {\n  const request = await call.receiveUnaryMessage();\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n  stream.request = request;\n  handler.func(stream);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}","map":{"version":3,"sources":["../../src/server.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http2 = require(\"http2\");\nconst url_1 = require(\"url\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst server_call_1 = require(\"./server-call\");\nfunction noop() { }\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n        metadata: new metadata_1.Metadata(),\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\n// tslint:enable:no-any\nclass Server {\n    constructor(options) {\n        this.http2Server = null;\n        this.handlers = new Map();\n        this.sessions = new Set();\n        this.started = false;\n        this.options = (options !== null && options !== void 0 ? options : {});\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (this.started === true) {\n            throw new Error(\"Can't add a service to a started server.\");\n        }\n        if (service === null ||\n            typeof service !== 'object' ||\n            implementation === null ||\n            typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach(name => {\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                }\n                else {\n                    methodType = 'clientStream';\n                }\n            }\n            else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                }\n                else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            }\n            else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || typeof creds !== 'object') {\n            throw new TypeError('creds must be an object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const url = new url_1.URL(`http://${port}`);\n        const options = { host: url.hostname, port: +url.port };\n        const serverOptions = {};\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n            };\n        }\n        if (creds._isSecure()) {\n            const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n            this.http2Server = http2.createSecureServer(secureServerOptions);\n        }\n        else {\n            this.http2Server = http2.createServer(serverOptions);\n        }\n        this.http2Server.setTimeout(0, noop);\n        this._setupHandlers();\n        function onError(err) {\n            callback(err, -1);\n        }\n        this.http2Server.once('error', onError);\n        this.http2Server.listen(options, () => {\n            const server = this.http2Server;\n            const port = server.address().port;\n            server.removeListener('error', onError);\n            callback(null, port);\n        });\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        if (this.http2Server && this.http2Server.listening) {\n            this.http2Server.close();\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach(session => {\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // tslint:disable-next-line:no-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n        });\n        return true;\n    }\n    start() {\n        if (this.http2Server === null || this.http2Server.listening !== true) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                callback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        if (this.http2Server && this.http2Server.listening) {\n            pendingChecks++;\n            this.http2Server.close(maybeCallback);\n        }\n        // If any sessions are active, close them gracefully.\n        pendingChecks += this.sessions.size;\n        this.sessions.forEach(session => {\n            session.close(maybeCallback);\n        });\n        // If the server is closed and there are no active sessions, just call back.\n        if (pendingChecks === 0) {\n            callback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    _setupHandlers() {\n        if (this.http2Server === null) {\n            return;\n        }\n        this.http2Server.on('stream', (stream, headers) => {\n            const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n            if (typeof contentType !== 'string' ||\n                !contentType.startsWith('application/grpc')) {\n                stream.respond({\n                    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n                }, { endStream: true });\n                return;\n            }\n            try {\n                const path = headers[http2.constants.HTTP2_HEADER_PATH];\n                const handler = this.handlers.get(path);\n                if (handler === undefined) {\n                    throw getUnimplementedStatusResponse(path);\n                }\n                const call = new server_call_1.Http2ServerCallStream(stream, handler);\n                const metadata = call.receiveMetadata(headers);\n                switch (handler.type) {\n                    case 'unary':\n                        handleUnary(call, handler, metadata);\n                        break;\n                    case 'clientStream':\n                        handleClientStreaming(call, handler, metadata);\n                        break;\n                    case 'serverStream':\n                        handleServerStreaming(call, handler, metadata);\n                        break;\n                    case 'bidi':\n                        handleBidiStreaming(call, handler, metadata);\n                        break;\n                    default:\n                        throw new Error(`Unknown handler type: ${handler.type}`);\n                }\n            }\n            catch (err) {\n                const call = new server_call_1.Http2ServerCallStream(stream, null);\n                if (err.code === undefined) {\n                    err.code = constants_1.Status.INTERNAL;\n                }\n                call.sendError(err);\n            }\n        });\n        this.http2Server.on('session', session => {\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            this.sessions.add(session);\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata) {\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    emitter.request = request;\n    handler.func(emitter, (err, value, trailer, flags) => {\n        call.sendUnaryMessage(err, value, trailer, flags);\n    });\n}\nfunction handleClientStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata) {\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n    stream.request = request;\n    handler.func(stream);\n}\nfunction handleBidiStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n}\n//# sourceMappingURL=server.js.map"]},"metadata":{},"sourceType":"script"}