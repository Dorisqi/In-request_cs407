{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst resolver_dns = require(\"./resolver-dns\");\n\nconst resolver_uds = require(\"./resolver-uds\");\n\nconst registeredResolvers = {};\nlet defaultResolver = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\n\nfunction registerResolver(prefix, resolverClass) {\n  registeredResolvers[prefix] = resolverClass;\n}\n\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\n\nfunction registerDefaultResolver(resolverClass) {\n  defaultResolver = resolverClass;\n}\n\nexports.registerDefaultResolver = registerDefaultResolver;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\n\nfunction createResolver(target, listener) {\n  for (const prefix of Object.keys(registeredResolvers)) {\n    if (target.startsWith(prefix)) {\n      return new registeredResolvers[prefix](target, listener);\n    }\n  }\n\n  if (defaultResolver !== null) {\n    return new defaultResolver(target, listener);\n  }\n\n  throw new Error(`No resolver could be created for target ${target}`);\n}\n\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\n\nfunction getDefaultAuthority(target) {\n  for (const prefix of Object.keys(registeredResolvers)) {\n    if (target.startsWith(prefix)) {\n      return registeredResolvers[prefix].getDefaultAuthority(target);\n    }\n  }\n\n  if (defaultResolver !== null) {\n    return defaultResolver.getDefaultAuthority(target);\n  }\n\n  throw new Error(`Invalid target ${target}`);\n}\n\nexports.getDefaultAuthority = getDefaultAuthority;\n\nfunction registerAll() {\n  resolver_dns.setup();\n  resolver_uds.setup();\n}\n\nexports.registerAll = registerAll;","map":{"version":3,"sources":["../../src/resolver.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAmBA,MAAA,YAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAuDA,MAAM,mBAAmB,GAA8C,EAAvE;AACA,IAAI,eAAe,GAA+B,IAAlD;AAEA;;;;;;;;AAOA,SAAgB,gBAAhB,CACE,MADF,EAEE,aAFF,EAEoC;AAElC,EAAA,mBAAmB,CAAC,MAAD,CAAnB,GAA8B,aAA9B;AACD;;AALD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAOA;;;;;;AAKA,SAAgB,uBAAhB,CAAwC,aAAxC,EAA0E;AACxE,EAAA,eAAe,GAAG,aAAlB;AACD;;AAFD,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAIA;;;;;;;AAMA,SAAgB,cAAhB,CACE,MADF,EAEE,QAFF,EAE4B;AAE1B,OAAK,MAAM,MAAX,IAAqB,MAAM,CAAC,IAAP,CAAY,mBAAZ,CAArB,EAAuD;AACrD,QAAI,MAAM,CAAC,UAAP,CAAkB,MAAlB,CAAJ,EAA+B;AAC7B,aAAO,IAAI,mBAAmB,CAAC,MAAD,CAAvB,CAAgC,MAAhC,EAAwC,QAAxC,CAAP;AACD;AACF;;AACD,MAAI,eAAe,KAAK,IAAxB,EAA8B;AAC5B,WAAO,IAAI,eAAJ,CAAoB,MAApB,EAA4B,QAA5B,CAAP;AACD;;AACD,QAAM,IAAI,KAAJ,CAAU,2CAA2C,MAAM,EAA3D,CAAN;AACD;;AAbD,OAAA,CAAA,cAAA,GAAA,cAAA;AAeA;;;;;;AAKA,SAAgB,mBAAhB,CAAoC,MAApC,EAAkD;AAChD,OAAK,MAAM,MAAX,IAAqB,MAAM,CAAC,IAAP,CAAY,mBAAZ,CAArB,EAAuD;AACrD,QAAI,MAAM,CAAC,UAAP,CAAkB,MAAlB,CAAJ,EAA+B;AAC7B,aAAO,mBAAmB,CAAC,MAAD,CAAnB,CAA4B,mBAA5B,CAAgD,MAAhD,CAAP;AACD;AACF;;AACD,MAAI,eAAe,KAAK,IAAxB,EAA8B;AAC5B,WAAO,eAAe,CAAC,mBAAhB,CAAoC,MAApC,CAAP;AACD;;AACD,QAAM,IAAI,KAAJ,CAAU,kBAAkB,MAAM,EAAlC,CAAN;AACD;;AAVD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAYA,SAAgB,WAAhB,GAA2B;AACzB,EAAA,YAAY,CAAC,KAAb;AACA,EAAA,YAAY,CAAC,KAAb;AACD;;AAHD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolver_dns = require(\"./resolver-dns\");\nconst resolver_uds = require(\"./resolver-uds\");\nconst registeredResolvers = {};\nlet defaultResolver = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(prefix, resolverClass) {\n    registeredResolvers[prefix] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultResolver(resolverClass) {\n    defaultResolver = resolverClass;\n}\nexports.registerDefaultResolver = registerDefaultResolver;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener) {\n    for (const prefix of Object.keys(registeredResolvers)) {\n        if (target.startsWith(prefix)) {\n            return new registeredResolvers[prefix](target, listener);\n        }\n    }\n    if (defaultResolver !== null) {\n        return new defaultResolver(target, listener);\n    }\n    throw new Error(`No resolver could be created for target ${target}`);\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    for (const prefix of Object.keys(registeredResolvers)) {\n        if (target.startsWith(prefix)) {\n            return registeredResolvers[prefix].getDefaultAuthority(target);\n        }\n    }\n    if (defaultResolver !== null) {\n        return defaultResolver.getDefaultAuthority(target);\n    }\n    throw new Error(`Invalid target ${target}`);\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction registerAll() {\n    resolver_dns.setup();\n    resolver_uds.setup();\n}\nexports.registerAll = registerAll;\n//# sourceMappingURL=resolver.js.map"]},"metadata":{},"sourceType":"script"}