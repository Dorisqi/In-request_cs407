{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst TRACER_NAME = 'call_stream';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n\nclass Http2CallStream extends stream_1.Duplex {\n  constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    super({\n      objectMode: true\n    });\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.channelCallCredentials = channelCallCredentials;\n    this.callNumber = callNumber;\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.pendingFinalCallback = null;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    this.mappedStatusCode = constants_1.Status.UNKNOWN; // Promise objects that are re-assigned to resolving promises when headers\n    // or trailers received. Processing headers/trailers is asynchronous, so we\n    // can use these objects to await their completion. This helps us establish\n    // order of precedence when obtaining the status of the call.\n\n    this.handlingHeaders = Promise.resolve();\n    this.handlingTrailers = Promise.resolve(); // This is populated (non-null) if and only if the call has ended\n\n    this.finalStatus = null;\n    this.subchannel = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n\n    this.disconnectListener = () => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n  }\n\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  } // tslint:disable-next-line:no-any\n\n\n  push(chunk, encoding) {\n    this.trace('pushing to reader message of length ' + (chunk instanceof Buffer ? chunk.length : null));\n    return super.push(chunk);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n\n\n  endCall(status) {\n    /* Once endCall is called, we are definitely not using the http2 stream\n     * anymore, so we can always safely destroy it here */\n    this.destroyHttp2Stream();\n\n    if (this.finalStatus === null) {\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      this.finalStatus = status;\n      /* We do this asynchronously to ensure that no async function is in the\n       * call stack when we return control to the application. If an async\n       * function is in the call stack, any exception thrown by the application\n       * (or our tests) will bubble up and turn into promise rejection, which\n       * will result in an UnhandledPromiseRejectionWarning. Because that is\n       * a warning, the error will be effectively swallowed and execution will\n       * continue */\n\n      process.nextTick(() => {\n        this.emit('status', status);\n      });\n\n      if (this.subchannel) {\n        this.subchannel.callUnref();\n        this.subchannel.removeDisconnectListener(this.disconnectListener);\n      }\n    }\n  }\n\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n\n  handleFilteredRead(message) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n\n    this.isReadFilterPending = false;\n\n    if (this.canPush) {\n      if (!this.push(message)) {\n        this.canPush = false;\n        this.http2Stream.pause();\n      }\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + message.length);\n      this.unpushedReadMessages.push(message);\n    }\n\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n\n    if (framedMessage === null) {\n      if (this.canPush) {\n        this.push(null);\n      } else {\n        this.unpushedReadMessages.push(null);\n      }\n\n      return;\n    }\n\n    this.trace('filterReceivedMessage of length ' + framedMessage.length);\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.trace('unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n\n  handleTrailers(headers) {\n    this.trace('received HTTP/2 trailing headers frame');\n    const code = this.mappedStatusCode;\n    const details = '';\n    let metadata;\n\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    const status = {\n      code,\n      details,\n      metadata\n    };\n\n    this.handlingTrailers = (async () => {\n      let finalStatus;\n\n      try {\n        // Attempt to assign final status.\n        finalStatus = await this.filterStack.receiveTrailers(Promise.resolve(status));\n      } catch (error) {\n        await this.handlingHeaders; // This is a no-op if the call was already ended when handling headers.\n\n        this.endCall({\n          code: constants_1.Status.INTERNAL,\n          details: 'Failed to process received status',\n          metadata: new metadata_1.Metadata()\n        });\n        return;\n      } // It's possible that headers were received but not fully handled yet.\n      // Give the headers handler an opportunity to end the call first,\n      // if an error occurred.\n\n\n      await this.handlingHeaders; // This is a no-op if the call was already ended when handling headers.\n\n      this.endCall(finalStatus);\n    })();\n  }\n\n  attachHttp2Stream(stream, subchannel) {\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n      this.http2Stream = stream;\n      this.subchannel = subchannel;\n      subchannel.addDisconnectListener(this.disconnectListener);\n      subchannel.callRef();\n      stream.on('response', (headers, flags) => {\n        this.trace('received HTTP/2 headers frame');\n\n        switch (headers[':status']) {\n          // TODO(murgatroid99): handle 100 and 101\n          case 400:\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n\n          case 401:\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n\n          case 403:\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n\n          case 404:\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n\n          case 429:\n          case 502:\n          case 503:\n          case 504:\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n\n          this.handlingHeaders = this.filterStack.receiveMetadata(Promise.resolve(metadata)).then(finalMetadata => {\n            this.emit('metadata', finalMetadata);\n          }).catch(error => {\n            this.destroyHttp2Stream();\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          });\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', data => {\n        this.trace('receive HTTP/2 data frame of length ' + data.length);\n        const messages = this.decoder.write(data);\n\n        for (const message of messages) {\n          this.trace('parsed message of length ' + message.length);\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.trace('received HTTP/2 end of data flag');\n        this.tryPush(null);\n      });\n      stream.on('close', async () => {\n        this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n        let code;\n        let details = '';\n\n        switch (stream.rstCode) {\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted';\n            break;\n\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n\n          default:\n            code = constants_1.Status.INTERNAL;\n        } // This guarantees that if trailers were received, the value of the\n        // 'grpc-status' header takes precedence for emitted status data.\n\n\n        await this.handlingTrailers; // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      stream.on('error', err => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n      });\n\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n\n        this.trace('sending data chunk of length ' + this.pendingWrite.length + ' (deferred)');\n        stream.write(this.pendingWrite, this.pendingWriteCallback);\n      }\n\n      if (this.pendingFinalCallback) {\n        this.trace('calling end() on HTTP/2 stream (deferred)');\n        stream.end(this.pendingFinalCallback);\n      }\n    }\n  }\n\n  sendMetadata(metadata) {\n    this.trace('Sending metadata');\n\n    this.channel._startCallStream(this, metadata);\n  }\n\n  destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n       * codes based on the status code */\n      this.http2Stream.close(NGHTTP2_CANCEL);\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.destroyHttp2Stream();\n\n    (async () => {\n      // If trailers are currently being processed, the call should be ended\n      // by handleTrailers instead.\n      await this.handlingTrailers;\n      this.endCall({\n        code: status,\n        details,\n        metadata: new metadata_1.Metadata()\n      });\n    })();\n  }\n\n  getDeadline() {\n    return this.options.deadline;\n  }\n\n  getCredentials() {\n    return this.credentials;\n  }\n\n  setCredentials(credentials) {\n    this.credentials = this.channelCallCredentials.compose(credentials);\n  }\n\n  getStatus() {\n    return this.finalStatus;\n  }\n\n  getPeer() {\n    throw new Error('Not yet implemented');\n  }\n\n  getMethod() {\n    return this.methodName;\n  }\n\n  getHost() {\n    return this.options.host;\n  }\n\n  _read(size) {\n    /* If we have already emitted a status, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null) {\n      this.push(null);\n      return;\n    }\n\n    this.canPush = true;\n\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      while (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.canPush = this.push(nextMessage);\n\n        if (nextMessage === null || !this.canPush) {\n          this.canPush = false;\n          return;\n        }\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit, and we haven't gotten the signal to stop pushing\n       * messages */\n\n\n      this.http2Stream.resume();\n    }\n  }\n\n  _write(chunk, encoding, cb) {\n    this.trace('write() called with message of length ' + chunk.message.length);\n    this.filterStack.sendMessage(Promise.resolve(chunk)).then(message => {\n      if (this.http2Stream === null) {\n        this.trace('deferring writing data chunk of length ' + message.message.length);\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.trace('sending data chunk of length ' + message.message.length);\n        this.http2Stream.write(message.message, cb);\n      }\n    }, this.handleFilterError.bind(this));\n  }\n\n  _final(cb) {\n    this.trace('end() called');\n\n    if (this.http2Stream === null) {\n      this.trace('deferring calling end() on HTTP/2 stream');\n      this.pendingFinalCallback = cb;\n    } else {\n      this.trace('calling end() on HTTP/2 stream');\n      this.http2Stream.end(cb);\n    }\n  }\n\n}\n\nexports.Http2CallStream = Http2CallStream;","map":{"version":3,"sources":["../../src/call-stream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'call_stream';\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL, } = http2.constants;\nclass Http2CallStream extends stream_1.Duplex {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n        super({ objectMode: true });\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.pendingFinalCallback = null;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // Promise objects that are re-assigned to resolving promises when headers\n        // or trailers received. Processing headers/trailers is asynchronous, so we\n        // can use these objects to await their completion. This helps us establish\n        // order of precedence when obtaining the status of the call.\n        this.handlingHeaders = Promise.resolve();\n        this.handlingTrailers = Promise.resolve();\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = () => {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Connection dropped',\n                metadata: new metadata_1.Metadata(),\n            });\n        };\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    // tslint:disable-next-line:no-any\n    push(chunk, encoding) {\n        this.trace('pushing to reader message of length ' +\n            (chunk instanceof Buffer ? chunk.length : null));\n        return super.push(chunk);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* Once endCall is called, we are definitely not using the http2 stream\n         * anymore, so we can always safely destroy it here */\n        this.destroyHttp2Stream();\n        if (this.finalStatus === null) {\n            this.trace('ended with status: code=' +\n                status.code +\n                ' details=\"' +\n                status.details +\n                '\"');\n            this.finalStatus = status;\n            /* We do this asynchronously to ensure that no async function is in the\n             * call stack when we return control to the application. If an async\n             * function is in the call stack, any exception thrown by the application\n             * (or our tests) will bubble up and turn into promise rejection, which\n             * will result in an UnhandledPromiseRejectionWarning. Because that is\n             * a warning, the error will be effectively swallowed and execution will\n             * continue */\n            process.nextTick(() => {\n                this.emit('status', status);\n            });\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended, we don't want to do anything with\n         * this message. Dropping it on the floor is correct behavior */\n        if (this.finalStatus !== null) {\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            if (!this.push(message)) {\n                this.canPush = false;\n                this.http2Stream.pause();\n            }\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */\n            const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended, we don't want to do anything with\n         * this message. Dropping it on the floor is correct behavior */\n        if (this.finalStatus !== null) {\n            return;\n        }\n        if (framedMessage === null) {\n            if (this.canPush) {\n                this.push(null);\n            }\n            else {\n                this.unpushedReadMessages.push(null);\n            }\n            return;\n        }\n        this.trace('filterReceivedMessage of length ' + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack\n            .receiveMessage(Promise.resolve(framedMessage))\n            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace('unfilteredReadMessages.push message of length ' +\n                (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        }\n        else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.trace('received HTTP/2 trailing headers frame');\n        const code = this.mappedStatusCode;\n        const details = '';\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const status = { code, details, metadata };\n        this.handlingTrailers = (async () => {\n            let finalStatus;\n            try {\n                // Attempt to assign final status.\n                finalStatus = await this.filterStack.receiveTrailers(Promise.resolve(status));\n            }\n            catch (error) {\n                await this.handlingHeaders;\n                // This is a no-op if the call was already ended when handling headers.\n                this.endCall({\n                    code: constants_1.Status.INTERNAL,\n                    details: 'Failed to process received status',\n                    metadata: new metadata_1.Metadata(),\n                });\n                return;\n            }\n            // It's possible that headers were received but not fully handled yet.\n            // Give the headers handler an opportunity to end the call first,\n            // if an error occurred.\n            await this.handlingHeaders;\n            // This is a no-op if the call was already ended when handling headers.\n            this.endCall(finalStatus);\n        })();\n    }\n    attachHttp2Stream(stream, subchannel) {\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        }\n        else {\n            this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on('response', (headers, flags) => {\n                this.trace('received HTTP/2 headers frame');\n                switch (headers[':status']) {\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                }\n                else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                        return;\n                    }\n                    this.handlingHeaders = this.filterStack\n                        .receiveMetadata(Promise.resolve(metadata))\n                        .then(finalMetadata => {\n                        this.emit('metadata', finalMetadata);\n                    })\n                        .catch(error => {\n                        this.destroyHttp2Stream();\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                    });\n                }\n            });\n            stream.on('trailers', this.handleTrailers.bind(this));\n            stream.on('data', (data) => {\n                this.trace('receive HTTP/2 data frame of length ' + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages) {\n                    this.trace('parsed message of length ' + message.length);\n                    this.tryPush(message);\n                }\n            });\n            stream.on('end', () => {\n                this.trace('received HTTP/2 end of data flag');\n                this.tryPush(null);\n            });\n            stream.on('close', async () => {\n                this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n                let code;\n                let details = '';\n                switch (stream.rstCode) {\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = 'Stream refused by server';\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        details = 'Call cancelled';\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = 'Bandwidth exhausted';\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = 'Protocol not secure enough';\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                }\n                // This guarantees that if trailers were received, the value of the\n                // 'grpc-status' header takes precedence for emitted status data.\n                await this.handlingTrailers;\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({ code, details, metadata: new metadata_1.Metadata() });\n            });\n            stream.on('error', (err) => {\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */\n            });\n            if (!this.pendingRead) {\n                stream.pause();\n            }\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error('Invalid state in write handling code');\n                }\n                this.trace('sending data chunk of length ' +\n                    this.pendingWrite.length +\n                    ' (deferred)');\n                stream.write(this.pendingWrite, this.pendingWriteCallback);\n            }\n            if (this.pendingFinalCallback) {\n                this.trace('calling end() on HTTP/2 stream (deferred)');\n                stream.end(this.pendingFinalCallback);\n            }\n        }\n    }\n    sendMetadata(metadata) {\n        this.trace('Sending metadata');\n        this.channel._startCallStream(this, metadata);\n    }\n    destroyHttp2Stream() {\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n             * codes based on the status code */\n            this.http2Stream.close(NGHTTP2_CANCEL);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.destroyHttp2Stream();\n        (async () => {\n            // If trailers are currently being processed, the call should be ended\n            // by handleTrailers instead.\n            await this.handlingTrailers;\n            this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n        })();\n    }\n    getDeadline() {\n        return this.options.deadline;\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        throw new Error('Not yet implemented');\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    _read(size) {\n        /* If we have already emitted a status, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null) {\n            this.push(null);\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        }\n        else {\n            while (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.canPush = this.push(nextMessage);\n                if (nextMessage === null || !this.canPush) {\n                    this.canPush = false;\n                    return;\n                }\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit, and we haven't gotten the signal to stop pushing\n             * messages */\n            this.http2Stream.resume();\n        }\n    }\n    _write(chunk, encoding, cb) {\n        this.trace('write() called with message of length ' + chunk.message.length);\n        this.filterStack.sendMessage(Promise.resolve(chunk)).then(message => {\n            if (this.http2Stream === null) {\n                this.trace('deferring writing data chunk of length ' + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            }\n            else {\n                this.trace('sending data chunk of length ' + message.message.length);\n                this.http2Stream.write(message.message, cb);\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    _final(cb) {\n        this.trace('end() called');\n        if (this.http2Stream === null) {\n            this.trace('deferring calling end() on HTTP/2 stream');\n            this.pendingFinalCallback = cb;\n        }\n        else {\n            this.trace('calling end() on HTTP/2 stream');\n            this.http2Stream.end(cb);\n        }\n    }\n}\nexports.Http2CallStream = Http2CallStream;\n//# sourceMappingURL=call-stream.js.map"]},"metadata":{},"sourceType":"script"}