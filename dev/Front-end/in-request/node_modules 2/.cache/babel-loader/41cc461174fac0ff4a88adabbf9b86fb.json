{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    this.multiplier = BACKOFF_MULTIPLIER;\n    this.maxDelay = MAX_BACKOFF_MS;\n    this.jitter = BACKOFF_JITTER;\n    this.running = false;\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  runOnce() {\n    this.running = true;\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value.\n   */\n\n\n  reset() {\n    this.nextDelay = this.initialDelay;\n  }\n\n  isRunning() {\n    return this.running;\n  }\n\n}\n\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"sources":["../../src/backoff-timeout.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAM,kBAAkB,GAAG,IAA3B;AACA,MAAM,kBAAkB,GAAG,GAA3B;AACA,MAAM,cAAc,GAAG,MAAvB;AACA,MAAM,cAAc,GAAG,GAAvB;AAEA;;;;;;AAKA,SAAS,aAAT,CAAuB,GAAvB,EAAoC,GAApC,EAA+C;AAC7C,SAAO,IAAI,CAAC,MAAL,MAAiB,GAAG,GAAG,GAAvB,IAA8B,GAArC;AACD;;AASD,MAAa,cAAb,CAA2B;AASzB,EAAA,WAAA,CAAoB,QAApB,EAA0C,OAA1C,EAAkE;AAA9C,SAAA,QAAA,GAAA,QAAA;AARZ,SAAA,YAAA,GAAuB,kBAAvB;AACA,SAAA,UAAA,GAAqB,kBAArB;AACA,SAAA,QAAA,GAAmB,cAAnB;AACA,SAAA,MAAA,GAAiB,cAAjB;AAGA,SAAA,OAAA,GAAU,KAAV;;AAGN,QAAI,OAAJ,EAAa;AACX,UAAI,OAAO,CAAC,YAAZ,EAA0B;AACxB,aAAK,YAAL,GAAoB,OAAO,CAAC,YAA5B;AACD;;AACD,UAAI,OAAO,CAAC,UAAZ,EAAwB;AACtB,aAAK,UAAL,GAAkB,OAAO,CAAC,UAA1B;AACD;;AACD,UAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,aAAK,MAAL,GAAc,OAAO,CAAC,MAAtB;AACD;;AACD,UAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,aAAK,QAAL,GAAgB,OAAO,CAAC,QAAxB;AACD;AACF;;AACD,SAAK,SAAL,GAAiB,KAAK,YAAtB;AACA,SAAK,OAAL,GAAe,UAAU,CAAC,MAAK,CAAG,CAAT,EAAW,CAAX,CAAzB;AACA,IAAA,YAAY,CAAC,KAAK,OAAN,CAAZ;AACD;AAED;;;;;AAGA,EAAA,OAAO,GAAA;AACL,SAAK,OAAL,GAAe,IAAf;AACA,SAAK,OAAL,GAAe,UAAU,CAAC,MAAK;AAC7B,WAAK,QAAL;AACA,WAAK,OAAL,GAAe,KAAf;AACD,KAHwB,EAGtB,KAAK,SAHiB,CAAzB;AAIA,UAAM,WAAW,GAAG,IAAI,CAAC,GAAL,CAClB,KAAK,SAAL,GAAiB,KAAK,UADJ,EAElB,KAAK,QAFa,CAApB;AAIA,UAAM,eAAe,GAAG,WAAW,GAAG,KAAK,MAA3C;AACA,SAAK,SAAL,GACE,WAAW,GAAG,aAAa,CAAC,CAAC,eAAF,EAAmB,eAAnB,CAD7B;AAED;AAED;;;;;;AAIA,EAAA,IAAI,GAAA;AACF,IAAA,YAAY,CAAC,KAAK,OAAN,CAAZ;AACA,SAAK,OAAL,GAAe,KAAf;AACD;AAED;;;;;AAGA,EAAA,KAAK,GAAA;AACH,SAAK,SAAL,GAAiB,KAAK,YAAtB;AACD;;AAED,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,OAAZ;AACD;;AAjEwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        this.multiplier = BACKOFF_MULTIPLIER;\n        this.maxDelay = MAX_BACKOFF_MS;\n        this.jitter = BACKOFF_JITTER;\n        this.running = false;\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.running = true;\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n    }\n    isRunning() {\n        return this.running;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n//# sourceMappingURL=backoff-timeout.js.map"]},"metadata":{},"sourceType":"script"}