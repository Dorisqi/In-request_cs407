{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst gaxios_1 = require(\"gaxios\");\n\nconst jsonBigint = require('json-bigint');\n\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.BASE_URL = exports.HOST_ADDRESS + exports.BASE_PATH;\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.SECONDARY_BASE_URL = exports.SECONDARY_HOST_ADDRESS + exports.BASE_PATH;\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({\n  [exports.HEADER_NAME]: exports.HEADER_VALUE\n}); // Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\n\nfunction validate(options) {\n  Object.keys(options).forEach(key => {\n    switch (key) {\n      case 'params':\n      case 'property':\n      case 'headers':\n        break;\n\n      case 'qs':\n        throw new Error(`'qs' is not a valid configuration option. Please use 'params' instead.`);\n\n      default:\n        throw new Error(`'${key}' is not a valid configuration option.`);\n    }\n  });\n}\n\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      property: options\n    };\n  }\n\n  let property = '';\n\n  if (typeof options === 'object' && options.property) {\n    property = '/' + options.property;\n  }\n\n  validate(options);\n\n  try {\n    const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n    const res = await requestMethod({\n      url: `${exports.BASE_URL}/${type}${property}`,\n      headers: Object.assign({}, exports.HEADERS, options.headers),\n      retryConfig: {\n        noResponseRetries\n      },\n      params: options.params,\n      responseType: 'text',\n      timeout: requestTimeout()\n    }); // NOTE: node.js converts all incoming headers to lower case.\n\n    if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n      throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n    } else if (!res.data) {\n      throw new Error('Invalid response from the metadata service');\n    }\n\n    if (typeof res.data === 'string') {\n      try {\n        return jsonBigint.parse(res.data);\n      } catch (_a) {\n        /* ignore */\n      }\n    }\n\n    return res.data;\n  } catch (e) {\n    if (e.response && e.response.status !== 200) {\n      e.message = `Unsuccessful response status code. ${e.message}`;\n    }\n\n    throw e;\n  }\n}\n\nasync function fastFailMetadataRequest(options) {\n  const secondaryOptions = Object.assign(Object.assign({}, options), {\n    url: options.url.replace(exports.BASE_URL, exports.SECONDARY_BASE_URL)\n  }); // We race a connection between DNS/IP to metadata server. There are a couple\n  // reasons for this:\n  //\n  // 1. the DNS is slow in some GCP environments; by checking both, we might\n  //    detect the runtime environment signficantly faster.\n  // 2. we can't just check the IP, which is tarpitted and slow to respond\n  //    on a user's local machine.\n  //\n  // Additional logic has been added to make sure that we don't create an\n  // unhandled rejection in scenarios where a failure happens sometime\n  // after a success.\n  //\n  // Note, however, if a failure happens prior to a success, a rejection should\n  // occur, this is for folks running locally.\n  //\n\n  let responded = false;\n  const r1 = gaxios_1.request(options).then(res => {\n    responded = true;\n    return res;\n  }).catch(err => {\n    if (responded) {\n      return r2;\n    } else {\n      responded = true;\n      throw err;\n    }\n  });\n  const r2 = gaxios_1.request(secondaryOptions).then(res => {\n    responded = true;\n    return res;\n  }).catch(err => {\n    if (responded) {\n      return r1;\n    } else {\n      responded = true;\n      throw err;\n    }\n  });\n  return Promise.race([r1, r2]);\n} // tslint:disable-next-line no-any\n\n\nfunction instance(options) {\n  return metadataAccessor('instance', options);\n}\n\nexports.instance = instance; // tslint:disable-next-line no-any\n\nfunction project(options) {\n  return metadataAccessor('project', options);\n}\n\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\n\nfunction detectGCPAvailableRetries() {\n  return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\n/**\n * Determine if the metadata server is currently available.\n */\n\n\nlet cachedIsAvailableResponse;\n\nasync function isAvailable() {\n  try {\n    // If a user is instantiating several GCP libraries at the same time,\n    // this may result in multiple calls to isAvailable(), to detect the\n    // runtime environment. We use the same promise for each of these calls\n    // to reduce the network load.\n    if (cachedIsAvailableResponse === undefined) {\n      cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), true);\n    }\n\n    await cachedIsAvailableResponse;\n    return true;\n  } catch (err) {\n    if (process.env.DEBUG_AUTH) {\n      console.info(err);\n    }\n\n    if (err.type === 'request-timeout') {\n      // If running in a GCP environment, metadata endpoint should return\n      // within ms.\n      return false;\n    } else if (err.code && ['EHOSTDOWN', 'EHOSTUNREACH', 'ENETUNREACH', 'ENOENT', 'ENOTFOUND'].includes(err.code)) {\n      // Failure to resolve the metadata service means that it is not available.\n      return false;\n    } else if (err.response && err.response.status === 404) {\n      return false;\n    } // Throw unexpected errors.\n\n\n    throw err;\n  }\n}\n\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\n\nfunction resetIsAvailableCache() {\n  cachedIsAvailableResponse = undefined;\n}\n\nexports.resetIsAvailableCache = resetIsAvailableCache;\n\nfunction requestTimeout() {\n  // In testing, we were able to reproduce behavior similar to\n  // https://github.com/googleapis/google-auth-library-nodejs/issues/798\n  // by making many concurrent network requests. Requests do not actually fail,\n  // rather they take significantly longer to complete (and we hit our\n  // default 3000ms timeout).\n  //\n  // This logic detects a GCF environment, using the documented environment\n  // variables K_SERVICE and FUNCTION_NAME:\n  // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\n  // eliminates timeouts (by setting the value to 0 to disable).\n  return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\n}\n\nexports.requestTimeout = requestTimeout;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gaxios_1 = require(\"gaxios\");\nconst jsonBigint = require('json-bigint');\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.BASE_URL = exports.HOST_ADDRESS + exports.BASE_PATH;\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.SECONDARY_BASE_URL = exports.SECONDARY_HOST_ADDRESS + exports.BASE_PATH;\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach(key => {\n        switch (key) {\n            case 'params':\n            case 'property':\n            case 'headers':\n                break;\n            case 'qs':\n                throw new Error(`'qs' is not a valid configuration option. Please use 'params' instead.`);\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { property: options };\n    }\n    let property = '';\n    if (typeof options === 'object' && options.property) {\n        property = '/' + options.property;\n    }\n    validate(options);\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${exports.BASE_URL}/${type}${property}`,\n            headers: Object.assign({}, exports.HEADERS, options.headers),\n            retryConfig: { noResponseRetries },\n            params: options.params,\n            responseType: 'text',\n            timeout: requestTimeout(),\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        }\n        else if (!res.data) {\n            throw new Error('Invalid response from the metadata service');\n        }\n        if (typeof res.data === 'string') {\n            try {\n                return jsonBigint.parse(res.data);\n            }\n            catch (_a) {\n                /* ignore */\n            }\n        }\n        return res.data;\n    }\n    catch (e) {\n        if (e.response && e.response.status !== 200) {\n            e.message = `Unsuccessful response status code. ${e.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = Object.assign(Object.assign({}, options), { url: options.url.replace(exports.BASE_URL, exports.SECONDARY_BASE_URL) });\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = gaxios_1.request(options)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r2;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = gaxios_1.request(secondaryOptions)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r1;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([r1, r2]);\n}\n// tslint:disable-next-line no-any\nfunction instance(options) {\n    return metadataAccessor('instance', options);\n}\nexports.instance = instance;\n// tslint:disable-next-line no-any\nfunction project(options) {\n    return metadataAccessor('project', options);\n}\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\nfunction detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES\n        ? Number(process.env.DETECT_GCP_RETRIES)\n        : 0;\n}\n/**\n * Determine if the metadata server is currently available.\n */\nlet cachedIsAvailableResponse;\nasync function isAvailable() {\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), true);\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    }\n    catch (err) {\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === 'request-timeout') {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        else if (err.code &&\n            [\n                'EHOSTDOWN',\n                'EHOSTUNREACH',\n                'ENETUNREACH',\n                'ENOENT',\n                'ENOTFOUND',\n            ].includes(err.code)) {\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n        else if (err.response && err.response.status === 404) {\n            return false;\n        }\n        // Throw unexpected errors.\n        throw err;\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\nfunction resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\nfunction requestTimeout() {\n    // In testing, we were able to reproduce behavior similar to\n    // https://github.com/googleapis/google-auth-library-nodejs/issues/798\n    // by making many concurrent network requests. Requests do not actually fail,\n    // rather they take significantly longer to complete (and we hit our\n    // default 3000ms timeout).\n    //\n    // This logic detects a GCF environment, using the documented environment\n    // variables K_SERVICE and FUNCTION_NAME:\n    // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\n    // eliminates timeouts (by setting the value to 0 to disable).\n    return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}