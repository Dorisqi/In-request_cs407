{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ReadState;\n\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\n\nclass StreamDecoder {\n  constructor() {\n    this.readState = ReadState.NO_DATA;\n    this.readCompressFlag = Buffer.alloc(1);\n    this.readPartialSize = Buffer.alloc(4);\n    this.readSizeRemaining = 4;\n    this.readMessageSize = 0;\n    this.readPartialMessage = [];\n    this.readMessageRemaining = 0;\n  }\n\n  write(data) {\n    let readHead = 0;\n    let toRead;\n    const result = [];\n\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n          this.readSizeRemaining -= toRead;\n          readHead += toRead; // readSizeRemaining >=0 here\n\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            this.readMessageRemaining = this.readMessageSize;\n\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n\n          break;\n\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead; // readMessageRemaining >=0 here\n\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [this.readCompressFlag, this.readPartialSize].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n\n          break;\n\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.StreamDecoder = StreamDecoder;","map":{"version":3,"sources":["../../src/stream-decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor() {\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n//# sourceMappingURL=stream-decoder.js.map"]},"metadata":{},"sourceType":"script"}