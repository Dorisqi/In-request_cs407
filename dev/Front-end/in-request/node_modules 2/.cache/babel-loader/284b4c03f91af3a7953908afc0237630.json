{"ast":null,"code":"var JsonWebTokenError = require('./lib/JsonWebTokenError');\n\nvar NotBeforeError = require('./lib/NotBeforeError');\n\nvar TokenExpiredError = require('./lib/TokenExpiredError');\n\nvar decode = require('./decode');\n\nvar timespan = require('./lib/timespan');\n\nvar jws = require('jws');\n\nvar xtend = require('xtend');\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  } //clone this object since we are going to mutate it.\n\n\n  options = xtend(options);\n  var done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function (err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString) {\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  var parts = jwtString.split('.');\n\n  if (parts.length !== 3) {\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  var hasSignature = parts[2].trim() !== '';\n\n  if (!hasSignature && secretOrPublicKey) {\n    return done(new JsonWebTokenError('jwt signature is required'));\n  }\n\n  if (hasSignature && !secretOrPublicKey) {\n    return done(new JsonWebTokenError('secret or public key must be provided'));\n  }\n\n  if (!hasSignature && !options.algorithms) {\n    options.algorithms = ['none'];\n  }\n\n  if (!options.algorithms) {\n    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') || ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'] : ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? ['RS256', 'RS384', 'RS512'] : ['HS256', 'HS384', 'HS512'];\n  }\n\n  var decodedToken;\n\n  try {\n    decodedToken = jws.decode(jwtString);\n  } catch (err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  var header = decodedToken.header;\n\n  if (!~options.algorithms.indexOf(header.alg)) {\n    return done(new JsonWebTokenError('invalid algorithm'));\n  }\n\n  var valid;\n\n  try {\n    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);\n  } catch (e) {\n    return done(e);\n  }\n\n  if (!valid) return done(new JsonWebTokenError('invalid signature'));\n  var payload;\n\n  try {\n    payload = decode(jwtString);\n  } catch (err) {\n    return done(err);\n  }\n\n  if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n    if (typeof payload.nbf !== 'number') {\n      return done(new JsonWebTokenError('invalid nbf value'));\n    }\n\n    if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n    if (typeof payload.exp !== 'number') {\n      return done(new JsonWebTokenError('invalid exp value'));\n    }\n\n    if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n    }\n  }\n\n  if (options.audience) {\n    var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n    var match = target.some(function (targetAudience) {\n      return audiences.some(function (audience) {\n        return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n      });\n    });\n    if (!match) return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n  }\n\n  if (options.issuer) {\n    var invalid_issuer = typeof options.issuer === 'string' && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;\n\n    if (invalid_issuer) {\n      return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n    }\n  }\n\n  if (options.subject) {\n    if (payload.sub !== options.subject) {\n      return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n    }\n  }\n\n  if (options.jwtid) {\n    if (payload.jti !== options.jwtid) {\n      return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n    }\n  }\n\n  if (options.maxAge) {\n    if (typeof payload.iat !== 'number') {\n      return done(new JsonWebTokenError('iat required when maxAge is specified'));\n    }\n\n    var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n\n    if (typeof maxAgeTimestamp === 'undefined') {\n      return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n\n    if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n      return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n    }\n  }\n\n  return done(null, payload);\n};","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/jsonwebtoken/verify.js"],"names":["JsonWebTokenError","require","NotBeforeError","TokenExpiredError","decode","timespan","jws","xtend","module","exports","jwtString","secretOrPublicKey","options","callback","done","err","data","clockTimestamp","Math","floor","Date","now","parts","split","length","hasSignature","trim","algorithms","toString","indexOf","decodedToken","header","alg","valid","verify","e","payload","nbf","ignoreNotBefore","clockTolerance","exp","ignoreExpiration","audience","audiences","Array","isArray","target","aud","match","some","targetAudience","RegExp","test","join","issuer","invalid_issuer","iss","subject","sub","jwtid","jti","maxAge","iat","maxAgeTimestamp"],"mappings":"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","sourcesContent":["var JsonWebTokenError = require('./lib/JsonWebTokenError');\nvar NotBeforeError    = require('./lib/NotBeforeError');\nvar TokenExpiredError = require('./lib/TokenExpiredError');\nvar decode            = require('./decode');\nvar timespan          = require('./lib/timespan');\nvar jws               = require('jws');\nvar xtend             = require('xtend');\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = xtend(options);\n  var done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  var parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  var hasSignature = parts[2].trim() !== '';\n\n  if (!hasSignature && secretOrPublicKey){\n    return done(new JsonWebTokenError('jwt signature is required'));\n  }\n\n  if (hasSignature && !secretOrPublicKey) {\n    return done(new JsonWebTokenError('secret or public key must be provided'));\n  }\n\n  if (!hasSignature && !options.algorithms) {\n    options.algorithms = ['none'];\n  }\n\n  if (!options.algorithms) {\n    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||\n                         ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ?\n                          [ 'RS256','RS384','RS512','ES256','ES384','ES512' ] :\n                         ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ?\n                          [ 'RS256','RS384','RS512' ] :\n                          [ 'HS256','HS384','HS512' ];\n\n  }\n\n  var decodedToken;\n  try {\n    decodedToken = jws.decode(jwtString);\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  var header = decodedToken.header;\n\n  if (!~options.algorithms.indexOf(header.alg)) {\n    return done(new JsonWebTokenError('invalid algorithm'));\n  }\n\n  var valid;\n\n  try {\n    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);\n  } catch (e) {\n    return done(e);\n  }\n\n  if (!valid)\n    return done(new JsonWebTokenError('invalid signature'));\n\n  var payload;\n\n  try {\n    payload = decode(jwtString);\n  } catch(err) {\n    return done(err);\n  }\n\n  if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n    if (typeof payload.nbf !== 'number') {\n      return done(new JsonWebTokenError('invalid nbf value'));\n    }\n    if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n    if (typeof payload.exp !== 'number') {\n      return done(new JsonWebTokenError('invalid exp value'));\n    }\n    if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n    }\n  }\n\n  if (options.audience) {\n    var audiences = Array.isArray(options.audience)? options.audience : [options.audience];\n    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n    var match = target.some(function(targetAudience) {\n      return audiences.some(function(audience) {\n        return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n      });\n    });\n\n    if (!match)\n      return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n  }\n\n  if (options.issuer) {\n    var invalid_issuer =\n        (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n        (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n    if (invalid_issuer) {\n      return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n    }\n  }\n\n  if (options.subject) {\n    if (payload.sub !== options.subject) {\n      return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n    }\n  }\n\n  if (options.jwtid) {\n    if (payload.jti !== options.jwtid) {\n      return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n    }\n  }\n\n  if (options.maxAge) {\n    if (typeof payload.iat !== 'number') {\n      return done(new JsonWebTokenError('iat required when maxAge is specified'));\n    }\n\n    var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n    if (typeof maxAgeTimestamp === 'undefined') {\n      return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n    if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n      return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n    }\n  }\n\n  return done(null, payload);\n};\n"]},"metadata":{},"sourceType":"script"}