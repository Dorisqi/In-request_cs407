{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Writer;\n\nvar util = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits = util.LongBits,\n    base64 = util.base64,\n    utf8 = util.utf8;\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\n\nfunction Op(fn, len, val) {\n  /**\r\n   * Function to call.\r\n   * @type {function(Uint8Array, number, *)}\r\n   */\n  this.fn = fn;\n  /**\r\n   * Value byte length.\r\n   * @type {number}\r\n   */\n\n  this.len = len;\n  /**\r\n   * Next operation.\r\n   * @type {Writer.Op|undefined}\r\n   */\n\n  this.next = undefined;\n  /**\r\n   * Value to write.\r\n   * @type {*}\r\n   */\n\n  this.val = val; // type varies\n}\n/* istanbul ignore next */\n\n\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\n\n\nfunction State(writer) {\n  /**\r\n   * Current head.\r\n   * @type {Writer.Op}\r\n   */\n  this.head = writer.head;\n  /**\r\n   * Current tail.\r\n   * @type {Writer.Op}\r\n   */\n\n  this.tail = writer.tail;\n  /**\r\n   * Current buffer length.\r\n   * @type {number}\r\n   */\n\n  this.len = writer.len;\n  /**\r\n   * Next state.\r\n   * @type {State|null}\r\n   */\n\n  this.next = writer.states;\n}\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\n\n\nfunction Writer() {\n  /**\r\n   * Current length.\r\n   * @type {number}\r\n   */\n  this.len = 0;\n  /**\r\n   * Operations head.\r\n   * @type {Object}\r\n   */\n\n  this.head = new Op(noop, 0, 0);\n  /**\r\n   * Operations tail\r\n   * @type {Object}\r\n   */\n\n  this.tail = this.head;\n  /**\r\n   * Linked forked states.\r\n   * @type {Object|null}\r\n   */\n\n  this.states = null; // When a value is written, the writer calculates its byte length and puts it into a linked\n  // list of operations to perform when finish() is called. This both allows us to allocate\n  // buffers of the exact required size and reduces the amount of work we have to do compared\n  // to first calculating over objects and then encoding over objects. In our case, the encoding\n  // part is just a linked list walk calling operations with already prepared values.\n}\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\n\n\nWriter.create = util.Buffer ? function create_buffer_setup() {\n  return (Writer.create = function create_buffer() {\n    return new BufferWriter();\n  })();\n}\n/* istanbul ignore next */\n: function create_array() {\n  return new Writer();\n};\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\n\nWriter.alloc = function alloc(size) {\n  return new util.Array(size);\n}; // Use Uint8Array buffer pool in the browser, just like node does with buffers\n\n/* istanbul ignore else */\n\n\nif (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\n\nWriter.prototype._push = function push(fn, len, val) {\n  this.tail = this.tail.next = new Op(fn, len, val);\n  this.len += len;\n  return this;\n};\n\nfunction writeByte(val, buf, pos) {\n  buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128;\n    val >>>= 7;\n  }\n\n  buf[pos] = val;\n}\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\n\n\nfunction VarintOp(len, val) {\n  this.len = len;\n  this.next = undefined;\n  this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\nWriter.prototype.uint32 = function write_uint32(value) {\n  // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n  // uint32 is by far the most frequently used operation and benefits significantly from this.\n  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n  return this;\n};\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.int32 = function write_int32(value) {\n  return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n  : this.uint32(value);\n};\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.sint32 = function write_sint32(value) {\n  return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n  while (val.hi) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n    val.hi >>>= 7;\n  }\n\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = val.lo >>> 7;\n  }\n\n  buf[pos++] = val.lo;\n}\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\n\n\nWriter.prototype.uint64 = function write_uint64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeVarint64, bits.length(), bits);\n};\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\n\n\nWriter.prototype.int64 = Writer.prototype.uint64;\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\n\nWriter.prototype.sint64 = function write_sint64(value) {\n  var bits = LongBits.from(value).zzEncode();\n  return this._push(writeVarint64, bits.length(), bits);\n};\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.bool = function write_bool(value) {\n  return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = val >>> 8 & 255;\n  buf[pos + 2] = val >>> 16 & 255;\n  buf[pos + 3] = val >>> 24;\n}\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.fixed32 = function write_fixed32(value) {\n  return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\n\nWriter.prototype.fixed64 = function write_fixed64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\n\n\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\nWriter.prototype.float = function write_float(value) {\n  return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.double = function write_double(value) {\n  return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n  buf.set(val, pos); // also works for plain array values\n}\n/* istanbul ignore next */\n: function writeBytes_for(val, buf, pos) {\n  for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];\n};\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\n\nWriter.prototype.bytes = function write_bytes(value) {\n  var len = value.length >>> 0;\n  if (!len) return this._push(writeByte, 1, 0);\n\n  if (util.isString(value)) {\n    var buf = Writer.alloc(len = base64.length(value));\n    base64.decode(value, buf, 0);\n    value = buf;\n  }\n\n  return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.string = function write_string(value) {\n  var len = utf8.length(value);\n  return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.fork = function fork() {\n  this.states = new State(this);\n  this.head = this.tail = new Op(noop, 0, 0);\n  this.len = 0;\n  return this;\n};\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.reset = function reset() {\n  if (this.states) {\n    this.head = this.states.head;\n    this.tail = this.states.tail;\n    this.len = this.states.len;\n    this.states = this.states.next;\n  } else {\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n  }\n\n  return this;\n};\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\n\n\nWriter.prototype.ldelim = function ldelim() {\n  var head = this.head,\n      tail = this.tail,\n      len = this.len;\n  this.reset().uint32(len);\n\n  if (len) {\n    this.tail.next = head.next; // skip noop\n\n    this.tail = tail;\n    this.len += len;\n  }\n\n  return this;\n};\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\n\n\nWriter.prototype.finish = function finish() {\n  var head = this.head.next,\n      // skip noop\n  buf = this.constructor.alloc(this.len),\n      pos = 0;\n\n  while (head) {\n    head.fn(head.val, buf, pos);\n    pos += head.len;\n    head = head.next;\n  } // this.head = this.tail = null;\n\n\n  return buf;\n};\n\nWriter._configure = function (BufferWriter_) {\n  BufferWriter = BufferWriter_;\n};","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/protobufjs/src/writer.js"],"names":["module","exports","Writer","util","require","BufferWriter","LongBits","base64","utf8","Op","fn","len","val","next","undefined","noop","State","writer","head","tail","states","create","Buffer","create_buffer_setup","create_buffer","create_array","alloc","size","Array","pool","prototype","subarray","_push","push","writeByte","buf","pos","writeVarint32","VarintOp","Object","uint32","write_uint32","value","int32","write_int32","writeVarint64","fromNumber","sint32","write_sint32","hi","lo","uint64","write_uint64","bits","from","length","int64","sint64","write_sint64","zzEncode","bool","write_bool","writeFixed32","fixed32","write_fixed32","sfixed32","fixed64","write_fixed64","sfixed64","float","write_float","writeFloatLE","double","write_double","writeDoubleLE","writeBytes","set","writeBytes_set","writeBytes_for","i","bytes","write_bytes","isString","decode","string","write_string","write","fork","reset","ldelim","finish","constructor","_configure","BufferWriter_"],"mappings":"AAAA;;AACAA,MAAM,CAACC,OAAP,GAAiBC,MAAjB;;AAEA,IAAIC,IAAI,GAAQC,OAAO,CAAC,gBAAD,CAAvB;;AAEA,IAAIC,YAAJ,C,CAAkB;;AAElB,IAAIC,QAAQ,GAAIH,IAAI,CAACG,QAArB;AAAA,IACIC,MAAM,GAAMJ,IAAI,CAACI,MADrB;AAAA,IAEIC,IAAI,GAAQL,IAAI,CAACK,IAFrB;AAIA;;;;;;;;;;AASA,SAASC,EAAT,CAAYC,EAAZ,EAAgBC,GAAhB,EAAqBC,GAArB,EAA0B;AAEtB;;;;AAIA,OAAKF,EAAL,GAAUA,EAAV;AAEA;;;;;AAIA,OAAKC,GAAL,GAAWA,GAAX;AAEA;;;;;AAIA,OAAKE,IAAL,GAAYC,SAAZ;AAEA;;;;;AAIA,OAAKF,GAAL,GAAWA,GAAX,CAxBsB,CAwBN;AACnB;AAED;;;AACA,SAASG,IAAT,GAAgB,CAAE,C,CAAC;;AAEnB;;;;;;;;;;AAQA,SAASC,KAAT,CAAeC,MAAf,EAAuB;AAEnB;;;;AAIA,OAAKC,IAAL,GAAYD,MAAM,CAACC,IAAnB;AAEA;;;;;AAIA,OAAKC,IAAL,GAAYF,MAAM,CAACE,IAAnB;AAEA;;;;;AAIA,OAAKR,GAAL,GAAWM,MAAM,CAACN,GAAlB;AAEA;;;;;AAIA,OAAKE,IAAL,GAAYI,MAAM,CAACG,MAAnB;AACH;AAED;;;;;;;AAKA,SAASlB,MAAT,GAAkB;AAEd;;;;AAIA,OAAKS,GAAL,GAAW,CAAX;AAEA;;;;;AAIA,OAAKO,IAAL,GAAY,IAAIT,EAAJ,CAAOM,IAAP,EAAa,CAAb,EAAgB,CAAhB,CAAZ;AAEA;;;;;AAIA,OAAKI,IAAL,GAAY,KAAKD,IAAjB;AAEA;;;;;AAIA,OAAKE,MAAL,GAAc,IAAd,CAxBc,CA0Bd;AACA;AACA;AACA;AACA;AACH;AAED;;;;;;;AAKAlB,MAAM,CAACmB,MAAP,GAAgBlB,IAAI,CAACmB,MAAL,GACV,SAASC,mBAAT,GAA+B;AAC7B,SAAO,CAACrB,MAAM,CAACmB,MAAP,GAAgB,SAASG,aAAT,GAAyB;AAC7C,WAAO,IAAInB,YAAJ,EAAP;AACH,GAFM,GAAP;AAGH;AACD;AANY,EAOV,SAASoB,YAAT,GAAwB;AACtB,SAAO,IAAIvB,MAAJ,EAAP;AACH,CATL;AAWA;;;;;;AAKAA,MAAM,CAACwB,KAAP,GAAe,SAASA,KAAT,CAAeC,IAAf,EAAqB;AAChC,SAAO,IAAIxB,IAAI,CAACyB,KAAT,CAAeD,IAAf,CAAP;AACH,CAFD,C,CAIA;;AACA;;;AACA,IAAIxB,IAAI,CAACyB,KAAL,KAAeA,KAAnB,EACI1B,MAAM,CAACwB,KAAP,GAAevB,IAAI,CAAC0B,IAAL,CAAU3B,MAAM,CAACwB,KAAjB,EAAwBvB,IAAI,CAACyB,KAAL,CAAWE,SAAX,CAAqBC,QAA7C,CAAf;AAEJ;;;;;;;;;AAQA7B,MAAM,CAAC4B,SAAP,CAAiBE,KAAjB,GAAyB,SAASC,IAAT,CAAcvB,EAAd,EAAkBC,GAAlB,EAAuBC,GAAvB,EAA4B;AACjD,OAAKO,IAAL,GAAY,KAAKA,IAAL,CAAUN,IAAV,GAAiB,IAAIJ,EAAJ,CAAOC,EAAP,EAAWC,GAAX,EAAgBC,GAAhB,CAA7B;AACA,OAAKD,GAAL,IAAYA,GAAZ;AACA,SAAO,IAAP;AACH,CAJD;;AAMA,SAASuB,SAAT,CAAmBtB,GAAnB,EAAwBuB,GAAxB,EAA6BC,GAA7B,EAAkC;AAC9BD,EAAAA,GAAG,CAACC,GAAD,CAAH,GAAWxB,GAAG,GAAG,GAAjB;AACH;;AAED,SAASyB,aAAT,CAAuBzB,GAAvB,EAA4BuB,GAA5B,EAAiCC,GAAjC,EAAsC;AAClC,SAAOxB,GAAG,GAAG,GAAb,EAAkB;AACduB,IAAAA,GAAG,CAACC,GAAG,EAAJ,CAAH,GAAaxB,GAAG,GAAG,GAAN,GAAY,GAAzB;AACAA,IAAAA,GAAG,MAAM,CAAT;AACH;;AACDuB,EAAAA,GAAG,CAACC,GAAD,CAAH,GAAWxB,GAAX;AACH;AAED;;;;;;;;;;;AASA,SAAS0B,QAAT,CAAkB3B,GAAlB,EAAuBC,GAAvB,EAA4B;AACxB,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKE,IAAL,GAAYC,SAAZ;AACA,OAAKF,GAAL,GAAWA,GAAX;AACH;;AAED0B,QAAQ,CAACR,SAAT,GAAqBS,MAAM,CAAClB,MAAP,CAAcZ,EAAE,CAACqB,SAAjB,CAArB;AACAQ,QAAQ,CAACR,SAAT,CAAmBpB,EAAnB,GAAwB2B,aAAxB;AAEA;;;;;;AAKAnC,MAAM,CAAC4B,SAAP,CAAiBU,MAAjB,GAA0B,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AACnD;AACA;AACA,OAAK/B,GAAL,IAAY,CAAC,KAAKQ,IAAL,GAAY,KAAKA,IAAL,CAAUN,IAAV,GAAiB,IAAIyB,QAAJ,CACtC,CAACI,KAAK,GAAGA,KAAK,KAAK,CAAnB,IACU,GADV,GACsB,CADtB,GAEEA,KAAK,GAAG,KAAR,GAAoB,CAApB,GACAA,KAAK,GAAG,OAAR,GAAoB,CAApB,GACAA,KAAK,GAAG,SAAR,GAAoB,CAApB,GACoB,CANgB,EAO1CA,KAP0C,CAA9B,EAOJ/B,GAPR;AAQA,SAAO,IAAP;AACH,CAZD;AAcA;;;;;;;;AAMAT,MAAM,CAAC4B,SAAP,CAAiBa,KAAjB,GAAyB,SAASC,WAAT,CAAqBF,KAArB,EAA4B;AACjD,SAAOA,KAAK,GAAG,CAAR,GACD,KAAKV,KAAL,CAAWa,aAAX,EAA0B,EAA1B,EAA8BvC,QAAQ,CAACwC,UAAT,CAAoBJ,KAApB,CAA9B,CADC,CACyD;AADzD,IAED,KAAKF,MAAL,CAAYE,KAAZ,CAFN;AAGH,CAJD;AAMA;;;;;;;AAKAxC,MAAM,CAAC4B,SAAP,CAAiBiB,MAAjB,GAA0B,SAASC,YAAT,CAAsBN,KAAtB,EAA6B;AACnD,SAAO,KAAKF,MAAL,CAAY,CAACE,KAAK,IAAI,CAAT,GAAaA,KAAK,IAAI,EAAvB,MAA+B,CAA3C,CAAP;AACH,CAFD;;AAIA,SAASG,aAAT,CAAuBjC,GAAvB,EAA4BuB,GAA5B,EAAiCC,GAAjC,EAAsC;AAClC,SAAOxB,GAAG,CAACqC,EAAX,EAAe;AACXd,IAAAA,GAAG,CAACC,GAAG,EAAJ,CAAH,GAAaxB,GAAG,CAACsC,EAAJ,GAAS,GAAT,GAAe,GAA5B;AACAtC,IAAAA,GAAG,CAACsC,EAAJ,GAAS,CAACtC,GAAG,CAACsC,EAAJ,KAAW,CAAX,GAAetC,GAAG,CAACqC,EAAJ,IAAU,EAA1B,MAAkC,CAA3C;AACArC,IAAAA,GAAG,CAACqC,EAAJ,MAAY,CAAZ;AACH;;AACD,SAAOrC,GAAG,CAACsC,EAAJ,GAAS,GAAhB,EAAqB;AACjBf,IAAAA,GAAG,CAACC,GAAG,EAAJ,CAAH,GAAaxB,GAAG,CAACsC,EAAJ,GAAS,GAAT,GAAe,GAA5B;AACAtC,IAAAA,GAAG,CAACsC,EAAJ,GAAStC,GAAG,CAACsC,EAAJ,KAAW,CAApB;AACH;;AACDf,EAAAA,GAAG,CAACC,GAAG,EAAJ,CAAH,GAAaxB,GAAG,CAACsC,EAAjB;AACH;AAED;;;;;;;;AAMAhD,MAAM,CAAC4B,SAAP,CAAiBqB,MAAjB,GAA0B,SAASC,YAAT,CAAsBV,KAAtB,EAA6B;AACnD,MAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAT,CAAcZ,KAAd,CAAX;AACA,SAAO,KAAKV,KAAL,CAAWa,aAAX,EAA0BQ,IAAI,CAACE,MAAL,EAA1B,EAAyCF,IAAzC,CAAP;AACH,CAHD;AAKA;;;;;;;;;AAOAnD,MAAM,CAAC4B,SAAP,CAAiB0B,KAAjB,GAAyBtD,MAAM,CAAC4B,SAAP,CAAiBqB,MAA1C;AAEA;;;;;;;AAMAjD,MAAM,CAAC4B,SAAP,CAAiB2B,MAAjB,GAA0B,SAASC,YAAT,CAAsBhB,KAAtB,EAA6B;AACnD,MAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAT,CAAcZ,KAAd,EAAqBiB,QAArB,EAAX;AACA,SAAO,KAAK3B,KAAL,CAAWa,aAAX,EAA0BQ,IAAI,CAACE,MAAL,EAA1B,EAAyCF,IAAzC,CAAP;AACH,CAHD;AAKA;;;;;;;AAKAnD,MAAM,CAAC4B,SAAP,CAAiB8B,IAAjB,GAAwB,SAASC,UAAT,CAAoBnB,KAApB,EAA2B;AAC/C,SAAO,KAAKV,KAAL,CAAWE,SAAX,EAAsB,CAAtB,EAAyBQ,KAAK,GAAG,CAAH,GAAO,CAArC,CAAP;AACH,CAFD;;AAIA,SAASoB,YAAT,CAAsBlD,GAAtB,EAA2BuB,GAA3B,EAAgCC,GAAhC,EAAqC;AACjCD,EAAAA,GAAG,CAACC,GAAD,CAAH,GAAgBxB,GAAG,GAAW,GAA9B;AACAuB,EAAAA,GAAG,CAACC,GAAG,GAAG,CAAP,CAAH,GAAgBxB,GAAG,KAAK,CAAR,GAAc,GAA9B;AACAuB,EAAAA,GAAG,CAACC,GAAG,GAAG,CAAP,CAAH,GAAgBxB,GAAG,KAAK,EAAR,GAAc,GAA9B;AACAuB,EAAAA,GAAG,CAACC,GAAG,GAAG,CAAP,CAAH,GAAgBxB,GAAG,KAAK,EAAxB;AACH;AAED;;;;;;;AAKAV,MAAM,CAAC4B,SAAP,CAAiBiC,OAAjB,GAA2B,SAASC,aAAT,CAAuBtB,KAAvB,EAA8B;AACrD,SAAO,KAAKV,KAAL,CAAW8B,YAAX,EAAyB,CAAzB,EAA4BpB,KAAK,KAAK,CAAtC,CAAP;AACH,CAFD;AAIA;;;;;;;;AAMAxC,MAAM,CAAC4B,SAAP,CAAiBmC,QAAjB,GAA4B/D,MAAM,CAAC4B,SAAP,CAAiBiC,OAA7C;AAEA;;;;;;;AAMA7D,MAAM,CAAC4B,SAAP,CAAiBoC,OAAjB,GAA2B,SAASC,aAAT,CAAuBzB,KAAvB,EAA8B;AACrD,MAAIW,IAAI,GAAG/C,QAAQ,CAACgD,IAAT,CAAcZ,KAAd,CAAX;AACA,SAAO,KAAKV,KAAL,CAAW8B,YAAX,EAAyB,CAAzB,EAA4BT,IAAI,CAACH,EAAjC,EAAqClB,KAArC,CAA2C8B,YAA3C,EAAyD,CAAzD,EAA4DT,IAAI,CAACJ,EAAjE,CAAP;AACH,CAHD;AAKA;;;;;;;;;AAOA/C,MAAM,CAAC4B,SAAP,CAAiBsC,QAAjB,GAA4BlE,MAAM,CAAC4B,SAAP,CAAiBoC,OAA7C;AAEA;;;;;;;AAMAhE,MAAM,CAAC4B,SAAP,CAAiBuC,KAAjB,GAAyB,SAASC,WAAT,CAAqB5B,KAArB,EAA4B;AACjD,SAAO,KAAKV,KAAL,CAAW7B,IAAI,CAACkE,KAAL,CAAWE,YAAtB,EAAoC,CAApC,EAAuC7B,KAAvC,CAAP;AACH,CAFD;AAIA;;;;;;;;AAMAxC,MAAM,CAAC4B,SAAP,CAAiB0C,MAAjB,GAA0B,SAASC,YAAT,CAAsB/B,KAAtB,EAA6B;AACnD,SAAO,KAAKV,KAAL,CAAW7B,IAAI,CAACkE,KAAL,CAAWK,aAAtB,EAAqC,CAArC,EAAwChC,KAAxC,CAAP;AACH,CAFD;;AAIA,IAAIiC,UAAU,GAAGxE,IAAI,CAACyB,KAAL,CAAWE,SAAX,CAAqB8C,GAArB,GACX,SAASC,cAAT,CAAwBjE,GAAxB,EAA6BuB,GAA7B,EAAkCC,GAAlC,EAAuC;AACrCD,EAAAA,GAAG,CAACyC,GAAJ,CAAQhE,GAAR,EAAawB,GAAb,EADqC,CAClB;AACtB;AACD;AAJa,EAKX,SAAS0C,cAAT,CAAwBlE,GAAxB,EAA6BuB,GAA7B,EAAkCC,GAAlC,EAAuC;AACrC,OAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnE,GAAG,CAAC2C,MAAxB,EAAgC,EAAEwB,CAAlC,EACI5C,GAAG,CAACC,GAAG,GAAG2C,CAAP,CAAH,GAAenE,GAAG,CAACmE,CAAD,CAAlB;AACP,CARL;AAUA;;;;;;AAKA7E,MAAM,CAAC4B,SAAP,CAAiBkD,KAAjB,GAAyB,SAASC,WAAT,CAAqBvC,KAArB,EAA4B;AACjD,MAAI/B,GAAG,GAAG+B,KAAK,CAACa,MAAN,KAAiB,CAA3B;AACA,MAAI,CAAC5C,GAAL,EACI,OAAO,KAAKqB,KAAL,CAAWE,SAAX,EAAsB,CAAtB,EAAyB,CAAzB,CAAP;;AACJ,MAAI/B,IAAI,CAAC+E,QAAL,CAAcxC,KAAd,CAAJ,EAA0B;AACtB,QAAIP,GAAG,GAAGjC,MAAM,CAACwB,KAAP,CAAaf,GAAG,GAAGJ,MAAM,CAACgD,MAAP,CAAcb,KAAd,CAAnB,CAAV;AACAnC,IAAAA,MAAM,CAAC4E,MAAP,CAAczC,KAAd,EAAqBP,GAArB,EAA0B,CAA1B;AACAO,IAAAA,KAAK,GAAGP,GAAR;AACH;;AACD,SAAO,KAAKK,MAAL,CAAY7B,GAAZ,EAAiBqB,KAAjB,CAAuB2C,UAAvB,EAAmChE,GAAnC,EAAwC+B,KAAxC,CAAP;AACH,CAVD;AAYA;;;;;;;AAKAxC,MAAM,CAAC4B,SAAP,CAAiBsD,MAAjB,GAA0B,SAASC,YAAT,CAAsB3C,KAAtB,EAA6B;AACnD,MAAI/B,GAAG,GAAGH,IAAI,CAAC+C,MAAL,CAAYb,KAAZ,CAAV;AACA,SAAO/B,GAAG,GACJ,KAAK6B,MAAL,CAAY7B,GAAZ,EAAiBqB,KAAjB,CAAuBxB,IAAI,CAAC8E,KAA5B,EAAmC3E,GAAnC,EAAwC+B,KAAxC,CADI,GAEJ,KAAKV,KAAL,CAAWE,SAAX,EAAsB,CAAtB,EAAyB,CAAzB,CAFN;AAGH,CALD;AAOA;;;;;;;AAKAhC,MAAM,CAAC4B,SAAP,CAAiByD,IAAjB,GAAwB,SAASA,IAAT,GAAgB;AACpC,OAAKnE,MAAL,GAAc,IAAIJ,KAAJ,CAAU,IAAV,CAAd;AACA,OAAKE,IAAL,GAAY,KAAKC,IAAL,GAAY,IAAIV,EAAJ,CAAOM,IAAP,EAAa,CAAb,EAAgB,CAAhB,CAAxB;AACA,OAAKJ,GAAL,GAAW,CAAX;AACA,SAAO,IAAP;AACH,CALD;AAOA;;;;;;AAIAT,MAAM,CAAC4B,SAAP,CAAiB0D,KAAjB,GAAyB,SAASA,KAAT,GAAiB;AACtC,MAAI,KAAKpE,MAAT,EAAiB;AACb,SAAKF,IAAL,GAAc,KAAKE,MAAL,CAAYF,IAA1B;AACA,SAAKC,IAAL,GAAc,KAAKC,MAAL,CAAYD,IAA1B;AACA,SAAKR,GAAL,GAAc,KAAKS,MAAL,CAAYT,GAA1B;AACA,SAAKS,MAAL,GAAc,KAAKA,MAAL,CAAYP,IAA1B;AACH,GALD,MAKO;AACH,SAAKK,IAAL,GAAY,KAAKC,IAAL,GAAY,IAAIV,EAAJ,CAAOM,IAAP,EAAa,CAAb,EAAgB,CAAhB,CAAxB;AACA,SAAKJ,GAAL,GAAY,CAAZ;AACH;;AACD,SAAO,IAAP;AACH,CAXD;AAaA;;;;;;AAIAT,MAAM,CAAC4B,SAAP,CAAiB2D,MAAjB,GAA0B,SAASA,MAAT,GAAkB;AACxC,MAAIvE,IAAI,GAAG,KAAKA,IAAhB;AAAA,MACIC,IAAI,GAAG,KAAKA,IADhB;AAAA,MAEIR,GAAG,GAAI,KAAKA,GAFhB;AAGA,OAAK6E,KAAL,GAAahD,MAAb,CAAoB7B,GAApB;;AACA,MAAIA,GAAJ,EAAS;AACL,SAAKQ,IAAL,CAAUN,IAAV,GAAiBK,IAAI,CAACL,IAAtB,CADK,CACuB;;AAC5B,SAAKM,IAAL,GAAYA,IAAZ;AACA,SAAKR,GAAL,IAAYA,GAAZ;AACH;;AACD,SAAO,IAAP;AACH,CAXD;AAaA;;;;;;AAIAT,MAAM,CAAC4B,SAAP,CAAiB4D,MAAjB,GAA0B,SAASA,MAAT,GAAkB;AACxC,MAAIxE,IAAI,GAAG,KAAKA,IAAL,CAAUL,IAArB;AAAA,MAA2B;AACvBsB,EAAAA,GAAG,GAAI,KAAKwD,WAAL,CAAiBjE,KAAjB,CAAuB,KAAKf,GAA5B,CADX;AAAA,MAEIyB,GAAG,GAAI,CAFX;;AAGA,SAAOlB,IAAP,EAAa;AACTA,IAAAA,IAAI,CAACR,EAAL,CAAQQ,IAAI,CAACN,GAAb,EAAkBuB,GAAlB,EAAuBC,GAAvB;AACAA,IAAAA,GAAG,IAAIlB,IAAI,CAACP,GAAZ;AACAO,IAAAA,IAAI,GAAGA,IAAI,CAACL,IAAZ;AACH,GARuC,CASxC;;;AACA,SAAOsB,GAAP;AACH,CAXD;;AAaAjC,MAAM,CAAC0F,UAAP,GAAoB,UAASC,aAAT,EAAwB;AACxCxF,EAAAA,YAAY,GAAGwF,aAAf;AACH,CAFD","sourcesContent":["\"use strict\";\r\nmodule.exports = Writer;\r\n\r\nvar util      = require(\"./util/minimal\");\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = util.Buffer\r\n    ? function create_buffer_setup() {\r\n        return (Writer.create = function create_buffer() {\r\n            return new BufferWriter();\r\n        })();\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array() {\r\n        return new Writer();\r\n    };\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}