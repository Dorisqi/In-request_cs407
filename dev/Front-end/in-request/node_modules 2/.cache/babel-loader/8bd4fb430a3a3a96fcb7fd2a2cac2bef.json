{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Namespace; // extends ReflectionObject\n\nvar ReflectionObject = require(\"./object\");\n\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field = require(\"./field\"),\n    util = require(\"./util\");\n\nvar Type, // cyclic\nService, Enum;\n/**\r\n * Constructs a new namespace instance.\r\n * @name Namespace\r\n * @classdesc Reflected namespace.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\n\n/**\r\n * Constructs a namespace from JSON.\r\n * @memberof Namespace\r\n * @function\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} json JSON object\r\n * @returns {Namespace} Created namespace\r\n * @throws {TypeError} If arguments are invalid\r\n */\n\nNamespace.fromJSON = function fromJSON(name, json) {\n  return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\r\n * Converts an array of reflection objects to JSON.\r\n * @memberof Namespace\r\n * @param {ReflectionObject[]} array Object array\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\r\n */\n\n\nfunction arrayToJSON(array, toJSONOptions) {\n  if (!(array && array.length)) return undefined;\n  var obj = {};\n\n  for (var i = 0; i < array.length; ++i) obj[array[i].name] = array[i].toJSON(toJSONOptions);\n\n  return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\nNamespace.isReservedId = function isReservedId(reserved, id) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] >= id) return true;\n  return false;\n};\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\n\nNamespace.isReservedName = function isReservedName(reserved, name) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (reserved[i] === name) return true;\n  return false;\n};\n/**\r\n * Not an actual constructor. Use {@link Namespace} instead.\r\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports NamespaceBase\r\n * @extends ReflectionObject\r\n * @abstract\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @see {@link Namespace}\r\n */\n\n\nfunction Namespace(name, options) {\n  ReflectionObject.call(this, name, options);\n  /**\r\n   * Nested objects by name.\r\n   * @type {Object.<string,ReflectionObject>|undefined}\r\n   */\n\n  this.nested = undefined; // toJSON\n\n  /**\r\n   * Cached nested objects as an array.\r\n   * @type {ReflectionObject[]|null}\r\n   * @private\r\n   */\n\n  this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n  namespace._nestedArray = null;\n  return namespace;\n}\n/**\r\n * Nested objects of this namespace as an array for iteration.\r\n * @name NamespaceBase#nestedArray\r\n * @type {ReflectionObject[]}\r\n * @readonly\r\n */\n\n\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n  get: function () {\n    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n  }\n});\n/**\r\n * Namespace descriptor.\r\n * @interface INamespace\r\n * @property {Object.<string,*>} [options] Namespace options\r\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\r\n */\n\n/**\r\n * Any extension field descriptor.\r\n * @typedef AnyExtensionField\r\n * @type {IExtensionField|IExtensionMapField}\r\n */\n\n/**\r\n * Any nested object descriptor.\r\n * @typedef AnyNestedObject\r\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\r\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\r\n * Converts this namespace to a namespace descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {INamespace} Namespace descriptor\r\n */\n\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n  return util.toObject([\"options\", this.options, \"nested\", arrayToJSON(this.nestedArray, toJSONOptions)]);\n};\n/**\r\n * Adds nested objects to this namespace from nested object descriptors.\r\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\r\n * @returns {Namespace} `this`\r\n */\n\n\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n  var ns = this;\n  /* istanbul ignore else */\n\n  if (nestedJson) {\n    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n      nested = nestedJson[names[i]];\n      ns.add( // most to least likely\n      (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n  }\n\n  return this;\n};\n/**\r\n * Gets the nested object of the specified name.\r\n * @param {string} name Nested object name\r\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\r\n */\n\n\nNamespace.prototype.get = function get(name) {\n  return this.nested && this.nested[name] || null;\n};\n/**\r\n * Gets the values of the nested {@link Enum|enum} of the specified name.\r\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\r\n * @param {string} name Nested enum name\r\n * @returns {Object.<string,number>} Enum values\r\n * @throws {Error} If there is no such enum\r\n */\n\n\nNamespace.prototype.getEnum = function getEnum(name) {\n  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n  throw Error(\"no such enum: \" + name);\n};\n/**\r\n * Adds a nested object to this namespace.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name\r\n */\n\n\nNamespace.prototype.add = function add(object) {\n  if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n  if (!this.nested) this.nested = {};else {\n    var prev = this.get(object.name);\n\n    if (prev) {\n      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n        // replace plain namespace but keep existing nested elements and options\n        var nested = prev.nestedArray;\n\n        for (var i = 0; i < nested.length; ++i) object.add(nested[i]);\n\n        this.remove(prev);\n        if (!this.nested) this.nested = {};\n        object.setOptions(prev.options, true);\n      } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    }\n  }\n  this.nested[object.name] = object;\n  object.onAdd(this);\n  return clearCache(this);\n};\n/**\r\n * Removes a nested object from this namespace.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this namespace\r\n */\n\n\nNamespace.prototype.remove = function remove(object) {\n  if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n  if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n  delete this.nested[object.name];\n  if (!Object.keys(this.nested).length) this.nested = undefined;\n  object.onRemove(this);\n  return clearCache(this);\n};\n/**\r\n * Defines additial namespaces within this one if not yet existing.\r\n * @param {string|string[]} path Path to create\r\n * @param {*} [json] Nested types to create from JSON\r\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\r\n */\n\n\nNamespace.prototype.define = function define(path, json) {\n  if (util.isString(path)) path = path.split(\".\");else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n  if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n  var ptr = this;\n\n  while (path.length > 0) {\n    var part = path.shift();\n\n    if (ptr.nested && ptr.nested[part]) {\n      ptr = ptr.nested[part];\n      if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n    } else ptr.add(ptr = new Namespace(part));\n  }\n\n  if (json) ptr.addJSON(json);\n  return ptr;\n};\n/**\r\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\r\n * @returns {Namespace} `this`\r\n */\n\n\nNamespace.prototype.resolveAll = function resolveAll() {\n  var nested = this.nestedArray,\n      i = 0;\n\n  while (i < nested.length) if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();\n\n  return this.resolve();\n};\n/**\r\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\r\n * @param {string|string[]} path Path to look up\r\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\r\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n */\n\n\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n  /* istanbul ignore next */\n  if (typeof filterTypes === \"boolean\") {\n    parentAlreadyChecked = filterTypes;\n    filterTypes = undefined;\n  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];\n\n  if (util.isString(path) && path.length) {\n    if (path === \".\") return this.root;\n    path = path.split(\".\");\n  } else if (!path.length) return this; // Start at root if path is absolute\n\n\n  if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes); // Test if the first part matches any nested object, and if so, traverse if path contains more\n\n  var found = this.get(path[0]);\n\n  if (found) {\n    if (path.length === 1) {\n      if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;\n    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found; // Otherwise try each nested namespace\n\n  } else for (var i = 0; i < this.nestedArray.length; ++i) if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found; // If there hasn't been a match, try again at the parent\n\n\n  if (this.parent === null || parentAlreadyChecked) return null;\n  return this.parent.lookup(path, filterTypes);\n};\n/**\r\n * Looks up the reflection object at the specified path, relative to this namespace.\r\n * @name NamespaceBase#lookup\r\n * @function\r\n * @param {string|string[]} path Path to look up\r\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n * @variation 2\r\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\r\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type\r\n * @throws {Error} If `path` does not point to a type\r\n */\n\n\nNamespace.prototype.lookupType = function lookupType(path) {\n  var found = this.lookup(path, [Type]);\n  if (!found) throw Error(\"no such type: \" + path);\n  return found;\n};\n/**\r\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Enum} Looked up enum\r\n * @throws {Error} If `path` does not point to an enum\r\n */\n\n\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n  var found = this.lookup(path, [Enum]);\n  if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n  return found;\n};\n/**\r\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type or enum\r\n * @throws {Error} If `path` does not point to a type or enum\r\n */\n\n\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n  var found = this.lookup(path, [Type, Enum]);\n  if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n  return found;\n};\n/**\r\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Service} Looked up service\r\n * @throws {Error} If `path` does not point to a service\r\n */\n\n\nNamespace.prototype.lookupService = function lookupService(path) {\n  var found = this.lookup(path, [Service]);\n  if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n  return found;\n}; // Sets up cyclic dependencies (called in index-light)\n\n\nNamespace._configure = function (Type_, Service_, Enum_) {\n  Type = Type_;\n  Service = Service_;\n  Enum = Enum_;\n};","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/protobufjs/src/namespace.js"],"names":["module","exports","Namespace","ReflectionObject","require","prototype","Object","create","constructor","className","Field","util","Type","Service","Enum","fromJSON","name","json","options","addJSON","nested","arrayToJSON","array","toJSONOptions","length","undefined","obj","i","toJSON","isReservedId","reserved","id","isReservedName","call","_nestedArray","clearCache","namespace","defineProperty","get","toArray","toObject","nestedArray","nestedJson","ns","names","keys","add","fields","values","methods","getEnum","Error","object","extend","TypeError","prev","remove","setOptions","onAdd","parent","onRemove","define","path","isString","split","Array","isArray","ptr","part","shift","resolveAll","resolve","lookup","filterTypes","parentAlreadyChecked","root","slice","found","indexOf","lookupType","lookupEnum","lookupTypeOrEnum","lookupService","_configure","Type_","Service_","Enum_"],"mappings":"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","sourcesContent":["\"use strict\";\r\nmodule.exports = Namespace;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = require(\"./object\");\r\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\r\n\r\nvar Field    = require(\"./field\"),\r\n    util     = require(\"./util\");\r\n\r\nvar Type,    // cyclic\r\n    Service,\r\n    Enum;\r\n\r\n/**\r\n * Constructs a new namespace instance.\r\n * @name Namespace\r\n * @classdesc Reflected namespace.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\r\n\r\n/**\r\n * Constructs a namespace from JSON.\r\n * @memberof Namespace\r\n * @function\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} json JSON object\r\n * @returns {Namespace} Created namespace\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nNamespace.fromJSON = function fromJSON(name, json) {\r\n    return new Namespace(name, json.options).addJSON(json.nested);\r\n};\r\n\r\n/**\r\n * Converts an array of reflection objects to JSON.\r\n * @memberof Namespace\r\n * @param {ReflectionObject[]} array Object array\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\r\n */\r\nfunction arrayToJSON(array, toJSONOptions) {\r\n    if (!(array && array.length))\r\n        return undefined;\r\n    var obj = {};\r\n    for (var i = 0; i < array.length; ++i)\r\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\r\n    return obj;\r\n}\r\n\r\nNamespace.arrayToJSON = arrayToJSON;\r\n\r\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedId = function isReservedId(reserved, id) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] >= id)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedName = function isReservedName(reserved, name) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (reserved[i] === name)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Not an actual constructor. Use {@link Namespace} instead.\r\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports NamespaceBase\r\n * @extends ReflectionObject\r\n * @abstract\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @see {@link Namespace}\r\n */\r\nfunction Namespace(name, options) {\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /**\r\n     * Nested objects by name.\r\n     * @type {Object.<string,ReflectionObject>|undefined}\r\n     */\r\n    this.nested = undefined; // toJSON\r\n\r\n    /**\r\n     * Cached nested objects as an array.\r\n     * @type {ReflectionObject[]|null}\r\n     * @private\r\n     */\r\n    this._nestedArray = null;\r\n}\r\n\r\nfunction clearCache(namespace) {\r\n    namespace._nestedArray = null;\r\n    return namespace;\r\n}\r\n\r\n/**\r\n * Nested objects of this namespace as an array for iteration.\r\n * @name NamespaceBase#nestedArray\r\n * @type {ReflectionObject[]}\r\n * @readonly\r\n */\r\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\r\n    get: function() {\r\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\r\n    }\r\n});\r\n\r\n/**\r\n * Namespace descriptor.\r\n * @interface INamespace\r\n * @property {Object.<string,*>} [options] Namespace options\r\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\r\n */\r\n\r\n/**\r\n * Any extension field descriptor.\r\n * @typedef AnyExtensionField\r\n * @type {IExtensionField|IExtensionMapField}\r\n */\r\n\r\n/**\r\n * Any nested object descriptor.\r\n * @typedef AnyNestedObject\r\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\r\n */\r\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\r\n\r\n/**\r\n * Converts this namespace to a namespace descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {INamespace} Namespace descriptor\r\n */\r\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    return util.toObject([\r\n        \"options\" , this.options,\r\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\r\n    ]);\r\n};\r\n\r\n/**\r\n * Adds nested objects to this namespace from nested object descriptors.\r\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\r\n    var ns = this;\r\n    /* istanbul ignore else */\r\n    if (nestedJson) {\r\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\r\n            nested = nestedJson[names[i]];\r\n            ns.add( // most to least likely\r\n                ( nested.fields !== undefined\r\n                ? Type.fromJSON\r\n                : nested.values !== undefined\r\n                ? Enum.fromJSON\r\n                : nested.methods !== undefined\r\n                ? Service.fromJSON\r\n                : nested.id !== undefined\r\n                ? Field.fromJSON\r\n                : Namespace.fromJSON )(names[i], nested)\r\n            );\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Gets the nested object of the specified name.\r\n * @param {string} name Nested object name\r\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\r\n */\r\nNamespace.prototype.get = function get(name) {\r\n    return this.nested && this.nested[name]\r\n        || null;\r\n};\r\n\r\n/**\r\n * Gets the values of the nested {@link Enum|enum} of the specified name.\r\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\r\n * @param {string} name Nested enum name\r\n * @returns {Object.<string,number>} Enum values\r\n * @throws {Error} If there is no such enum\r\n */\r\nNamespace.prototype.getEnum = function getEnum(name) {\r\n    if (this.nested && this.nested[name] instanceof Enum)\r\n        return this.nested[name].values;\r\n    throw Error(\"no such enum: \" + name);\r\n};\r\n\r\n/**\r\n * Adds a nested object to this namespace.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name\r\n */\r\nNamespace.prototype.add = function add(object) {\r\n\r\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))\r\n        throw TypeError(\"object must be a valid nested object\");\r\n\r\n    if (!this.nested)\r\n        this.nested = {};\r\n    else {\r\n        var prev = this.get(object.name);\r\n        if (prev) {\r\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\r\n                // replace plain namespace but keep existing nested elements and options\r\n                var nested = prev.nestedArray;\r\n                for (var i = 0; i < nested.length; ++i)\r\n                    object.add(nested[i]);\r\n                this.remove(prev);\r\n                if (!this.nested)\r\n                    this.nested = {};\r\n                object.setOptions(prev.options, true);\r\n\r\n            } else\r\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\r\n        }\r\n    }\r\n    this.nested[object.name] = object;\r\n    object.onAdd(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Removes a nested object from this namespace.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this namespace\r\n */\r\nNamespace.prototype.remove = function remove(object) {\r\n\r\n    if (!(object instanceof ReflectionObject))\r\n        throw TypeError(\"object must be a ReflectionObject\");\r\n    if (object.parent !== this)\r\n        throw Error(object + \" is not a member of \" + this);\r\n\r\n    delete this.nested[object.name];\r\n    if (!Object.keys(this.nested).length)\r\n        this.nested = undefined;\r\n\r\n    object.onRemove(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Defines additial namespaces within this one if not yet existing.\r\n * @param {string|string[]} path Path to create\r\n * @param {*} [json] Nested types to create from JSON\r\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\r\n */\r\nNamespace.prototype.define = function define(path, json) {\r\n\r\n    if (util.isString(path))\r\n        path = path.split(\".\");\r\n    else if (!Array.isArray(path))\r\n        throw TypeError(\"illegal path\");\r\n    if (path && path.length && path[0] === \"\")\r\n        throw Error(\"path must be relative\");\r\n\r\n    var ptr = this;\r\n    while (path.length > 0) {\r\n        var part = path.shift();\r\n        if (ptr.nested && ptr.nested[part]) {\r\n            ptr = ptr.nested[part];\r\n            if (!(ptr instanceof Namespace))\r\n                throw Error(\"path conflicts with non-namespace objects\");\r\n        } else\r\n            ptr.add(ptr = new Namespace(part));\r\n    }\r\n    if (json)\r\n        ptr.addJSON(json);\r\n    return ptr;\r\n};\r\n\r\n/**\r\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.resolveAll = function resolveAll() {\r\n    var nested = this.nestedArray, i = 0;\r\n    while (i < nested.length)\r\n        if (nested[i] instanceof Namespace)\r\n            nested[i++].resolveAll();\r\n        else\r\n            nested[i++].resolve();\r\n    return this.resolve();\r\n};\r\n\r\n/**\r\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\r\n * @param {string|string[]} path Path to look up\r\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\r\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n */\r\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\r\n\r\n    /* istanbul ignore next */\r\n    if (typeof filterTypes === \"boolean\") {\r\n        parentAlreadyChecked = filterTypes;\r\n        filterTypes = undefined;\r\n    } else if (filterTypes && !Array.isArray(filterTypes))\r\n        filterTypes = [ filterTypes ];\r\n\r\n    if (util.isString(path) && path.length) {\r\n        if (path === \".\")\r\n            return this.root;\r\n        path = path.split(\".\");\r\n    } else if (!path.length)\r\n        return this;\r\n\r\n    // Start at root if path is absolute\r\n    if (path[0] === \"\")\r\n        return this.root.lookup(path.slice(1), filterTypes);\r\n\r\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\r\n    var found = this.get(path[0]);\r\n    if (found) {\r\n        if (path.length === 1) {\r\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\r\n                return found;\r\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\r\n            return found;\r\n\r\n    // Otherwise try each nested namespace\r\n    } else\r\n        for (var i = 0; i < this.nestedArray.length; ++i)\r\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\r\n                return found;\r\n\r\n    // If there hasn't been a match, try again at the parent\r\n    if (this.parent === null || parentAlreadyChecked)\r\n        return null;\r\n    return this.parent.lookup(path, filterTypes);\r\n};\r\n\r\n/**\r\n * Looks up the reflection object at the specified path, relative to this namespace.\r\n * @name NamespaceBase#lookup\r\n * @function\r\n * @param {string|string[]} path Path to look up\r\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n * @variation 2\r\n */\r\n// lookup(path: string, [parentAlreadyChecked: boolean])\r\n\r\n/**\r\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type\r\n * @throws {Error} If `path` does not point to a type\r\n */\r\nNamespace.prototype.lookupType = function lookupType(path) {\r\n    var found = this.lookup(path, [ Type ]);\r\n    if (!found)\r\n        throw Error(\"no such type: \" + path);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Enum} Looked up enum\r\n * @throws {Error} If `path` does not point to an enum\r\n */\r\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\r\n    var found = this.lookup(path, [ Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type or enum\r\n * @throws {Error} If `path` does not point to a type or enum\r\n */\r\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\r\n    var found = this.lookup(path, [ Type, Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Service} Looked up service\r\n * @throws {Error} If `path` does not point to a service\r\n */\r\nNamespace.prototype.lookupService = function lookupService(path) {\r\n    var found = this.lookup(path, [ Service ]);\r\n    if (!found)\r\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nNamespace._configure = function(Type_, Service_, Enum_) {\r\n    Type    = Type_;\r\n    Service = Service_;\r\n    Enum    = Enum_;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}