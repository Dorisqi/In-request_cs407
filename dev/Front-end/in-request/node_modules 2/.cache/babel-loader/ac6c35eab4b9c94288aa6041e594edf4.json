{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst channel_options_1 = require(\"./channel-options\");\n\nconst subchannel_1 = require(\"./subchannel\"); // 10 seconds in milliseconds. This value is arbitrary.\n\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\n\n\nconst REF_CHECK_INTERVAL = 10000;\n\nclass SubchannelPool {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   * @param global If true, this is the global subchannel pool. Otherwise, it\n   * is the pool for a single channel.\n   */\n  constructor(global) {\n    this.global = global;\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n\n\n  unrefUnusedSubchannels() {\n    let allSubchannelsUnrefed = true;\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // tslint:disable-next-line:forin\n\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n\n\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n    // Cancel the cleanup task if all subchannels have been unrefed.\n\n\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n\n\n  ensureCleanupTask() {\n    if (this.global && this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL); // Unref because this timer should not keep the event loop running.\n\n      this.cleanupTimer.unref();\n    }\n  }\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n\n\n  getOrCreateSubchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials) {\n    this.ensureCleanupTask();\n\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      for (const subchannelObj of subchannelObjArray) {\n        if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n          return subchannelObj.subchannel;\n        }\n      }\n    } // If we get here, no matching subchannel was found\n\n\n    const subchannel = new subchannel_1.Subchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials);\n\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel\n    });\n\n    if (this.global) {\n      subchannel.ref();\n    }\n\n    return subchannel;\n  }\n\n}\n\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool(true);\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\n\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool(false);\n  }\n}\n\nexports.getSubchannelPool = getSubchannelPool;","map":{"version":3,"sources":["../../src/subchannel-pool.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst channel_options_1 = require(\"./channel-options\");\nconst subchannel_1 = require(\"./subchannel\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     * @param global If true, this is the global subchannel pool. Otherwise, it\n     * is the pool for a single channel.\n     */\n    constructor(global) {\n        this.global = global;\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // tslint:disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        if (this.global && this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            this.cleanupTimer.unref();\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials);\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        if (this.global) {\n            subchannel.ref();\n        }\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool(true);\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool(false);\n    }\n}\nexports.getSubchannelPool = getSubchannelPool;\n//# sourceMappingURL=subchannel-pool.js.map"]},"metadata":{},"sourceType":"script"}