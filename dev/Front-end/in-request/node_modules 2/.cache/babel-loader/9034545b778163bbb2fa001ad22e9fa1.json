{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst channel_1 = require(\"./channel\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\n\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\n\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null\n    };\n  }\n\n}\n\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of backend addresses most recently passed to `updateAddressList`.\n     */\n\n    this.latestAddressList = [];\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n\n    this.subchannels = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n\n    this.currentPick = null;\n    this.triedAllSubchannels = false;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.subchannelStateCounts = {\n      [channel_1.ConnectivityState.CONNECTING]: 0,\n      [channel_1.ConnectivityState.IDLE]: 0,\n      [channel_1.ConnectivityState.READY]: 0,\n      [channel_1.ConnectivityState.SHUTDOWN]: 0,\n      [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n\n      if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.startNextSubchannelConnecting();\n      }\n\n      if (newState === channel_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (this.triedAllSubchannels && this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] === this.subchannels.length) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources */\n          this.resetSubchannelList();\n        }\n\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n\n            if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = channel_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = channel_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState !== this.currentState) {\n              if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new picker_1.UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new picker_1.QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        }\n      }\n    };\n\n    this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n      if (newState !== channel_1.ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n\n            if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = channel_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = channel_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new picker_1.UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new picker_1.QueuePicker(this));\n            }\n          } else {\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n      }\n    };\n\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n\n        if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n\n    this.triedAllSubchannels = true;\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n\n\n  startConnecting(subchannelIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n\n    if (this.subchannels[subchannelIndex].getConnectivityState() === channel_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.subchannels[subchannelIndex].getAddress());\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n    }\n\n    this.currentPick = subchannel;\n    this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  updateState(newState, picker) {\n    trace(channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n    }\n\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [channel_1.ConnectivityState.CONNECTING]: 0,\n      [channel_1.ConnectivityState.IDLE]: 0,\n      [channel_1.ConnectivityState.READY]: 0,\n      [channel_1.ConnectivityState.SHUTDOWN]: 0,\n      [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n    this.triedAllSubchannels = false;\n  }\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n\n\n  connectToAddressList() {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + this.latestAddressList.map(address => subchannel_1.subchannelAddressToString(address)));\n    this.subchannels = this.latestAddressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n    }\n\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n\n      if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n\n      if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {\n        this.startConnecting(index);\n\n        if (this.currentPick === null) {\n          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n\n        return;\n      }\n    } // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n\n\n    if (this.currentPick === null) {\n      this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    }\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    // lbConfig has no useful information for pick first load balancing\n\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n\n    if (this.currentState === channel_1.ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n\n    if (this.currentState === channel_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n      this.channelControlHelper.requestReresolution();\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n    }\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n  replaceChannelControlHelper(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n  }\n\n}\n\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer);\n}\n\nexports.setup = setup;","map":{"version":3,"sources":["../../src/load-balancer-pick-first.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst load_balancer_1 = require(\"./load-balancer\");\nconst channel_1 = require(\"./channel\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_1 = require(\"./subchannel\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n        };\n    }\n}\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of backend addresses most recently passed to `updateAddressList`.\n         */\n        this.latestAddressList = [];\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.subchannels = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = channel_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        this.triedAllSubchannels = false;\n        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.subchannelStateCounts = {\n            [channel_1.ConnectivityState.CONNECTING]: 0,\n            [channel_1.ConnectivityState.IDLE]: 0,\n            [channel_1.ConnectivityState.READY]: 0,\n            [channel_1.ConnectivityState.SHUTDOWN]: 0,\n            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            /* If the subchannel we most recently attempted to start connecting\n             * to goes into TRANSIENT_FAILURE, immediately try to start\n             * connecting to the next one instead of waiting for the connection\n             * delay timer. */\n            if (subchannel === this.subchannels[this.currentSubchannelIndex] &&\n                newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.startNextSubchannelConnecting();\n            }\n            if (newState === channel_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n            else {\n                if (this.triedAllSubchannels &&\n                    this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] ===\n                        this.subchannels.length) {\n                    /* If all of the subchannels are IDLE we should go back to a\n                     * basic IDLE state where there is no subchannel list to avoid\n                     * holding unused resources */\n                    this.resetSubchannelList();\n                }\n                if (this.currentPick === null) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = channel_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = channel_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState !== this.currentState) {\n                            if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                                this.updateState(newLBState, new picker_1.UnavailablePicker());\n                            }\n                            else {\n                                this.updateState(newLBState, new picker_1.QueuePicker(this));\n                            }\n                        }\n                    }\n                    else {\n                        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n            }\n        };\n        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n            if (newState !== channel_1.ConnectivityState.READY) {\n                this.currentPick = null;\n                subchannel.unref();\n                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n                if (this.subchannels.length > 0) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = channel_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = channel_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                            this.updateState(newLBState, new picker_1.UnavailablePicker());\n                        }\n                        else {\n                            this.updateState(newLBState, new picker_1.QueuePicker(this));\n                        }\n                    }\n                    else {\n                        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n                else {\n                    /* We don't need to backoff here because this only happens if a\n                     * subchannel successfully connects then disconnects, so it will not\n                     * create a loop of attempting to connect to an unreachable backend\n                     */\n                    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n            }\n        };\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    startNextSubchannelConnecting() {\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            if (index > this.currentSubchannelIndex) {\n                const subchannelState = subchannel.getConnectivityState();\n                if (subchannelState === channel_1.ConnectivityState.IDLE ||\n                    subchannelState === channel_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.subchannels[subchannelIndex].getConnectivityState() ===\n            channel_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.subchannels[subchannelIndex].getAddress());\n            process.nextTick(() => {\n                this.subchannels[subchannelIndex].startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(() => {\n            this.startNextSubchannelConnecting();\n        }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n    pickSubchannel(subchannel) {\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n        subchannel.ref();\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    updateState(newState, picker) {\n        trace(channel_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            channel_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n        }\n        this.currentSubchannelIndex = 0;\n        this.subchannelStateCounts = {\n            [channel_1.ConnectivityState.CONNECTING]: 0,\n            [channel_1.ConnectivityState.IDLE]: 0,\n            [channel_1.ConnectivityState.READY]: 0,\n            [channel_1.ConnectivityState.SHUTDOWN]: 0,\n            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n        this.triedAllSubchannels = false;\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */\n    connectToAddressList() {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            this.latestAddressList.map(address => subchannel_1.subchannelAddressToString(address)));\n        this.subchannels = this.latestAddressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n        }\n        for (const subchannel of this.subchannels) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                this.resetSubchannelList();\n                return;\n            }\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === channel_1.ConnectivityState.IDLE ||\n                subchannelState === channel_1.ConnectivityState.CONNECTING) {\n                this.startConnecting(index);\n                if (this.currentPick === null) {\n                    this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                }\n                return;\n            }\n        }\n        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n        if (this.currentPick === null) {\n            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        // lbConfig has no useful information for pick first load balancing\n        /* To avoid unnecessary churn, we only do something with this address list\n         * if we're not currently trying to establish a connection, or if the new\n         * address list is different from the existing one */\n        if (this.subchannels.length === 0 ||\n            !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n            this.latestAddressList = addressList;\n            this.connectToAddressList();\n        }\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n        if (this.currentState === channel_1.ConnectivityState.IDLE) {\n            if (this.latestAddressList.length > 0) {\n                this.connectToAddressList();\n            }\n        }\n        if (this.currentState === channel_1.ConnectivityState.IDLE ||\n            this.triedAllSubchannels) {\n            this.channelControlHelper.requestReresolution();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n    replaceChannelControlHelper(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-pick-first.js.map"]},"metadata":{},"sourceType":"script"}