{"ast":null,"code":"\"use strict\";\n\nmodule.exports = encoder;\n\nvar Enum = require(\"./enum\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n/**\r\n * Generates a partial message type encoder.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\n\n\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n  return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\r\n * Generates an encoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\n\n\nfunction encoder(mtype) {\n  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n  var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n  var i, ref; // \"when a message is serialized its known fields should be written sequentially by field number\"\n\n  var fields =\n  /* initializes */\n  mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n  for (var i = 0; i < fields.length; ++i) {\n    var field = fields[i].resolve(),\n        index = mtype._fieldsArray.indexOf(field),\n        type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n        wireType = types.basic[type];\n\n    ref = \"m\" + util.safeProp(field.name); // Map fields\n\n    if (field.map) {\n      gen(\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name) // !== undefined && !== null\n      (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n      if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n      else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n      gen(\"}\")(\"}\"); // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n      // Packed repeated\n\n      if (field.packed && types.packed[type] !== undefined) {\n        gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\"); // Non-packed\n      } else {\n        gen(\"for(var i=0;i<%s.length;++i)\", ref);\n        if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n      }\n\n      gen(\"}\"); // Non-repeated\n    } else {\n      if (field.optional) gen(\"if(%s!=null&&m.hasOwnProperty(%j))\", ref, field.name); // !== undefined && !== null\n\n      if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n    }\n  }\n\n  return gen(\"return w\");\n  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/protobufjs/src/encoder.js"],"names":["module","exports","encoder","Enum","require","types","util","genTypePartial","gen","field","fieldIndex","ref","resolvedType","group","id","mtype","codegen","name","i","fields","fieldsArray","slice","sort","compareFieldsById","length","resolve","index","_fieldsArray","indexOf","type","wireType","basic","safeProp","map","mapKey","keyType","undefined","repeated","packed","optional"],"mappings":"AAAA;;AACAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,IAAIC,IAAI,GAAOC,OAAO,CAAC,QAAD,CAAtB;AAAA,IACIC,KAAK,GAAMD,OAAO,CAAC,SAAD,CADtB;AAAA,IAEIE,IAAI,GAAOF,OAAO,CAAC,QAAD,CAFtB;AAIA;;;;;;;;;;;AASA,SAASG,cAAT,CAAwBC,GAAxB,EAA6BC,KAA7B,EAAoCC,UAApC,EAAgDC,GAAhD,EAAqD;AACjD,SAAOF,KAAK,CAACG,YAAN,CAAmBC,KAAnB,GACDL,GAAG,CAAC,8CAAD,EAAiDE,UAAjD,EAA6DC,GAA7D,EAAkE,CAACF,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgB,CAAjB,MAAwB,CAA1F,EAA6F,CAACL,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgB,CAAjB,MAAwB,CAArH,CADF,GAEDN,GAAG,CAAC,mDAAD,EAAsDE,UAAtD,EAAkEC,GAAlE,EAAuE,CAACF,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgB,CAAjB,MAAwB,CAA/F,CAFT;AAGH;AAED;;;;;;;AAKA,SAASZ,OAAT,CAAiBa,KAAjB,EAAwB;AACpB;AACA,MAAIP,GAAG,GAAGF,IAAI,CAACU,OAAL,CAAa,CAAC,GAAD,EAAM,GAAN,CAAb,EAAyBD,KAAK,CAACE,IAAN,GAAa,SAAtC,EACT,QADS,EAEL,mBAFK,CAAV;AAIA,MAAIC,CAAJ,EAAOP,GAAP,CANoB,CAQpB;;AACA,MAAIQ,MAAM;AAAG;AAAkBJ,EAAAA,KAAK,CAACK,WAAN,CAAkBC,KAAlB,GAA0BC,IAA1B,CAA+BhB,IAAI,CAACiB,iBAApC,CAA/B;;AAEA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,MAAM,CAACK,MAA3B,EAAmC,EAAEN,CAArC,EAAwC;AACpC,QAAIT,KAAK,GAAMU,MAAM,CAACD,CAAD,CAAN,CAAUO,OAAV,EAAf;AAAA,QACIC,KAAK,GAAMX,KAAK,CAACY,YAAN,CAAmBC,OAAnB,CAA2BnB,KAA3B,CADf;AAAA,QAEIoB,IAAI,GAAOpB,KAAK,CAACG,YAAN,YAA8BT,IAA9B,GAAqC,OAArC,GAA+CM,KAAK,CAACoB,IAFpE;AAAA,QAGIC,QAAQ,GAAGzB,KAAK,CAAC0B,KAAN,CAAYF,IAAZ,CAHf;;AAIIlB,IAAAA,GAAG,GAAQ,MAAML,IAAI,CAAC0B,QAAL,CAAcvB,KAAK,CAACQ,IAApB,CAAjB,CALgC,CAOpC;;AACA,QAAIR,KAAK,CAACwB,GAAV,EAAe;AACXzB,MAAAA,GAAG,CACV,qCADU,EAC6BG,GAD7B,EACkCF,KAAK,CAACQ,IADxC,CAAH,CACiD;AADjD,OAEH,kDAFG,EAEiDN,GAFjD,EAGC,0CAHD,EAG6C,CAACF,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgB,CAAjB,MAAwB,CAHrE,EAGwE,IAAIT,KAAK,CAAC6B,MAAN,CAAazB,KAAK,CAAC0B,OAAnB,CAH5E,EAGyG1B,KAAK,CAAC0B,OAH/G;AAIA,UAAIL,QAAQ,KAAKM,SAAjB,EAA4B5B,GAAG,CAC9B,mEAD8B,EACuCkB,KADvC,EAC8Cf,GAD9C,CAAH,CAA5B,CACmF;AADnF,WAEKH,GAAG,CACP,oCADO,EAC+B,KAAKsB,QADpC,EAC8CD,IAD9C,EACoDlB,GADpD,CAAH;AAELH,MAAAA,GAAG,CACN,GADM,CAAH,CAEP,GAFO,EATW,CAaX;AACH,KAdD,MAcO,IAAIC,KAAK,CAAC4B,QAAV,EAAoB;AAAE7B,MAAAA,GAAG,CACnC,0BADmC,EACPG,GADO,EACFA,GADE,CAAH,CAAF,CACS;AAEhC;;AACA,UAAIF,KAAK,CAAC6B,MAAN,IAAgBjC,KAAK,CAACiC,MAAN,CAAaT,IAAb,MAAuBO,SAA3C,EAAsD;AAAE5B,QAAAA,GAAG,CAE9D,qBAF8D,EAEvC,CAACC,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgB,CAAjB,MAAwB,CAFe,CAAH,CAG3D,8BAH2D,EAG3BH,GAH2B,EAIvD,aAJuD,EAIxCkB,IAJwC,EAIlClB,GAJkC,EAK3D,YAL2D,EAAF,CAOtD;AACC,OARD,MAQO;AAAEH,QAAAA,GAAG,CAEf,8BAFe,EAEiBG,GAFjB,CAAH;AAGL,YAAImB,QAAQ,KAAKM,SAAjB,EACJ7B,cAAc,CAACC,GAAD,EAAMC,KAAN,EAAaiB,KAAb,EAAoBf,GAAG,GAAG,KAA1B,CAAd,CADI,KAEKH,GAAG,CACX,wBADW,EACe,CAACC,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgBgB,QAAjB,MAA+B,CAD9C,EACiDD,IADjD,EACuDlB,GADvD,CAAH;AAGR;;AAACH,MAAAA,GAAG,CACZ,GADY,CAAH,CApBqB,CAuB3B;AACC,KAxBM,MAwBA;AACH,UAAIC,KAAK,CAAC8B,QAAV,EAAoB/B,GAAG,CAC9B,oCAD8B,EACQG,GADR,EACaF,KAAK,CAACQ,IADnB,CAAH,CADjB,CAE8C;;AAEjD,UAAIa,QAAQ,KAAKM,SAAjB,EACJ7B,cAAc,CAACC,GAAD,EAAMC,KAAN,EAAaiB,KAAb,EAAoBf,GAApB,CAAd,CADI,KAEKH,GAAG,CACX,qBADW,EACY,CAACC,KAAK,CAACK,EAAN,IAAY,CAAZ,GAAgBgB,QAAjB,MAA+B,CAD3C,EAC8CD,IAD9C,EACoDlB,GADpD,CAAH;AAGR;AACJ;;AAED,SAAOH,GAAG,CACT,UADS,CAAV;AAEA;AACH","sourcesContent":["\"use strict\";\r\nmodule.exports = encoder;\r\n\r\nvar Enum     = require(\"./enum\"),\r\n    types    = require(\"./types\"),\r\n    util     = require(\"./util\");\r\n\r\n/**\r\n * Generates a partial message type encoder.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genTypePartial(gen, field, fieldIndex, ref) {\r\n    return field.resolvedType.group\r\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\r\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\r\n}\r\n\r\n/**\r\n * Generates an encoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction encoder(mtype) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\r\n    (\"if(!w)\")\r\n        (\"w=Writer.create()\");\r\n\r\n    var i, ref;\r\n\r\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\r\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\r\n\r\n    for (var i = 0; i < fields.length; ++i) {\r\n        var field    = fields[i].resolve(),\r\n            index    = mtype._fieldsArray.indexOf(field),\r\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\r\n            wireType = types.basic[type];\r\n            ref      = \"m\" + util.safeProp(field.name);\r\n\r\n        // Map fields\r\n        if (field.map) {\r\n            gen\r\n    (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name) // !== undefined && !== null\r\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\r\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\r\n            if (wireType === undefined) gen\r\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\r\n            else gen\r\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\r\n            gen\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n            // Repeated fields\r\n        } else if (field.repeated) { gen\r\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\r\n\r\n            // Packed repeated\r\n            if (field.packed && types.packed[type] !== undefined) { gen\r\n\r\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\r\n        (\"for(var i=0;i<%s.length;++i)\", ref)\r\n            (\"w.%s(%s[i])\", type, ref)\r\n        (\"w.ldelim()\");\r\n\r\n            // Non-packed\r\n            } else { gen\r\n\r\n        (\"for(var i=0;i<%s.length;++i)\", ref);\r\n                if (wireType === undefined)\r\n            genTypePartial(gen, field, index, ref + \"[i]\");\r\n                else gen\r\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n            } gen\r\n    (\"}\");\r\n\r\n        // Non-repeated\r\n        } else {\r\n            if (field.optional) gen\r\n    (\"if(%s!=null&&m.hasOwnProperty(%j))\", ref, field.name); // !== undefined && !== null\r\n\r\n            if (wireType === undefined)\r\n        genTypePartial(gen, field, index, ref);\r\n            else gen\r\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n        }\r\n    }\r\n\r\n    return gen\r\n    (\"return w\");\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n}"]},"metadata":{},"sourceType":"script"}