{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst metadata_status_filter_1 = require(\"./metadata-status-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst logging_1 = require(\"./logging\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a;\n\n    this.target = target;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool((_a = options['grpc.use_local_subchannel_pool'], _a !== null && _a !== void 0 ? _a : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n\n        for (const {\n          callStream,\n          callMetadata\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    }; // TODO(murgatroid99): check channel arg for default service config\n\n    let defaultServiceConfig = {\n      loadBalancingConfig: [],\n      methodConfig: []\n    };\n\n    if (options['grpc.service_config']) {\n      defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(options['grpc.service_config']));\n    }\n\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(target, channelControlHelper, defaultServiceConfig);\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new metadata_status_filter_1.MetadataStatusFilterFactory(this), new compression_filter_1.CompressionFilterFactory(this)]); // TODO(murgatroid99): Add more centralized handling of channel options\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(target);\n    }\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata\n    });\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pickQueue.push({\n              callStream,\n              callMetadata\n            });\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === ConnectivityState.READY) {\n              try {\n                pickResult.subchannel.startCallStream(finalMetadata, callStream);\n              } catch (error) {\n                /* An error here indicates that something went wrong with\n                 * the picked subchannel's http2 stream right before we\n                 * tried to start the stream. We are handling a promise\n                 * result here, so this is asynchronous with respect to the\n                 * original tryPick call, so calling it again is not\n                 * recursive. We call tryPick immediately instead of\n                 * queueing this pick again because handling the queue is\n                 * triggered by state changes, and we want to immediately\n                 * check if the state has already changed since the\n                 * previous tryPick call. We do this instead of cancelling\n                 * the stream because the correct behavior may be\n                 * re-queueing instead, based on the logic in the rest of\n                 * tryPick */\n                logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick');\n                this.tryPick(callStream, callMetadata);\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick');\n              this.tryPick(callStream, callMetadata);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pickQueue.push({\n          callStream,\n          callMetadata\n        });\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pickQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', this.target + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        watcherObject.callback();\n        clearTimeout(watcherObject.timer);\n        this.removeConnectivityStateWatcher(watcherObject);\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryPick(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return this.target;\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n    const now = new Date();\n\n    if (deadlineDate <= now) {\n      process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n      return;\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer: setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime())\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', this.target + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n      flags: propagateFlags || 0,\n      host: host || this.defaultAuthority,\n      parentCall: parentCall || null\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst call_stream_1 = require(\"./call-stream\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst metadata_status_filter_1 = require(\"./metadata-status-filter\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst service_config_1 = require(\"./service-config\");\nconst logging_1 = require(\"./logging\");\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        var _a;\n        this.target = target;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = subchannel_pool_1.getSubchannelPool((_a = options['grpc.use_local_subchannel_pool'], (_a !== null && _a !== void 0 ? _a : 0)) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                for (const { callStream, callMetadata } of queueCopy) {\n                    this.tryPick(callStream, callMetadata);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n        };\n        // TODO(murgatroid99): check channel arg for default service config\n        let defaultServiceConfig = {\n            loadBalancingConfig: [],\n            methodConfig: [],\n        };\n        if (options['grpc.service_config']) {\n            defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(options['grpc.service_config']));\n        }\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(target, channelControlHelper, defaultServiceConfig);\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new metadata_status_filter_1.MetadataStatusFilterFactory(this),\n            new compression_filter_1.CompressionFilterFactory(this),\n        ]);\n        // TODO(murgatroid99): Add more centralized handling of channel options\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(target);\n        }\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */\n    tryPick(callStream, callMetadata) {\n        var _a, _b, _c;\n        const pickResult = this.currentPicker.pick({ metadata: callMetadata });\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) +\n            ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) +\n            ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n                    // End the call with an error\n                }\n                else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +\n                            pickResult.subchannel.getAddress() +\n                            ' has state ' +\n                            ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pickQueue.push({ callStream, callMetadata });\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */\n                    callStream.filterStack\n                        .sendMetadata(Promise.resolve(callMetadata.clone()))\n                        .then(finalMetadata => {\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === ConnectivityState.READY) {\n                            try {\n                                pickResult.subchannel.startCallStream(finalMetadata, callStream);\n                            }\n                            catch (error) {\n                                /* An error here indicates that something went wrong with\n                                 * the picked subchannel's http2 stream right before we\n                                 * tried to start the stream. We are handling a promise\n                                 * result here, so this is asynchronous with respect to the\n                                 * original tryPick call, so calling it again is not\n                                 * recursive. We call tryPick immediately instead of\n                                 * queueing this pick again because handling the queue is\n                                 * triggered by state changes, and we want to immediately\n                                 * check if the state has already changed since the\n                                 * previous tryPick call. We do this instead of cancelling\n                                 * the stream because the correct behavior may be\n                                 * re-queueing instead, based on the logic in the rest of\n                                 * tryPick */\n                                logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' +\n                                    pickResult.subchannel.getAddress() +\n                                    ' with error ' +\n                                    error.message +\n                                    '. Retrying pick');\n                                this.tryPick(callStream, callMetadata);\n                            }\n                        }\n                        else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */\n                            logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' +\n                                pickResult.subchannel.getAddress() +\n                                ' has state ' +\n                                ConnectivityState[subchannelState] +\n                                ' after metadata filters. Retrying pick');\n                            this.tryPick(callStream, callMetadata);\n                        }\n                    }, (error) => {\n                        // We assume the error code isn't 0 (Status.OK)\n                        callStream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pickQueue.push({ callStream, callMetadata });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pickQueue.push({ callStream, callMetadata });\n                }\n                else {\n                    callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n                }\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', this.target +\n            ' ' +\n            ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            ConnectivityState[newState]);\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                watcherObject.callback();\n                clearTimeout(watcherObject.timer);\n                this.removeConnectivityStateWatcher(watcherObject);\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryPick(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(ConnectivityState.SHUTDOWN);\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return this.target;\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n        const now = new Date();\n        if (deadlineDate <= now) {\n            process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n            return;\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer: setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime()),\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const callNumber = getNewCallNumber();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', this.target +\n            ' createCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            deadline);\n        const finalOptions = {\n            deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n            flags: propagateFlags || 0,\n            host: host || this.defaultAuthority,\n            parentCall: parentCall || null,\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map"]},"metadata":{},"sourceType":"script"}