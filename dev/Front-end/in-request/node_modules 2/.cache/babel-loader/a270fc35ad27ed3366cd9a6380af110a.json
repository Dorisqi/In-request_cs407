{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { describe, PropTypes } from 'react-desc';\nimport { getAvailableAtBadge, themeDocUtils } from '../../utils';\nexport var doc = function doc(MaskedInput) {\n  var DocumentedMaskedInput = describe(MaskedInput).availableAt(getAvailableAtBadge('MaskedInput')).description('An input field with formalized syntax.').usage(\"import { MaskedInput } from 'grommet';\\n<MaskedInput id='item' name='item' />\").intrinsicElement('input');\n  DocumentedMaskedInput.propTypes = {\n    id: PropTypes.string.description('The id attribute of the input.'),\n    name: PropTypes.string.description('The name attribute of the input.'),\n    onChange: PropTypes.func.description(\"Function that will be called when the user types or pastes text.\"),\n    onBlur: PropTypes.func.description(\"Function that will be called when the user leaves the field.\"),\n    mask: PropTypes.arrayOf(PropTypes.shape({\n      length: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n      fixed: PropTypes.string,\n      options: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n      regexp: PropTypes.shape({}) // RegExp\n\n    })).description(\"Describes the structure of the mask. If a regexp is provided, it should\\n      allow both the final full string element as well as partial strings\\n      as the user types characters one by one.\"),\n    size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'medium', 'large', 'xlarge']), PropTypes.string]).description('The size of the text.'),\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).description(\"What text to put in the input. The caller should ensure that it\\n      is initially valid with respect to the mask.\")\n  };\n  return DocumentedMaskedInput;\n};\nexport var themeDoc = _extends({\n  'global.hover.background': {\n    description: 'The background style when hovering.',\n    type: 'string | { color: string, opacity: string }',\n    defaultValue: \"{ color: 'active', opacity: 'medium' }\"\n  },\n  'global.hover.color': {\n    description: 'The text color when hovering.',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: \"{ dark: 'white', light: 'black' }\"\n  },\n  'maskedInput.extend': {\n    description: 'Any additional style for MaskedInput.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'text.medium': {\n    description: 'The size of the text for MaskedInput.',\n    type: 'string',\n    defaultValue: '18px'\n  }\n}, themeDocUtils.focusStyle, {}, themeDocUtils.placeholderStyle, {}, themeDocUtils.inputStyle);","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/grommet/es6/components/MaskedInput/doc.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","describe","PropTypes","getAvailableAtBadge","themeDocUtils","doc","MaskedInput","DocumentedMaskedInput","availableAt","description","usage","intrinsicElement","propTypes","id","string","name","onChange","func","onBlur","mask","arrayOf","shape","oneOfType","number","fixed","options","regexp","size","oneOf","value","themeDoc","type","defaultValue","undefined","focusStyle","placeholderStyle","inputStyle"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { describe, PropTypes } from 'react-desc';\nimport { getAvailableAtBadge, themeDocUtils } from '../../utils';\nexport var doc = function doc(MaskedInput) {\n  var DocumentedMaskedInput = describe(MaskedInput).availableAt(getAvailableAtBadge('MaskedInput')).description('An input field with formalized syntax.').usage(\"import { MaskedInput } from 'grommet';\\n<MaskedInput id='item' name='item' />\").intrinsicElement('input');\n  DocumentedMaskedInput.propTypes = {\n    id: PropTypes.string.description('The id attribute of the input.'),\n    name: PropTypes.string.description('The name attribute of the input.'),\n    onChange: PropTypes.func.description(\"Function that will be called when the user types or pastes text.\"),\n    onBlur: PropTypes.func.description(\"Function that will be called when the user leaves the field.\"),\n    mask: PropTypes.arrayOf(PropTypes.shape({\n      length: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n      fixed: PropTypes.string,\n      options: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n      regexp: PropTypes.shape({}) // RegExp\n\n    })).description(\"Describes the structure of the mask. If a regexp is provided, it should\\n      allow both the final full string element as well as partial strings\\n      as the user types characters one by one.\"),\n    size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'medium', 'large', 'xlarge']), PropTypes.string]).description('The size of the text.'),\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).description(\"What text to put in the input. The caller should ensure that it\\n      is initially valid with respect to the mask.\")\n  };\n  return DocumentedMaskedInput;\n};\nexport var themeDoc = _extends({\n  'global.hover.background': {\n    description: 'The background style when hovering.',\n    type: 'string | { color: string, opacity: string }',\n    defaultValue: \"{ color: 'active', opacity: 'medium' }\"\n  },\n  'global.hover.color': {\n    description: 'The text color when hovering.',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: \"{ dark: 'white', light: 'black' }\"\n  },\n  'maskedInput.extend': {\n    description: 'Any additional style for MaskedInput.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'text.medium': {\n    description: 'The size of the text for MaskedInput.',\n    type: 'string',\n    defaultValue: '18px'\n  }\n}, themeDocUtils.focusStyle, {}, themeDocUtils.placeholderStyle, {}, themeDocUtils.inputStyle);"]},"metadata":{},"sourceType":"module"}