{"ast":null,"code":"/*! firebase-admin v8.9.2 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Use untyped import syntax for Node built-ins\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar util = require(\"../utils/validator\");\n\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token'; // NOTE: the Google Metadata Service uses HTTP over a vlan\n\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\n\nvar configDir = function () {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  var sys = os.platform();\n\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  } // On *nix the gcloud cli creates a . dir.\n\n\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n}();\n\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\n\nvar ServiceAccountCredential =\n/** @class */\nfunction () {\n  /**\n   * Creates a new ServiceAccountCredential from the given parameters.\n   *\n   * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n   *   environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    var serviceAccount = typeof serviceAccountPathOrObject === 'string' ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);\n    this.projectId = serviceAccount.projectId;\n    this.privateKey = serviceAccount.privateKey;\n    this.clientEmail = serviceAccount.clientEmail;\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  ServiceAccountCredential.prototype.getAccessToken = function () {\n    var token = this.createAuthJwt_();\n    var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    var request = {\n      method: 'POST',\n      url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ServiceAccountCredential.prototype.createAuthJwt_ = function () {\n    var claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    };\n\n    var jwt = require('jsonwebtoken'); // This method is actually synchronous so we can capture and return the buffer.\n\n\n    return jwt.sign(claims, this.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  };\n\n  return ServiceAccountCredential;\n}();\n\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\n\nvar ServiceAccount =\n/** @class */\nfunction () {\n  function ServiceAccount(json) {\n    if (!util.isNonNullObject(json)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.projectId)) {\n      errorMessage = 'Service account object must contain a string \"project_id\" property.';\n    } else if (!util.isNonEmptyString(this.privateKey)) {\n      errorMessage = 'Service account object must contain a string \"private_key\" property.';\n    } else if (!util.isNonEmptyString(this.clientEmail)) {\n      errorMessage = 'Service account object must contain a string \"client_email\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n\n    var forge = require('node-forge');\n\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n\n  ServiceAccount.fromPath = function (filePath) {\n    try {\n      return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n    }\n  };\n\n  return ServiceAccount;\n}();\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\n\n\nvar ComputeEngineCredential =\n/** @class */\nfunction () {\n  function ComputeEngineCredential(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  ComputeEngineCredential.prototype.getAccessToken = function () {\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ComputeEngineCredential.prototype.getProjectId = function () {\n    var _this = this;\n\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n    return this.httpClient.send(request).then(function (resp) {\n      _this.projectId = resp.text;\n      return _this.projectId;\n    }).catch(function (err) {\n      var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\n    });\n  };\n\n  ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\n    return {\n      method: 'GET',\n      url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\n      headers: {\n        'Metadata-Flavor': 'Google'\n      },\n      httpAgent: this.httpAgent\n    };\n  };\n\n  return ComputeEngineCredential;\n}();\n\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\n\nvar RefreshTokenCredential =\n/** @class */\nfunction () {\n  /**\n   * Creates a new RefreshTokenCredential from the given parameters.\n   *\n   * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n   *   environment, as opposed to being explicitly specified by the developer.\n   *\n   * @constructor\n   */\n  function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  RefreshTokenCredential.prototype.getAccessToken = function () {\n    var postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    var request = {\n      method: 'POST',\n      url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  return RefreshTokenCredential;\n}();\n\nexports.RefreshTokenCredential = RefreshTokenCredential;\n\nvar RefreshToken =\n/** @class */\nfunction () {\n  function RefreshToken(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.clientId)) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (!util.isNonEmptyString(this.clientSecret)) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (!util.isNonEmptyString(this.refreshToken)) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (!util.isNonEmptyString(this.type)) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n  /*\n   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n   * data at the path is invalid.\n   */\n\n\n  RefreshToken.fromPath = function (filePath) {\n    try {\n      return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  };\n\n  return RefreshToken;\n}();\n\nfunction getApplicationDefault(httpAgent) {\n  if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n    return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n  } // It is OK to not have this file. If it is present, it must be valid.\n\n\n  if (GCLOUD_CREDENTIAL_PATH) {\n    var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\n\n    if (refreshToken) {\n      return new RefreshTokenCredential(refreshToken, httpAgent, true);\n    }\n  }\n\n  return new ComputeEngineCredential(httpAgent);\n}\n\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential The credential instance to check.\n */\n\nfunction isApplicationDefault(credential) {\n  return credential instanceof ComputeEngineCredential || credential instanceof ServiceAccountCredential && credential.implicit || credential instanceof RefreshTokenCredential && credential.implicit;\n}\n\nexports.isApplicationDefault = isApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to Target object to copy the property into.\n * @param from Source object to copy the property from.\n * @param key Name of the property to copy.\n * @param alt Alternative name of the property to copy.\n */\n\nfunction copyAttr(to, from, key, alt) {\n  var tmp = from[key] || from[alt];\n\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\n\n\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(function (resp) {\n    var json = resp.data;\n\n    if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n    }\n\n    return json;\n  }).catch(function (err) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\n\n\nfunction getErrorMessage(err) {\n  var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n  return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\n\n\nfunction getDetailFromResponse(response) {\n  if (response.isJson() && response.data.error) {\n    var json = response.data;\n    var detail = json.error;\n\n    if (json.error_description) {\n      detail += ' (' + json.error_description + ')';\n    }\n\n    return detail;\n  }\n\n  return response.text || 'Missing error payload';\n}\n\nfunction credentialFromFile(filePath, httpAgent) {\n  var credentialsFile = readCredentialFile(filePath);\n\n  if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n  }\n\n  if (credentialsFile.type === 'service_account') {\n    return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n  }\n\n  if (credentialsFile.type === 'authorized_user') {\n    return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n  }\n\n  throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\n\nfunction readCredentialFile(filePath, ignoreMissing) {\n  var fileText;\n\n  try {\n    fileText = fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    if (ignoreMissing) {\n      return null;\n    }\n\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n  }\n\n  try {\n    return JSON.parse(fileText);\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n  }\n}","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/firebase-admin/lib/auth/credential.js"],"names":["Object","defineProperty","exports","value","fs","require","os","path","error_1","api_request_1","util","GOOGLE_TOKEN_AUDIENCE","GOOGLE_AUTH_TOKEN_HOST","GOOGLE_AUTH_TOKEN_PATH","GOOGLE_METADATA_SERVICE_HOST","GOOGLE_METADATA_SERVICE_TOKEN_PATH","GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH","configDir","sys","platform","length","substring","toLowerCase","process","env","APPDATA","HOME","resolve","GCLOUD_CREDENTIAL_SUFFIX","GCLOUD_CREDENTIAL_PATH","REFRESH_TOKEN_HOST","REFRESH_TOKEN_PATH","ONE_HOUR_IN_SECONDS","JWT_ALGORITHM","ServiceAccountCredential","serviceAccountPathOrObject","httpAgent","implicit","serviceAccount","ServiceAccount","fromPath","projectId","privateKey","clientEmail","httpClient","HttpClient","prototype","getAccessToken","token","createAuthJwt_","postData","request","method","url","headers","data","requestAccessToken","claims","scope","join","jwt","sign","audience","expiresIn","issuer","algorithm","json","isNonNullObject","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","copyAttr","errorMessage","isNonEmptyString","forge","pki","privateKeyFromPem","error","filePath","JSON","parse","readFileSync","ComputeEngineCredential","buildRequest","getProjectId","_this","Promise","send","then","resp","text","catch","err","detail","HttpError","getDetailFromResponse","response","message","urlPath","RefreshTokenCredential","refreshTokenPathOrObject","refreshToken","RefreshToken","clientId","clientSecret","type","getApplicationDefault","GOOGLE_APPLICATION_CREDENTIALS","credentialFromFile","readCredentialFile","isApplicationDefault","credential","to","from","key","alt","tmp","client","access_token","expires_in","stringify","getErrorMessage","isJson","error_description","credentialsFile","ignoreMissing","fileText"],"mappings":"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","sourcesContent":["/*! firebase-admin v8.9.2 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Use untyped import syntax for Node built-ins\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar path = require(\"path\");\nvar error_1 = require(\"../utils/error\");\nvar api_request_1 = require(\"../utils/api-request\");\nvar util = require(\"../utils/validator\");\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\n// NOTE: the Google Metadata Service uses HTTP over a vlan\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\nvar configDir = (function () {\n    // Windows has a dedicated low-rights location for apps at ~/Application Data\n    var sys = os.platform();\n    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n        return process.env.APPDATA;\n    }\n    // On *nix the gcloud cli creates a . dir.\n    return process.env.HOME && path.resolve(process.env.HOME, '.config');\n})();\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\nvar ServiceAccountCredential = /** @class */ (function () {\n    /**\n     * Creates a new ServiceAccountCredential from the given parameters.\n     *\n     * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n     *   environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\n        if (implicit === void 0) { implicit = false; }\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        var serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?\n            ServiceAccount.fromPath(serviceAccountPathOrObject)\n            : new ServiceAccount(serviceAccountPathOrObject);\n        this.projectId = serviceAccount.projectId;\n        this.privateKey = serviceAccount.privateKey;\n        this.clientEmail = serviceAccount.clientEmail;\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    ServiceAccountCredential.prototype.getAccessToken = function () {\n        var token = this.createAuthJwt_();\n        var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +\n            'grant-type%3Ajwt-bearer&assertion=' + token;\n        var request = {\n            method: 'POST',\n            url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    ServiceAccountCredential.prototype.createAuthJwt_ = function () {\n        var claims = {\n            scope: [\n                'https://www.googleapis.com/auth/cloud-platform',\n                'https://www.googleapis.com/auth/firebase.database',\n                'https://www.googleapis.com/auth/firebase.messaging',\n                'https://www.googleapis.com/auth/identitytoolkit',\n                'https://www.googleapis.com/auth/userinfo.email',\n            ].join(' '),\n        };\n        var jwt = require('jsonwebtoken');\n        // This method is actually synchronous so we can capture and return the buffer.\n        return jwt.sign(claims, this.privateKey, {\n            audience: GOOGLE_TOKEN_AUDIENCE,\n            expiresIn: ONE_HOUR_IN_SECONDS,\n            issuer: this.clientEmail,\n            algorithm: JWT_ALGORITHM,\n        });\n    };\n    return ServiceAccountCredential;\n}());\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\nvar ServiceAccount = /** @class */ (function () {\n    function ServiceAccount(json) {\n        if (!util.isNonNullObject(json)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n        }\n        copyAttr(this, json, 'projectId', 'project_id');\n        copyAttr(this, json, 'privateKey', 'private_key');\n        copyAttr(this, json, 'clientEmail', 'client_email');\n        var errorMessage;\n        if (!util.isNonEmptyString(this.projectId)) {\n            errorMessage = 'Service account object must contain a string \"project_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.privateKey)) {\n            errorMessage = 'Service account object must contain a string \"private_key\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientEmail)) {\n            errorMessage = 'Service account object must contain a string \"client_email\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n        var forge = require('node-forge');\n        try {\n            forge.pki.privateKeyFromPem(this.privateKey);\n        }\n        catch (error) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n        }\n    }\n    ServiceAccount.fromPath = function (filePath) {\n        try {\n            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n        }\n    };\n    return ServiceAccount;\n}());\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\nvar ComputeEngineCredential = /** @class */ (function () {\n    function ComputeEngineCredential(httpAgent) {\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    ComputeEngineCredential.prototype.getAccessToken = function () {\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n        return requestAccessToken(this.httpClient, request);\n    };\n    ComputeEngineCredential.prototype.getProjectId = function () {\n        var _this = this;\n        if (this.projectId) {\n            return Promise.resolve(this.projectId);\n        }\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n        return this.httpClient.send(request)\n            .then(function (resp) {\n            _this.projectId = resp.text;\n            return _this.projectId;\n        })\n            .catch(function (err) {\n            var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\n        });\n    };\n    ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\n        return {\n            method: 'GET',\n            url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n            httpAgent: this.httpAgent,\n        };\n    };\n    return ComputeEngineCredential;\n}());\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\nvar RefreshTokenCredential = /** @class */ (function () {\n    /**\n     * Creates a new RefreshTokenCredential from the given parameters.\n     *\n     * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n     *   environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\n        if (implicit === void 0) { implicit = false; }\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?\n            RefreshToken.fromPath(refreshTokenPathOrObject)\n            : new RefreshToken(refreshTokenPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    RefreshTokenCredential.prototype.getAccessToken = function () {\n        var postData = 'client_id=' + this.refreshToken.clientId + '&' +\n            'client_secret=' + this.refreshToken.clientSecret + '&' +\n            'refresh_token=' + this.refreshToken.refreshToken + '&' +\n            'grant_type=refresh_token';\n        var request = {\n            method: 'POST',\n            url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    return RefreshTokenCredential;\n}());\nexports.RefreshTokenCredential = RefreshTokenCredential;\nvar RefreshToken = /** @class */ (function () {\n    function RefreshToken(json) {\n        copyAttr(this, json, 'clientId', 'client_id');\n        copyAttr(this, json, 'clientSecret', 'client_secret');\n        copyAttr(this, json, 'refreshToken', 'refresh_token');\n        copyAttr(this, json, 'type', 'type');\n        var errorMessage;\n        if (!util.isNonEmptyString(this.clientId)) {\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientSecret)) {\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n        }\n        else if (!util.isNonEmptyString(this.refreshToken)) {\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n        }\n        else if (!util.isNonEmptyString(this.type)) {\n            errorMessage = 'Refresh token must contain a \"type\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n    }\n    /*\n     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n     * data at the path is invalid.\n     */\n    RefreshToken.fromPath = function (filePath) {\n        try {\n            return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n        }\n    };\n    return RefreshToken;\n}());\nfunction getApplicationDefault(httpAgent) {\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n    }\n    // It is OK to not have this file. If it is present, it must be valid.\n    if (GCLOUD_CREDENTIAL_PATH) {\n        var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\n        if (refreshToken) {\n            return new RefreshTokenCredential(refreshToken, httpAgent, true);\n        }\n    }\n    return new ComputeEngineCredential(httpAgent);\n}\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential The credential instance to check.\n */\nfunction isApplicationDefault(credential) {\n    return credential instanceof ComputeEngineCredential ||\n        (credential instanceof ServiceAccountCredential && credential.implicit) ||\n        (credential instanceof RefreshTokenCredential && credential.implicit);\n}\nexports.isApplicationDefault = isApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to Target object to copy the property into.\n * @param from Source object to copy the property from.\n * @param key Name of the property to copy.\n * @param alt Alternative name of the property to copy.\n */\nfunction copyAttr(to, from, key, alt) {\n    var tmp = from[key] || from[alt];\n    if (typeof tmp !== 'undefined') {\n        to[key] = tmp;\n    }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\nfunction requestAccessToken(client, request) {\n    return client.send(request).then(function (resp) {\n        var json = resp.data;\n        if (!json.access_token || !json.expires_in) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n        }\n        return json;\n    }).catch(function (err) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n    });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\nfunction getErrorMessage(err) {\n    var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n    return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\nfunction getDetailFromResponse(response) {\n    if (response.isJson() && response.data.error) {\n        var json = response.data;\n        var detail = json.error;\n        if (json.error_description) {\n            detail += ' (' + json.error_description + ')';\n        }\n        return detail;\n    }\n    return response.text || 'Missing error payload';\n}\nfunction credentialFromFile(filePath, httpAgent) {\n    var credentialsFile = readCredentialFile(filePath);\n    if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n    }\n    if (credentialsFile.type === 'service_account') {\n        return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n    }\n    if (credentialsFile.type === 'authorized_user') {\n        return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\nfunction readCredentialFile(filePath, ignoreMissing) {\n    var fileText;\n    try {\n        fileText = fs.readFileSync(filePath, 'utf8');\n    }\n    catch (error) {\n        if (ignoreMissing) {\n            return null;\n        }\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n    }\n    try {\n        return JSON.parse(fileText);\n    }\n    catch (error) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}