{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst querystring = require(\"querystring\");\n\nconst stream = require(\"stream\");\n\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst messages = require(\"../messages\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nclass OAuth2Client extends authclient_1.AuthClient {\n  constructor(optionsOrClientId, clientSecret, redirectUri) {\n    super();\n    this.certificateCache = {};\n    this.certificateExpiry = null;\n    this.certificateCacheFormat = CertificateFormat.PEM;\n    this.refreshTokenPromises = new Map();\n    const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  generateAuthUrl(opts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   *\n   * For a full example see:\n   * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n   */\n\n\n  async generateCodeVerifierAsync() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const crypto = crypto_1.createCrypto();\n    const randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n\n    const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n    const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier); // We need to use base64UrlEncoding instead of standard base64\n\n    const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n    return {\n      codeVerifier,\n      codeChallenge\n    };\n  }\n\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  async getTokenAsync(options) {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    });\n    const tokens = res.data;\n\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    this.emit('tokens', tokens);\n    return {\n      tokens,\n      res\n    };\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n\n\n  async refreshToken(refreshToken) {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    } // If a request to refresh using the same token has started,\n    // return the same promise.\n\n\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken);\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken).then(r => {\n      this.refreshTokenPromises.delete(refreshToken);\n      return r;\n    }, e => {\n      this.refreshTokenPromises.delete(refreshToken);\n      throw e;\n    });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  async refreshTokenNoCache(refreshToken) {\n    if (!refreshToken) {\n      throw new Error('No refresh token is set.');\n    }\n\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    }; // request for new token\n\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    });\n    const tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    this.emit('tokens', tokens);\n    return {\n      tokens,\n      res\n    };\n  }\n\n  refreshAccessToken(callback) {\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  async refreshAccessTokenAsync() {\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {\n      credentials: this.credentials,\n      res: r.res\n    };\n  }\n\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  async getAccessTokenAsync() {\n    const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n    if (shouldRefresh) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n\n      if (!r.credentials || r.credentials && !r.credentials.access_token) {\n        throw new Error('Could not refresh access token.');\n      }\n\n      return {\n        token: r.credentials.access_token,\n        res: r.res\n      };\n    } else {\n      return {\n        token: this.credentials.access_token\n      };\n    }\n  }\n\n  getRequestMetadata(url, callback) {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   * @param url The optional url being authorized\n   */\n\n\n  async getRequestHeaders(url) {\n    const headers = (await this.getRequestMetadataAsync(url)).headers;\n    return headers;\n  }\n\n  async getRequestMetadataAsync(url) {\n    const thisCreds = this.credentials;\n\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {\n        headers\n      };\n    }\n\n    if (this.apiKey) {\n      return {\n        headers: {\n          'X-Goog-Api-Key': this.apiKey\n        }\n      };\n    }\n\n    let r = null;\n    let tokens = null;\n\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err;\n\n      if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n        e.message = `Could not refresh access token: ${e.message}`;\n      }\n\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {\n      headers: this.addSharedMetadataHeaders(headers),\n      res: r.res\n    };\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   */\n\n\n  static getRevokeTokenUrl(token) {\n    const parameters = querystring.stringify({\n      token\n    });\n    return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n  }\n\n  revokeToken(token, callback) {\n    const opts = {\n      url: OAuth2Client.getRevokeTokenUrl(token),\n      method: 'POST'\n    };\n\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  async requestAsync(opts, retry = false) {\n    let r2;\n\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      opts.headers = opts.headers || {};\n\n      if (r.headers && r.headers['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n      }\n\n      if (r.headers && r.headers.Authorization) {\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.headers['X-Goog-Api-Key'] = this.apiKey;\n      }\n\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n\n      if (res) {\n        const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but either no\n        //   expiry_date was available or the forceRefreshOnFailure flag is set.\n        //   The absent expiry_date case can happen when developers stash the\n        //   access_token and refresh_token for later use, but the access_token\n        //   fails on the first try because it's expired. Some developers may\n        //   choose to enable forceRefreshOnFailure to mitigate time-related\n        //   errors.\n\n        const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n\n      throw e;\n    }\n\n    return r2;\n  }\n\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  async verifyIdTokenAsync(options) {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n    return login;\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n\n\n  async getTokenInfo(accessToken) {\n    const {\n      data\n    } = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {\n        access_token: accessToken\n      }\n    });\n    const info = Object.assign({\n      expiry_date: new Date().getTime() + data.expires_in * 1000,\n      scopes: data.scope.split(' ')\n    }, data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync() {\n    const nowTime = new Date().getTime();\n    const format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n    if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n      return {\n        certs: this.certificateCache,\n        format\n      };\n    }\n\n    let res;\n    let url;\n\n    switch (format) {\n      case CertificateFormat.PEM:\n        url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n        break;\n\n      case CertificateFormat.JWK:\n        url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n        break;\n\n      default:\n        throw new Error(`Unsupported certificate format ${format}`);\n    }\n\n    try {\n      res = await this.transporter.request({\n        url\n      });\n    } catch (e) {\n      e.message = `Failed to retrieve verification certificates: ${e.message}`;\n      throw e;\n    }\n\n    const cacheControl = res ? res.headers['cache-control'] : undefined;\n    let cacheAge = -1;\n\n    if (cacheControl) {\n      const pattern = new RegExp('max-age=([0-9]*)');\n      const regexResult = pattern.exec(cacheControl);\n\n      if (regexResult && regexResult.length === 2) {\n        // Cache results with max-age (in seconds)\n        cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n      }\n    }\n\n    let certificates = {};\n\n    switch (format) {\n      case CertificateFormat.PEM:\n        certificates = res.data;\n        break;\n\n      case CertificateFormat.JWK:\n        for (const key of res.data.keys) {\n          certificates[key.kid] = key;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unsupported certificate format ${format}`);\n    }\n\n    const now = new Date();\n    this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    this.certificateCache = certificates;\n    this.certificateCacheFormat = format;\n    return {\n      certs: certificates,\n      format,\n      res\n    };\n  }\n\n  getIapPublicKeys(callback) {\n    if (callback) {\n      this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n    } else {\n      return this.getIapPublicKeysAsync();\n    }\n  }\n\n  async getIapPublicKeysAsync() {\n    const nowTime = new Date().getTime();\n    let res;\n    const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n\n    try {\n      res = await this.transporter.request({\n        url\n      });\n    } catch (e) {\n      e.message = `Failed to retrieve verification certificates: ${e.message}`;\n      throw e;\n    }\n\n    return {\n      pubkeys: res.data,\n      res\n    };\n  }\n\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n\n\n  async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    const crypto = crypto_1.createCrypto();\n\n    if (!maxExpiry) {\n      maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n    }\n\n    const segments = jwt.split('.');\n\n    if (segments.length !== 3) {\n      throw new Error('Wrong number of segments in token: ' + jwt);\n    }\n\n    const signed = segments[0] + '.' + segments[1];\n    let signature = segments[2];\n    let envelope;\n    let payload;\n\n    try {\n      envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n    } catch (err) {\n      err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n      throw err;\n    }\n\n    if (!envelope) {\n      throw new Error(\"Can't parse token envelope: \" + segments[0]);\n    }\n\n    try {\n      payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n    } catch (err) {\n      err.message = `Can't parse token payload '${segments[0]}`;\n      throw err;\n    }\n\n    if (!payload) {\n      throw new Error(\"Can't parse token payload: \" + segments[1]);\n    }\n\n    if (!certs.hasOwnProperty(envelope.kid)) {\n      // If this is not present, then there's no reason to attempt verification\n      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n    }\n\n    const cert = certs[envelope.kid];\n\n    if (envelope.alg === 'ES256') {\n      signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n    }\n\n    const verified = await crypto.verify(cert, signed, signature);\n\n    if (!verified) {\n      throw new Error('Invalid token signature: ' + jwt);\n    }\n\n    if (!payload.iat) {\n      throw new Error('No issue time in token: ' + JSON.stringify(payload));\n    }\n\n    if (!payload.exp) {\n      throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n    }\n\n    const iat = Number(payload.iat);\n    if (isNaN(iat)) throw new Error('iat field using invalid format');\n    const exp = Number(payload.exp);\n    if (isNaN(exp)) throw new Error('exp field using invalid format');\n    const now = new Date().getTime() / 1000;\n\n    if (exp >= now + maxExpiry) {\n      throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now < earliest) {\n      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n    }\n\n    if (now > latest) {\n      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss) < 0) {\n      throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n    } // Check the audience matches if we have one\n\n\n    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n      const aud = payload.aud;\n      let audVerified = false; // If the requiredAudience is an array, check if it contains token\n      // audience\n\n      if (requiredAudience.constructor === Array) {\n        audVerified = requiredAudience.indexOf(aud) > -1;\n      } else {\n        audVerified = aud === requiredAudience;\n      }\n\n      if (!audVerified) {\n        throw new Error('Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n\n    return new loginticket_1.LoginTicket(envelope, payload);\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n\n\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["Object","defineProperty","exports","value","querystring","require","stream","formatEcdsa","crypto_1","messages","authclient_1","loginticket_1","CodeChallengeMethod","CertificateFormat","OAuth2Client","AuthClient","constructor","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","forceRefreshOnFailure","generateAuthUrl","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","unencodedCodeChallenge","sha256DigestBase64","codeChallenge","split","getToken","codeOrOptions","callback","options","code","getTokenAsync","then","r","tokens","res","e","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","refreshAccessToken","refreshAccessTokenAsync","credentials","getAccessToken","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","getRequestMetadata","warn","OAUTH_GET_REQUEST_METADATA_DEPRECATED","getRequestMetadataAsync","getRequestHeaders","thisCreds","apiKey","token_type","Authorization","err","status","message","addSharedMetadataHeaders","getRevokeTokenUrl","parameters","GOOGLE_OAUTH2_REVOKE_URL_","revokeToken","revokeCredentials","revokeCredentialsAsync","requestAsync","retry","r2","statusCode","mayRequireRefresh","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","login","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","getTokenInfo","accessToken","GOOGLE_TOKEN_INFO_URL","params","info","assign","scopes","getFederatedSignonCerts","nowTime","format","hasBrowserCrypto","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","key","keys","kid","now","getIapPublicKeys","getIapPublicKeysAsync","pubkeys","GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_","verifySignedJwtWithCerts","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","payload","JSON","parse","decodeBase64StringUtf8","hasOwnProperty","cert","alg","joseToDer","toString","verified","verify","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","LoginTicket","expiryDate"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst messages = require(\"../messages\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (opts.scope instanceof Array) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return rootUrl + '?' + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = crypto_1.createCrypto();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: options.codeVerifier,\n        };\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(values),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        // request for new token\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(data),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                throw new Error('No refresh token is set.');\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    getRequestMetadata(url, callback) {\n        messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n        if (callback) {\n            this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n        }\n        else {\n            return this.getRequestMetadataAsync();\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n            throw new Error('No access, refresh token or API key is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            };\n            return { headers };\n        }\n        if (this.apiKey) {\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\n        };\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST',\n        };\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: 'GET',\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n            params: { access_token: accessToken },\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = crypto_1.hasBrowserCrypto()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            throw e;\n        }\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp('max-age=([0-9]*)');\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        const nowTime = new Date().getTime();\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = crypto_1.createCrypto();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            err.message = `Can't parse token payload '${segments[0]}`;\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!certs.hasOwnProperty(envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = [\n    'accounts.google.com',\n    'https://accounts.google.com',\n];\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}