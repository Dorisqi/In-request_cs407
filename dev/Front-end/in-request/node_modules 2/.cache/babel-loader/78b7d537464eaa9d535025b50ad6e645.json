{"ast":null,"code":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  var _proto = BufferList.prototype;\n\n  _proto.push = function push(v) {\n    var entry = {\n      data: v,\n      next: null\n    };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  _proto.unshift = function unshift(v) {\n    var entry = {\n      data: v,\n      next: this.head\n    };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  _proto.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  _proto.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  _proto.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n\n    while (p = p.next) {\n      ret += s + p.data;\n    }\n\n    return ret;\n  };\n\n  _proto.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n\n    return ret;\n  } // Consumes a specified amount of bytes or characters from the buffered data.\n  ;\n\n  _proto.consume = function consume(n, hasStrings) {\n    var ret;\n\n    if (n < this.head.data.length) {\n      // `slice` is the same for buffers and strings.\n      ret = this.head.data.slice(0, n);\n      this.head.data = this.head.data.slice(n);\n    } else if (n === this.head.data.length) {\n      // First chunk is a perfect match.\n      ret = this.shift();\n    } else {\n      // Result spans more than one buffer.\n      ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n\n    return ret;\n  };\n\n  _proto.first = function first() {\n    return this.head.data;\n  } // Consumes a specified amount of characters from the buffered data.\n  ;\n\n  _proto._getString = function _getString(n) {\n    var p = this.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n\n    while (p = p.next) {\n      var str = p.data;\n      var nb = n > str.length ? str.length : n;\n      if (nb === str.length) ret += str;else ret += str.slice(0, n);\n      n -= nb;\n\n      if (n === 0) {\n        if (nb === str.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = str.slice(nb);\n        }\n\n        break;\n      }\n\n      ++c;\n    }\n\n    this.length -= c;\n    return ret;\n  } // Consumes a specified amount of bytes from the buffered data.\n  ;\n\n  _proto._getBuffer = function _getBuffer(n) {\n    var ret = Buffer.allocUnsafe(n);\n    var p = this.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n\n    while (p = p.next) {\n      var buf = p.data;\n      var nb = n > buf.length ? buf.length : n;\n      buf.copy(ret, ret.length - n, 0, nb);\n      n -= nb;\n\n      if (n === 0) {\n        if (nb === buf.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = buf.slice(nb);\n        }\n\n        break;\n      }\n\n      ++c;\n    }\n\n    this.length -= c;\n    return ret;\n  } // Make sure the linked list only shows the minimal necessary information.\n  ;\n\n  _proto[custom] = function (_, options) {\n    return inspect(this, _objectSpread({}, options, {\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    }));\n  };\n\n  return BufferList;\n}();","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/buffer_list.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_require","require","Buffer","_require2","inspect","custom","copyBuffer","src","offset","prototype","copy","call","module","exports","BufferList","head","tail","_proto","v","entry","data","next","unshift","shift","ret","clear","join","s","p","concat","n","alloc","allocUnsafe","consume","hasStrings","slice","_getString","_getBuffer","first","c","str","nb","buf","_","options","depth","customInspect"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  var _proto = BufferList.prototype;\n\n  _proto.push = function push(v) {\n    var entry = {\n      data: v,\n      next: null\n    };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  _proto.unshift = function unshift(v) {\n    var entry = {\n      data: v,\n      next: this.head\n    };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  _proto.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  _proto.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  _proto.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n\n    while (p = p.next) {\n      ret += s + p.data;\n    }\n\n    return ret;\n  };\n\n  _proto.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n\n    return ret;\n  } // Consumes a specified amount of bytes or characters from the buffered data.\n  ;\n\n  _proto.consume = function consume(n, hasStrings) {\n    var ret;\n\n    if (n < this.head.data.length) {\n      // `slice` is the same for buffers and strings.\n      ret = this.head.data.slice(0, n);\n      this.head.data = this.head.data.slice(n);\n    } else if (n === this.head.data.length) {\n      // First chunk is a perfect match.\n      ret = this.shift();\n    } else {\n      // Result spans more than one buffer.\n      ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n\n    return ret;\n  };\n\n  _proto.first = function first() {\n    return this.head.data;\n  } // Consumes a specified amount of characters from the buffered data.\n  ;\n\n  _proto._getString = function _getString(n) {\n    var p = this.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n\n    while (p = p.next) {\n      var str = p.data;\n      var nb = n > str.length ? str.length : n;\n      if (nb === str.length) ret += str;else ret += str.slice(0, n);\n      n -= nb;\n\n      if (n === 0) {\n        if (nb === str.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = str.slice(nb);\n        }\n\n        break;\n      }\n\n      ++c;\n    }\n\n    this.length -= c;\n    return ret;\n  } // Consumes a specified amount of bytes from the buffered data.\n  ;\n\n  _proto._getBuffer = function _getBuffer(n) {\n    var ret = Buffer.allocUnsafe(n);\n    var p = this.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n\n    while (p = p.next) {\n      var buf = p.data;\n      var nb = n > buf.length ? buf.length : n;\n      buf.copy(ret, ret.length - n, 0, nb);\n      n -= nb;\n\n      if (n === 0) {\n        if (nb === buf.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = buf.slice(nb);\n        }\n\n        break;\n      }\n\n      ++c;\n    }\n\n    this.length -= c;\n    return ret;\n  } // Make sure the linked list only shows the minimal necessary information.\n  ;\n\n  _proto[custom] = function (_, options) {\n    return inspect(this, _objectSpread({}, options, {\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    }));\n  };\n\n  return BufferList;\n}();"]},"metadata":{},"sourceType":"script"}