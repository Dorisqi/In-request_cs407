{"ast":null,"code":"\"use strict\"; // Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  const slice = Array.prototype.slice; // tslint:disable-next-line:no-any\n\n  const wrapper = function () {\n    const context = this;\n    let last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      const arg = arguments[last];\n\n      if (typeof arg === 'undefined') {\n        continue; // skip trailing undefined.\n      }\n\n      if (typeof arg !== 'function') {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(context, arguments);\n    } // peel trailing undefined.\n\n\n    const args = slice.call(arguments, 0, last + 1); // tslint:disable-next-line:variable-name\n\n    let PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (context && context.Promise) {\n      PromiseCtor = context.Promise;\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      // tslint:disable-next-line:no-any\n      args.push((...args) => {\n        const callbackArgs = slice.call(args);\n        const err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(context, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\n\nfunction promisifyAll(Class, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) && // is it promisable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n    // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = exports.promisify(originalMethod, options);\n    }\n  });\n}\n\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction callbackify(originalMethod) {\n  if (originalMethod.callbackified_) {\n    return originalMethod;\n  } // tslint:disable-next-line:no-any\n\n\n  const wrapper = function () {\n    const context = this;\n\n    if (typeof arguments[arguments.length - 1] !== 'function') {\n      return originalMethod.apply(context, arguments);\n    }\n\n    const cb = Array.prototype.pop.call(arguments);\n    originalMethod.apply(context, arguments).then( // tslint:disable-next-line:no-any\n    res => {\n      res = Array.isArray(res) ? res : [res];\n      cb(null, ...res);\n    }, err => cb(err));\n  };\n\n  wrapper.callbackified_ = true;\n  return wrapper;\n}\n\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n\nfunction callbackifyAll( // tslint:disable-next-line:variable-name\nClass, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/^_|(Stream|_)|^constructor$/.test(methodName) && // is it callbackifyable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n    // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.callbackified_) {\n      Class.prototype[methodName] = exports.callbackify(originalMethod);\n    }\n  });\n}\n\nexports.callbackifyAll = callbackifyAll;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/@google-cloud/promisify/build/src/index.js"],"names":["Object","defineProperty","exports","value","promisify","originalMethod","options","promisified_","slice","Array","prototype","wrapper","context","last","arguments","length","arg","apply","args","call","PromiseCtor","Promise","resolve","reject","push","callbackArgs","err","shift","singular","promisifyAll","Class","exclude","ownPropertyNames","getOwnPropertyNames","methods","filter","methodName","test","indexOf","forEach","callbackify","callbackified_","cb","pop","then","res","isArray","callbackifyAll"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\nfunction promisify(originalMethod, options) {\n    if (originalMethod.promisified_) {\n        return originalMethod;\n    }\n    options = options || {};\n    const slice = Array.prototype.slice;\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        const context = this;\n        let last;\n        for (last = arguments.length - 1; last >= 0; last--) {\n            const arg = arguments[last];\n            if (typeof arg === 'undefined') {\n                continue; // skip trailing undefined.\n            }\n            if (typeof arg !== 'function') {\n                break; // non-callback last argument found.\n            }\n            return originalMethod.apply(context, arguments);\n        }\n        // peel trailing undefined.\n        const args = slice.call(arguments, 0, last + 1);\n        // tslint:disable-next-line:variable-name\n        let PromiseCtor = Promise;\n        // Because dedupe will likely create a single install of\n        // @google-cloud/common to be shared amongst all modules, we need to\n        // localize it at the Service level.\n        if (context && context.Promise) {\n            PromiseCtor = context.Promise;\n        }\n        return new PromiseCtor((resolve, reject) => {\n            // tslint:disable-next-line:no-any\n            args.push((...args) => {\n                const callbackArgs = slice.call(args);\n                const err = callbackArgs.shift();\n                if (err) {\n                    return reject(err);\n                }\n                if (options.singular && callbackArgs.length === 1) {\n                    resolve(callbackArgs[0]);\n                }\n                else {\n                    resolve(callbackArgs);\n                }\n            });\n            originalMethod.apply(context, args);\n        });\n    };\n    wrapper.promisified_ = true;\n    return wrapper;\n}\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\nfunction promisifyAll(Class, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) && // is it promisable?\n            exclude.indexOf(methodName) === -1); // is it blacklisted?\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.promisified_) {\n            Class.prototype[methodName] = exports.promisify(originalMethod, options);\n        }\n    });\n}\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\nfunction callbackify(originalMethod) {\n    if (originalMethod.callbackified_) {\n        return originalMethod;\n    }\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        const context = this;\n        if (typeof arguments[arguments.length - 1] !== 'function') {\n            return originalMethod.apply(context, arguments);\n        }\n        const cb = Array.prototype.pop.call(arguments);\n        originalMethod.apply(context, arguments).then(\n        // tslint:disable-next-line:no-any\n        (res) => {\n            res = Array.isArray(res) ? res : [res];\n            cb(null, ...res);\n        }, (err) => cb(err));\n    };\n    wrapper.callbackified_ = true;\n    return wrapper;\n}\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\nfunction callbackifyAll(\n// tslint:disable-next-line:variable-name\nClass, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/^_|(Stream|_)|^constructor$/.test(methodName) && // is it callbackifyable?\n            exclude.indexOf(methodName) === -1); // is it blacklisted?\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.callbackified_) {\n            Class.prototype[methodName] = exports.callbackify(originalMethod);\n        }\n    });\n}\nexports.callbackifyAll = callbackifyAll;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}