{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key) {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\n\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n\n  if (value != null) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\n\n\nclass Metadata {\n  constructor(options) {\n    this.internalRepr = new Map();\n\n    if (options === undefined) {\n      this.options = {};\n    } else {\n      this.options = options;\n    }\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n\n\n  remove(key) {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n\n\n  get(key) {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n\n\n  getMap() {\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n\n\n  clone() {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue = value.map(v => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    });\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n\n\n  merge(other) {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n\n\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(value => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  } // For compatibility with the other Metadata implementation\n\n\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n\n\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    Object.keys(headers).forEach(key => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => result.add(key, v.trim()));\n            } else {\n              result.add(key, values);\n            }\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        logging_1.log(constants_1.LogVerbosity.ERROR, message);\n      }\n    });\n    return result;\n  }\n\n}\n\nexports.Metadata = Metadata;","map":{"version":3,"sources":["../../src/metadata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value != null) {\n        if (isBinaryKey(key)) {\n            if (!(value instanceof Buffer)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (value instanceof Buffer) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options) {\n        this.internalRepr = new Map();\n        if (options === undefined) {\n            this.options = {};\n        }\n        else {\n            this.options = options;\n        }\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        this.internalRepr.forEach((values, key) => {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = v instanceof Buffer ? v.slice() : v;\n            }\n        });\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        this.internalRepr.forEach((value, key) => {\n            const clonedValue = value.map(v => {\n                if (v instanceof Buffer) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        });\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        other.internalRepr.forEach((values, key) => {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        });\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        this.internalRepr.forEach((values, key) => {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(value => {\n                if (value instanceof Buffer) {\n                    return value.toString('base64');\n                }\n                else {\n                    return value;\n                }\n            });\n        });\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        Object.keys(headers).forEach(key => {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                return;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach(v => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach(v => result.add(key, v.trim()));\n                        }\n                        else {\n                            result.add(key, values);\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                logging_1.log(constants_1.LogVerbosity.ERROR, message);\n            }\n        });\n        return result;\n    }\n}\nexports.Metadata = Metadata;\n//# sourceMappingURL=metadata.js.map"]},"metadata":{},"sourceType":"script"}