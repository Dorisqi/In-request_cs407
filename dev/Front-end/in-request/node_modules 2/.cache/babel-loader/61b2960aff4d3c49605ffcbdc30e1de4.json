{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.findVisibleParent = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.setFocusWithoutScroll = exports.getNewContainer = exports.getBodyChildElements = exports.getFirstFocusableDescendant = exports.findScrollParents = void 0;\n\nvar findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (result.length === 0) {\n      result.push(document);\n    } else if (result[0].tagName.toLowerCase() === 'body') {\n      result.length = 0;\n      result.push(document);\n    }\n  }\n\n  return result;\n};\n\nexports.findScrollParents = findScrollParents;\n\nvar getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n    var tagName = child.tagName.toLowerCase();\n\n    if (tagName === 'input' || tagName === 'select') {\n      return child;\n    }\n  }\n\n  return undefined;\n};\n\nexports.getFirstFocusableDescendant = getFirstFocusableDescendant;\n\nvar getBodyChildElements = function getBodyChildElements() {\n  var excludeMatch = /^(script|link)$/i;\n  var children = [];\n  [].forEach.call(document.body.children, function (node) {\n    if (!excludeMatch.test(node.tagName)) {\n      children.push(node);\n    }\n  });\n  return children;\n};\n\nexports.getBodyChildElements = getBodyChildElements;\n\nvar getNewContainer = function getNewContainer() {\n  // setup DOM\n  var container = document.createElement('div');\n  document.body.appendChild(container);\n  return container;\n};\n\nexports.getNewContainer = getNewContainer;\n\nvar setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\n\nexports.setFocusWithoutScroll = setFocusWithoutScroll;\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\n\nvar makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', false); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\nexports.makeNodeFocusable = makeNodeFocusable;\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\n\nvar makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabindex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabindex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\n\nexports.makeNodeUnfocusable = makeNodeUnfocusable;\n\nvar findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\n\nexports.findVisibleParent = findVisibleParent;\n\nvar isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  if (target === void 0) {\n    target = window;\n  }\n\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      height = _target$getBoundingCl.height,\n      top = _target$getBoundingCl.top;\n\n  return bottom >= top + height;\n};\n\nexports.isNodeAfterScroll = isNodeAfterScroll;\n\nvar isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  if (target === void 0) {\n    target = window;\n  }\n\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top;\n\n  var _target$getBoundingCl2 = target.getBoundingClientRect(),\n      targetTop = _target$getBoundingCl2.top;\n\n  return top <= targetTop;\n};\n\nexports.isNodeBeforeScroll = isNodeBeforeScroll;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/grommet/utils/DOM.js"],"names":["exports","__esModule","isNodeBeforeScroll","isNodeAfterScroll","findVisibleParent","makeNodeUnfocusable","makeNodeFocusable","setFocusWithoutScroll","getNewContainer","getBodyChildElements","getFirstFocusableDescendant","findScrollParents","element","horizontal","result","parent","parentNode","getBoundingClientRect","rect","width","scrollWidth","push","height","scrollHeight","length","document","tagName","toLowerCase","children","getElementsByTagName","i","child","undefined","excludeMatch","forEach","call","body","node","test","container","createElement","appendChild","x","window","scrollX","y","scrollY","focus","scrollTo","TABINDEX","TABINDEX_STATE","hasAttribute","setAttribute","elements","Array","prototype","filter","prior","getAttribute","removeAttribute","autoFocusingTags","currentTag","match","offsetParent","parentElement","target","_node$getBoundingClie","bottom","_target$getBoundingCl","top","_node$getBoundingClie2","_target$getBoundingCl2","targetTop"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.findVisibleParent = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.setFocusWithoutScroll = exports.getNewContainer = exports.getBodyChildElements = exports.getFirstFocusableDescendant = exports.findScrollParents = void 0;\n\nvar findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (result.length === 0) {\n      result.push(document);\n    } else if (result[0].tagName.toLowerCase() === 'body') {\n      result.length = 0;\n      result.push(document);\n    }\n  }\n\n  return result;\n};\n\nexports.findScrollParents = findScrollParents;\n\nvar getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n    var tagName = child.tagName.toLowerCase();\n\n    if (tagName === 'input' || tagName === 'select') {\n      return child;\n    }\n  }\n\n  return undefined;\n};\n\nexports.getFirstFocusableDescendant = getFirstFocusableDescendant;\n\nvar getBodyChildElements = function getBodyChildElements() {\n  var excludeMatch = /^(script|link)$/i;\n  var children = [];\n  [].forEach.call(document.body.children, function (node) {\n    if (!excludeMatch.test(node.tagName)) {\n      children.push(node);\n    }\n  });\n  return children;\n};\n\nexports.getBodyChildElements = getBodyChildElements;\n\nvar getNewContainer = function getNewContainer() {\n  // setup DOM\n  var container = document.createElement('div');\n  document.body.appendChild(container);\n  return container;\n};\n\nexports.getNewContainer = getNewContainer;\n\nvar setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\n\nexports.setFocusWithoutScroll = setFocusWithoutScroll;\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\n\nvar makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', false); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\nexports.makeNodeFocusable = makeNodeFocusable;\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\n\nvar makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabindex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabindex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\n\nexports.makeNodeUnfocusable = makeNodeUnfocusable;\n\nvar findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\n\nexports.findVisibleParent = findVisibleParent;\n\nvar isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  if (target === void 0) {\n    target = window;\n  }\n\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      height = _target$getBoundingCl.height,\n      top = _target$getBoundingCl.top;\n\n  return bottom >= top + height;\n};\n\nexports.isNodeAfterScroll = isNodeAfterScroll;\n\nvar isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  if (target === void 0) {\n    target = window;\n  }\n\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top;\n\n  var _target$getBoundingCl2 = target.getBoundingClientRect(),\n      targetTop = _target$getBoundingCl2.top;\n\n  return top <= targetTop;\n};\n\nexports.isNodeBeforeScroll = isNodeBeforeScroll;"]},"metadata":{},"sourceType":"script"}