{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require('deep-equal');\n\nconst assert = require(\"assert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst path_1 = require(\"./path\");\n\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\n\n\nclass DocumentSnapshotBuilder {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n\n\n  build() {\n    assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n    assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n    return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n  }\n\n}\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\n\nclass DocumentSnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromObject(ref, obj) {\n    const serializer = ref.firestore._serializer;\n    return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n  }\n  /**\n   * Creates a DocumentSnapshot from an UpdateMap.\n   *\n   * This methods expands the top-level field paths in a JavaScript map and\n   * turns { foo.bar : foobar } into { foo { bar : foobar }}\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param data The field/value map to expand.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const serializer = ref.firestore._serializer;\n    /**\n     * Merges 'value' at the field path specified by the path array into\n     * 'target'.\n     */\n\n    function merge(target, value, path, pos) {\n      const key = path[pos];\n      const isLast = pos === path.length - 1;\n\n      if (target[key] === undefined) {\n        if (isLast) {\n          if (value instanceof field_value_1.FieldTransform) {\n            // If there is already data at this path, we need to retain it.\n            // Otherwise, we don't include it in the DocumentSnapshot.\n            return !util_1.isEmpty(target) ? target : null;\n          } // The merge is done.\n\n\n          const leafNode = serializer.encodeValue(value);\n\n          if (leafNode) {\n            target[key] = leafNode;\n          }\n\n          return target;\n        } else {\n          // We need to expand the target object.\n          const childNode = {\n            mapValue: {\n              fields: {}\n            }\n          };\n          const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n          if (nestedValue) {\n            childNode.mapValue.fields = nestedValue;\n            target[key] = childNode;\n            return target;\n          } else {\n            return !util_1.isEmpty(target) ? target : null;\n          }\n        }\n      } else {\n        assert(!isLast, \"Can't merge current value into a nested object\");\n        target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n        return target;\n      }\n    }\n\n    const res = {};\n\n    for (const [key, value] of data) {\n      const path = key.toArray();\n      merge(res, value, path, 0);\n    }\n\n    return new DocumentSnapshot(ref, res);\n  }\n  /**\n   * True if the document exists.\n   *\n   * @type {boolean}\n   * @name DocumentSnapshot#exists\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n   *   }\n   * });\n   */\n\n\n  get exists() {\n    return this._fieldsProto !== undefined;\n  }\n  /**\n   * A [DocumentReference]{@link DocumentReference} for the document\n   * stored in this snapshot.\n   *\n   * @type {DocumentReference}\n   * @name DocumentSnapshot#ref\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n   *   }\n   * });\n   */\n\n\n  get ref() {\n    return this._ref;\n  }\n  /**\n   * The ID of the document for which this DocumentSnapshot contains data.\n   *\n   * @type {string}\n   * @name DocumentSnapshot#id\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Document found with name '${documentSnapshot.id}'`);\n   *   }\n   * });\n   */\n\n\n  get id() {\n    return this._ref.id;\n  }\n  /**\n   * The time the document was created. Undefined for documents that don't\n   * exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#createTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let createTime = documentSnapshot.createTime;\n   *     console.log(`Document created at '${createTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get createTime() {\n    return this._createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined for documents that don't exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#updateTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let updateTime = documentSnapshot.updateTime;\n   *     console.log(`Document updated at '${updateTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get updateTime() {\n    return this._updateTime;\n  }\n  /**\n   * The time this snapshot was read.\n   *\n   * @type {Timestamp}\n   * @name DocumentSnapshot#readTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let readTime = documentSnapshot.readTime;\n   *   console.log(`Document read at '${readTime.toDate()}'`);\n   * });\n   */\n\n\n  get readTime() {\n    if (this._readTime === undefined) {\n      throw new Error(`Called 'readTime' on a local document`);\n    }\n\n    return this._readTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object. Returns 'undefined' if\n   * the document doesn't exist.\n   *\n   * @returns {T|undefined} An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n\n\n  data() {\n    const fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const obj = {};\n\n    for (const prop of Object.keys(fields)) {\n      obj[prop] = this._serializer.decodeValue(fields[prop]);\n    }\n\n    return this.ref._converter.fromFirestore(obj);\n  }\n  /**\n   * Retrieves the field specified by `field`.\n   *\n   * @param {string|FieldPath} field The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns {*} The data at the specified field location or undefined if no\n   * such field exists.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ a: { b: 'c' }}).then(() => {\n   *   return documentRef.get();\n   * }).then(documentSnapshot => {\n   *   let field = documentSnapshot.get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // tslint:disable-next-line no-any\n\n\n  get(field) {\n    // tslint:disable-line no-any\n    path_1.validateFieldPath('field', field);\n    const protoField = this.protoField(field);\n\n    if (protoField === undefined) {\n      return undefined;\n    }\n\n    return this._serializer.decodeValue(protoField);\n  }\n  /**\n   * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n   * representation.\n   *\n   * @private\n   * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The Protobuf-encoded data at the specified field location or\n   * undefined if no such field exists.\n   */\n\n\n  protoField(field) {\n    let fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const components = path_1.FieldPath.fromArgument(field).toArray();\n\n    while (components.length > 1) {\n      fields = fields[components.shift()];\n\n      if (!fields || !fields.mapValue) {\n        return undefined;\n      }\n\n      fields = fields.mapValue.fields;\n    }\n\n    return fields[components[0]];\n  }\n  /**\n   * Checks whether this DocumentSnapshot contains any fields.\n   *\n   * @private\n   * @return {boolean}\n   */\n\n\n  get isEmpty() {\n    return this._fieldsProto === undefined || util_1.isEmpty(this._fieldsProto);\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Document' Protobuf.\n   *\n   * @private\n   * @returns The document in the format the API expects.\n   */\n\n\n  toProto() {\n    return {\n      update: {\n        name: this._ref.formattedName,\n        fields: this._fieldsProto\n      }\n    };\n  }\n  /**\n   * Returns true if the document's data and path in this `DocumentSnapshot` is\n   * equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every document read, we explicitly\n    // ignore all document metadata in this comparison.\n    return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto, {\n      strict: true\n    });\n  }\n\n}\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\n\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param readTime The time when this snapshot was read.\n   * @param createTime The time when the document was created.\n   * @param updateTime The time when the document was last updated.\n   */\n  constructor(ref, fieldsProto, readTime, createTime, updateTime) {\n    super(ref, fieldsProto, readTime, createTime, updateTime);\n  }\n  /**\n   * The time the document was created.\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#createTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n   * });\n   */\n\n\n  get createTime() {\n    return super.createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated).\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#updateTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n   * });\n   */\n\n\n  get updateTime() {\n    return super.updateTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object.\n   *\n   * @override\n   *\n   * @returns {T} An object containing all fields in the document.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n\n\n  data() {\n    const data = super.data();\n\n    if (!data) {\n      throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n    }\n\n    return data;\n  }\n\n}\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\n\nclass DocumentMask {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  constructor(fieldPaths) {\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  static fromUpdateMap(data) {\n    const fieldPaths = [];\n    data.forEach((value, key) => {\n      if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n        fieldPaths.push(path_1.FieldPath.fromArgument(key));\n      }\n    });\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask from an array of field paths.\n   *\n   * @private\n   * @param fieldMask A list of field paths.\n   */\n\n\n  static fromFieldMask(fieldMask) {\n    const fieldPaths = [];\n\n    for (const fieldPath of fieldMask) {\n      fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n    }\n\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask with the field names of a document.\n   *\n   * @private\n   * @param data An object with fields to modify. Only the keys are used to\n   * extract the document mask.\n   */\n\n\n  static fromObject(data) {\n    const fieldPaths = [];\n\n    function extractFieldPaths(currentData, currentPath) {\n      let isEmpty = true;\n\n      for (const key of Object.keys(currentData)) {\n        isEmpty = false; // We don't split on dots since fromObject is called with\n        // DocumentData.\n\n        const childSegment = new path_1.FieldPath(key);\n        const childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n        const value = currentData[key];\n\n        if (value instanceof field_value_1.FieldTransform) {\n          if (value.includeInDocumentMask) {\n            fieldPaths.push(childPath);\n          }\n        } else if (util_1.isPlainObject(value)) {\n          extractFieldPaths(value, childPath);\n        } else {\n          fieldPaths.push(childPath);\n        }\n      } // Add a field path for an explicitly updated empty map.\n\n\n      if (currentPath && isEmpty) {\n        fieldPaths.push(currentPath);\n      }\n    }\n\n    extractFieldPaths(data);\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Returns true if this document mask contains no fields.\n   *\n   * @private\n   * @return {boolean} Whether this document mask is empty.\n   */\n\n\n  get isEmpty() {\n    return this._sortedPaths.length === 0;\n  }\n  /**\n   * Removes the specified values from a sorted field path array.\n   *\n   * @private\n   * @param input A sorted array of FieldPaths.\n   * @param values An array of FieldPaths to remove.\n   */\n\n\n  static removeFromSortedArray(input, values) {\n    for (let i = 0; i < input.length;) {\n      let removed = false;\n\n      for (const fieldPath of values) {\n        if (input[i].isEqual(fieldPath)) {\n          input.splice(i, 1);\n          removed = true;\n          break;\n        }\n      }\n\n      if (!removed) {\n        ++i;\n      }\n    }\n  }\n  /**\n   * Removes the field path specified in 'fieldPaths' from this document mask.\n   *\n   * @private\n   * @param fieldPaths An array of FieldPaths.\n   */\n\n\n  removeFields(fieldPaths) {\n    DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n  }\n  /**\n   * Returns whether this document mask contains 'fieldPath'.\n   *\n   * @private\n   * @param fieldPath The field path to test.\n   * @return Whether this document mask contains 'fieldPath'.\n   */\n\n\n  contains(fieldPath) {\n    for (const sortedPath of this._sortedPaths) {\n      const cmp = sortedPath.compareTo(fieldPath);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp > 0) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Removes all properties from 'data' that are not contained in this document\n   * mask.\n   *\n   * @private\n   * @param data An object to filter.\n   * @return A shallow copy of the object filtered by this document mask.\n   */\n\n\n  applyTo(data) {\n    /*!\n     * Applies this DocumentMask to 'data' and computes the list of field paths\n     * that were specified in the mask but are not present in 'data'.\n     */\n    const applyDocumentMask = data => {\n      const remainingPaths = this._sortedPaths.slice(0);\n\n      const processObject = (currentData, currentPath) => {\n        let result = null;\n        Object.keys(currentData).forEach(key => {\n          const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n          if (this.contains(childPath)) {\n            DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n            result = result || {};\n            result[key] = currentData[key];\n          } else if (util_1.isObject(currentData[key])) {\n            const childObject = processObject(currentData[key], childPath);\n\n            if (childObject) {\n              result = result || {};\n              result[key] = childObject;\n            }\n          }\n        });\n        return result;\n      }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n      const filteredData = processObject(data) || {};\n      return {\n        filteredData,\n        remainingPaths\n      };\n    };\n\n    const result = applyDocumentMask(data);\n\n    if (result.remainingPaths.length !== 0) {\n      throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n    }\n\n    return result.filteredData;\n  }\n  /**\n   * Converts a document mask to the Firestore 'DocumentMask' Proto.\n   *\n   * @private\n   * @returns A Firestore 'DocumentMask' Proto.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return {};\n    }\n\n    const encodedPaths = [];\n\n    for (const fieldPath of this._sortedPaths) {\n      encodedPaths.push(fieldPath.formattedName);\n    }\n\n    return {\n      fieldPaths: encodedPaths\n    };\n  }\n\n}\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\n\nclass DocumentTransform {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  constructor(ref, transforms) {\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromObject(ref, obj) {\n    const updateMap = new Map();\n\n    for (const prop of Object.keys(obj)) {\n      updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n    }\n\n    return DocumentTransform.fromUpdateMap(ref, updateMap);\n  }\n  /**\n   * Generates a DocumentTransform from an Update Map.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param data The update data to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const transforms = new Map();\n\n    function encode_(val, path, allowTransforms) {\n      if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n        if (allowTransforms) {\n          transforms.set(path, val);\n        } else {\n          throw new Error(`${val.methodName}() is not supported inside of array values.`);\n        }\n      } else if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; ++i) {\n          // We need to verify that no array value contains a document transform\n          encode_(val[i], path.append(String(i)), false);\n        }\n      } else if (util_1.isPlainObject(val)) {\n        for (const prop of Object.keys(val)) {\n          encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n        }\n      }\n    }\n\n    data.forEach((value, key) => {\n      encode_(value, path_1.FieldPath.fromArgument(key), true);\n    });\n    return new DocumentTransform(ref, transforms);\n  }\n  /**\n   * Whether this DocumentTransform contains any actionable transformations.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this.transforms.size === 0;\n  }\n  /**\n   * Returns the array of fields in this DocumentTransform.\n   *\n   * @private\n   */\n\n\n  get fields() {\n    return Array.from(this.transforms.keys());\n  }\n  /**\n   * Validates the user provided field values in this document transform.\n   * @private\n   */\n\n\n  validate() {\n    this.transforms.forEach(transform => transform.validate());\n  }\n  /**\n   * Converts a document transform to the Firestore 'DocumentTransform' Proto.\n   *\n   * @private\n   * @param serializer The Firestore serializer\n   * @returns A Firestore 'DocumentTransform' Proto or 'null' if this transform\n   * is empty.\n   */\n\n\n  toProto(serializer) {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const fieldTransforms = [];\n\n    for (const [path, transform] of this.transforms) {\n      fieldTransforms.push(transform.toProto(serializer, path));\n    }\n\n    return {\n      transform: {\n        document: this.ref.formattedName,\n        fieldTransforms\n      }\n    };\n  }\n\n}\n\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\n\nclass Precondition {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  constructor(options) {\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const proto = {};\n\n    if (this._lastUpdateTime !== undefined) {\n      const valueProto = this._lastUpdateTime.toProto();\n\n      proto.updateTime = valueProto.timestampValue;\n    } else {\n      proto.exists = this._exists;\n    }\n\n    return proto;\n  }\n  /**\n   * Whether this DocumentTransform contains any enforcement.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this._exists === undefined && !this._lastUpdateTime;\n  }\n\n}\n\nexports.Precondition = Precondition;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/@google-cloud/firestore/build/src/document.js"],"names":["Object","defineProperty","exports","value","deepEqual","require","assert","field_value_1","path_1","util_1","DocumentSnapshotBuilder","constructor","ref","build","fieldsProto","undefined","createTime","updateTime","QueryDocumentSnapshot","readTime","DocumentSnapshot","_fieldsProto","_ref","_serializer","firestore","_readTime","_createTime","_updateTime","fromObject","obj","serializer","encodeFields","fromUpdateMap","data","merge","target","path","pos","key","isLast","length","FieldTransform","isEmpty","leafNode","encodeValue","childNode","mapValue","fields","nestedValue","res","toArray","exists","id","Error","prop","keys","decodeValue","_converter","fromFirestore","get","field","validateFieldPath","protoField","components","FieldPath","fromArgument","shift","toProto","update","name","formattedName","isEqual","other","strict","DocumentMask","fieldPaths","_sortedPaths","sort","a","b","compareTo","forEach","includeInDocumentMask","push","fromFieldMask","fieldMask","fieldPath","extractFieldPaths","currentData","currentPath","childSegment","childPath","append","isPlainObject","removeFromSortedArray","input","values","i","removed","splice","removeFields","contains","sortedPath","cmp","applyTo","applyDocumentMask","remainingPaths","slice","processObject","result","isObject","childObject","filteredData","encodedPaths","DocumentTransform","transforms","updateMap","Map","set","encode_","val","allowTransforms","includeInDocumentTransform","methodName","Array","isArray","String","size","from","validate","transform","fieldTransforms","document","Precondition","options","_exists","_lastUpdateTime","lastUpdateTime","proto","valueProto","timestampValue"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst deepEqual = require('deep-equal');\nconst assert = require(\"assert\");\nconst field_value_1 = require(\"./field-value\");\nconst path_1 = require(\"./path\");\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\nclass DocumentSnapshotBuilder {\n    // We include the DocumentReference in the constructor in order to allow the\n    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n    constructor(ref) {\n        this.ref = ref;\n    }\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    build() {\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n        return this.fieldsProto\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\nclass DocumentSnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param ref The reference to the document.\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document (or undefined if the document does not exist).\n     * @param readTime The time when this snapshot was read  (or undefined if\n     * the document exists only locally).\n     * @param createTime The time when the document was created (or undefined if\n     * the document does not exist).\n     * @param updateTime The time when the document was last updated (or undefined\n     * if the document does not exist).\n     */\n    constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n        this._fieldsProto = _fieldsProto;\n        this._ref = ref;\n        this._serializer = ref.firestore._serializer;\n        this._readTime = readTime;\n        this._createTime = createTime;\n        this._updateTime = updateTime;\n    }\n    /**\n     * Creates a DocumentSnapshot from an object.\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param obj The object to store in the DocumentSnapshot.\n     * @return The created DocumentSnapshot.\n     */\n    static fromObject(ref, obj) {\n        const serializer = ref.firestore._serializer;\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n    static fromUpdateMap(ref, data) {\n        const serializer = ref.firestore._serializer;\n        /**\n         * Merges 'value' at the field path specified by the path array into\n         * 'target'.\n         */\n        function merge(target, value, path, pos) {\n            const key = path[pos];\n            const isLast = pos === path.length - 1;\n            if (target[key] === undefined) {\n                if (isLast) {\n                    if (value instanceof field_value_1.FieldTransform) {\n                        // If there is already data at this path, we need to retain it.\n                        // Otherwise, we don't include it in the DocumentSnapshot.\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                    // The merge is done.\n                    const leafNode = serializer.encodeValue(value);\n                    if (leafNode) {\n                        target[key] = leafNode;\n                    }\n                    return target;\n                }\n                else {\n                    // We need to expand the target object.\n                    const childNode = {\n                        mapValue: {\n                            fields: {},\n                        },\n                    };\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n                    if (nestedValue) {\n                        childNode.mapValue.fields = nestedValue;\n                        target[key] = childNode;\n                        return target;\n                    }\n                    else {\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                }\n            }\n            else {\n                assert(!isLast, \"Can't merge current value into a nested object\");\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n                return target;\n            }\n        }\n        const res = {};\n        for (const [key, value] of data) {\n            const path = key.toArray();\n            merge(res, value, path, 0);\n        }\n        return new DocumentSnapshot(ref, res);\n    }\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get exists() {\n        return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n    get ref() {\n        return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n    get id() {\n        return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get createTime() {\n        return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get updateTime() {\n        return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        if (this._readTime === undefined) {\n            throw new Error(`Called 'readTime' on a local document`);\n        }\n        return this._readTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const obj = {};\n        for (const prop of Object.keys(fields)) {\n            obj[prop] = this._serializer.decodeValue(fields[prop]);\n        }\n        return this.ref._converter.fromFirestore(obj);\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // tslint:disable-next-line no-any\n    get(field) {\n        // tslint:disable-line no-any\n        path_1.validateFieldPath('field', field);\n        const protoField = this.protoField(field);\n        if (protoField === undefined) {\n            return undefined;\n        }\n        return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n    protoField(field) {\n        let fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const components = path_1.FieldPath.fromArgument(field).toArray();\n        while (components.length > 1) {\n            fields = fields[components.shift()];\n            if (!fields || !fields.mapValue) {\n                return undefined;\n            }\n            fields = fields.mapValue.fields;\n        }\n        return fields[components[0]];\n    }\n    /**\n     * Checks whether this DocumentSnapshot contains any fields.\n     *\n     * @private\n     * @return {boolean}\n     */\n    get isEmpty() {\n        return this._fieldsProto === undefined || util_1.isEmpty(this._fieldsProto);\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' Protobuf.\n     *\n     * @private\n     * @returns The document in the format the API expects.\n     */\n    toProto() {\n        return {\n            update: {\n                name: this._ref.formattedName,\n                fields: this._fieldsProto,\n            },\n        };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every document read, we explicitly\n        // ignore all document metadata in this comparison.\n        return (this === other ||\n            (other instanceof DocumentSnapshot &&\n                this._ref.isEqual(other._ref) &&\n                deepEqual(this._fieldsProto, other._fieldsProto, { strict: true })));\n    }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param ref The reference to the document.\n     * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document.\n     * @param readTime The time when this snapshot was read.\n     * @param createTime The time when the document was created.\n     * @param updateTime The time when the document was last updated.\n     */\n    constructor(ref, fieldsProto, readTime, createTime, updateTime) {\n        super(ref, fieldsProto, readTime, createTime, updateTime);\n    }\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get createTime() {\n        return super.createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n    get updateTime() {\n        return super.updateTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const data = super.data();\n        if (!data) {\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n        }\n        return data;\n    }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\nclass DocumentMask {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param fieldPaths The field paths in this mask.\n     */\n    constructor(fieldPaths) {\n        this._sortedPaths = fieldPaths;\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Creates a document mask with the field paths of a document.\n     *\n     * @private\n     * @param data A map with fields to modify. Only the keys are used to extract\n     * the document mask.\n     */\n    static fromUpdateMap(data) {\n        const fieldPaths = [];\n        data.forEach((value, key) => {\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\n            }\n        });\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n    static fromFieldMask(fieldMask) {\n        const fieldPaths = [];\n        for (const fieldPath of fieldMask) {\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n    static fromObject(data) {\n        const fieldPaths = [];\n        function extractFieldPaths(currentData, currentPath) {\n            let isEmpty = true;\n            for (const key of Object.keys(currentData)) {\n                isEmpty = false;\n                // We don't split on dots since fromObject is called with\n                // DocumentData.\n                const childSegment = new path_1.FieldPath(key);\n                const childPath = currentPath\n                    ? currentPath.append(childSegment)\n                    : childSegment;\n                const value = currentData[key];\n                if (value instanceof field_value_1.FieldTransform) {\n                    if (value.includeInDocumentMask) {\n                        fieldPaths.push(childPath);\n                    }\n                }\n                else if (util_1.isPlainObject(value)) {\n                    extractFieldPaths(value, childPath);\n                }\n                else {\n                    fieldPaths.push(childPath);\n                }\n            }\n            // Add a field path for an explicitly updated empty map.\n            if (currentPath && isEmpty) {\n                fieldPaths.push(currentPath);\n            }\n        }\n        extractFieldPaths(data);\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get isEmpty() {\n        return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n    static removeFromSortedArray(input, values) {\n        for (let i = 0; i < input.length;) {\n            let removed = false;\n            for (const fieldPath of values) {\n                if (input[i].isEqual(fieldPath)) {\n                    input.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed) {\n                ++i;\n            }\n        }\n    }\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    removeFields(fieldPaths) {\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n    contains(fieldPath) {\n        for (const sortedPath of this._sortedPaths) {\n            const cmp = sortedPath.compareTo(fieldPath);\n            if (cmp === 0) {\n                return true;\n            }\n            else if (cmp > 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n    applyTo(data) {\n        /*!\n         * Applies this DocumentMask to 'data' and computes the list of field paths\n         * that were specified in the mask but are not present in 'data'.\n         */\n        const applyDocumentMask = (data) => {\n            const remainingPaths = this._sortedPaths.slice(0);\n            const processObject = (currentData, currentPath) => {\n                let result = null;\n                Object.keys(currentData).forEach(key => {\n                    const childPath = currentPath\n                        ? currentPath.append(key)\n                        : new path_1.FieldPath(key);\n                    if (this.contains(childPath)) {\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n                        result = result || {};\n                        result[key] = currentData[key];\n                    }\n                    else if (util_1.isObject(currentData[key])) {\n                        const childObject = processObject(currentData[key], childPath);\n                        if (childObject) {\n                            result = result || {};\n                            result[key] = childObject;\n                        }\n                    }\n                });\n                return result;\n            };\n            // processObject() returns 'null' if the DocumentMask is empty.\n            const filteredData = processObject(data) || {};\n            return {\n                filteredData,\n                remainingPaths,\n            };\n        };\n        const result = applyDocumentMask(data);\n        if (result.remainingPaths.length !== 0) {\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n        }\n        return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return {};\n        }\n        const encodedPaths = [];\n        for (const fieldPath of this._sortedPaths) {\n            encodedPaths.push(fieldPath.formattedName);\n        }\n        return {\n            fieldPaths: encodedPaths,\n        };\n    }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\nclass DocumentTransform {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param ref The DocumentReference for this transform.\n     * @param transforms A Map of FieldPaths to FieldTransforms.\n     */\n    constructor(ref, transforms) {\n        this.ref = ref;\n        this.transforms = transforms;\n    }\n    /**\n     * Generates a DocumentTransform from a JavaScript object.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param obj The object to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromObject(ref, obj) {\n        const updateMap = new Map();\n        for (const prop of Object.keys(obj)) {\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromUpdateMap(ref, data) {\n        const transforms = new Map();\n        function encode_(val, path, allowTransforms) {\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n                if (allowTransforms) {\n                    transforms.set(path, val);\n                }\n                else {\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\n                }\n            }\n            else if (Array.isArray(val)) {\n                for (let i = 0; i < val.length; ++i) {\n                    // We need to verify that no array value contains a document transform\n                    encode_(val[i], path.append(String(i)), false);\n                }\n            }\n            else if (util_1.isPlainObject(val)) {\n                for (const prop of Object.keys(val)) {\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n                }\n            }\n        }\n        data.forEach((value, key) => {\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\n        });\n        return new DocumentTransform(ref, transforms);\n    }\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n    get fields() {\n        return Array.from(this.transforms.keys());\n    }\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     */\n    validate() {\n        this.transforms.forEach(transform => transform.validate());\n    }\n    /**\n     * Converts a document transform to the Firestore 'DocumentTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A Firestore 'DocumentTransform' Proto or 'null' if this transform\n     * is empty.\n     */\n    toProto(serializer) {\n        if (this.isEmpty) {\n            return null;\n        }\n        const fieldTransforms = [];\n        for (const [path, transform] of this.transforms) {\n            fieldTransforms.push(transform.toProto(serializer, path));\n        }\n        return {\n            transform: {\n                document: this.ref.formattedName,\n                fieldTransforms,\n            },\n        };\n    }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\nclass Precondition {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param options.exists - Whether the referenced document should exist in\n     * Firestore,\n     * @param options.lastUpdateTime - The last update time of the referenced\n     * document in Firestore.\n     * @param options\n     */\n    constructor(options) {\n        if (options !== undefined) {\n            this._exists = options.exists;\n            this._lastUpdateTime = options.lastUpdateTime;\n        }\n    }\n    /**\n     * Generates the Protobuf `Preconditon` object for this precondition.\n     *\n     * @private\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\n     * preconditions.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return null;\n        }\n        const proto = {};\n        if (this._lastUpdateTime !== undefined) {\n            const valueProto = this._lastUpdateTime.toProto();\n            proto.updateTime = valueProto.timestampValue;\n        }\n        else {\n            proto.exists = this._exists;\n        }\n        return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._exists === undefined && !this._lastUpdateTime;\n    }\n}\nexports.Precondition = Precondition;\n//# sourceMappingURL=document.js.map"]},"metadata":{},"sourceType":"script"}