{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst resolver_1 = require(\"./resolver\");\n\nconst dns = require(\"dns\");\n\nconst semver = require(\"semver\");\n\nconst util = require(\"util\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst TRACER_NAME = 'dns_resolver';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/* These regular expressions match IP addresses with optional ports in different\n * formats. In each case, capture group 1 contains the address, and capture\n * group 2 contains the port number, if present */\n\n/**\n * Matches 4 groups of up to 3 digits each, separated by periods, optionally\n * followed by a colon and a number.\n */\n\n\nconst IPV4_REGEX = /^(\\d{1,3}(?:\\.\\d{1,3}){3})(?::(\\d+))?$/;\n/**\n * Matches any number of groups of up to 4 hex digits (case insensitive)\n * separated by 1 or more colons. This variant does not match a port number.\n */\n\nconst IPV6_REGEX = /^([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)$/i;\n/**\n * Matches the same as the IPv6_REGEX, surrounded by square brackets, and\n * optionally followed by a colon and a number.\n */\n\nconst IPV6_BRACKET_REGEX = /^\\[([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)\\](?::(\\d+))?$/i;\n/**\n * Matches `[dns:][//authority/]host[:port]`, where `authority` and `host` are\n * both arbitrary sequences of dot-separated strings of alphanumeric characters\n * and `port` is a sequence of digits. Group 1 contains the hostname and group\n * 2 contains the port number if provided.\n */\n\nconst DNS_REGEX = /^(?:dns:)?(?:\\/\\/(?:[a-zA-Z0-9-]+\\.?)+\\/)?((?:[a-zA-Z0-9-]+\\.?)+)(?::(\\d+))?$/;\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\n\nconst DEFAULT_PORT = '443';\n/**\n * The range of Node versions in which the Node issue\n * https://github.com/nodejs/node/issues/28216 has been fixed. In other\n * versions, IPv6 literal addresses cannot be used to establish HTTP/2\n * connections.\n */\n\nconst IPV6_SUPPORT_RANGE = '>= 12.6';\n/**\n * Get a promise that always resolves with either the result of the function\n * or the error if it failed.\n * @param fn\n */\n\nfunction resolvePromisify(fn) {\n  return arg => new Promise((resolve, reject) => {\n    fn(arg, (error, result) => {\n      if (error) {\n        resolve(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nconst resolveTxtPromise = resolvePromisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Attempt to parse a target string as an IP address\n * @param target\n * @return An \"IP:port\" string in an array if parsing was successful, `null` otherwise\n */\n\nfunction parseIP(target) {\n  /* These three regular expressions are all mutually exclusive, so we just\n   * want the first one that matches the target string, if any do. */\n  const ipv4Match = IPV4_REGEX.exec(target);\n  const match = ipv4Match || IPV6_REGEX.exec(target) || IPV6_BRACKET_REGEX.exec(target);\n\n  if (match === null) {\n    return null;\n  } // ipv6 addresses should be bracketed\n\n\n  const addr = match[1];\n  let port;\n\n  if (match[2]) {\n    port = match[2];\n  } else {\n    port = DEFAULT_PORT;\n  }\n\n  return [{\n    host: addr,\n    port: +port\n  }];\n}\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\n\n\nfunction mergeArrays(...arrays) {\n  const result = [];\n\n  for (let i = 0; i < Math.max.apply(null, arrays.map(array => array.length)); i++) {\n    for (const array of arrays) {\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\n\n\nclass DnsResolver {\n  constructor(target, listener) {\n    this.target = target;\n    this.listener = listener;\n    /* The promise results here contain, in order, the A record, the AAAA record,\n     * and either the TXT record or an error if TXT resolution failed */\n\n    this.pendingResultPromise = null;\n    trace('Resolver constructed for target ' + target);\n    this.ipResult = parseIP(target);\n    const dnsMatch = DNS_REGEX.exec(target);\n\n    if (dnsMatch === null) {\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      this.dnsHostname = dnsMatch[1];\n\n      if (dnsMatch[2]) {\n        this.port = dnsMatch[2];\n      } else {\n        this.port = DEFAULT_PORT;\n      }\n    }\n\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: `Name resolution failed for target ${this.target}`,\n      metadata: new metadata_1.Metadata()\n    };\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT\n   */\n\n\n  startResolution() {\n    if (this.ipResult !== null) {\n      trace('Returning IP address for target ' + this.target);\n      setImmediate(() => {\n        this.listener.onSuccessfulResolution(this.ipResult, null, null);\n      });\n      return;\n    }\n\n    if (this.dnsHostname !== null) {\n      const hostname = this.dnsHostname;\n      /* We lookup both address families here and then split them up later\n       * because when looking up a single family, dns.lookup outputs an error\n       * if the name exists but there are no records for that family, and that\n       * error is indistinguishable from other kinds of errors */\n\n      const addressResult = dnsLookupPromise(hostname, {\n        all: true\n      });\n      /* We handle the TXT query promise differently than the others because\n       * the name resolution attempt as a whole is a success even if the TXT\n       * lookup fails */\n\n      const txtResult = resolveTxtPromise(hostname);\n      this.pendingResultPromise = Promise.all([addressResult, txtResult]);\n      this.pendingResultPromise.then(([addressList, txtRecord]) => {\n        this.pendingResultPromise = null;\n        const ip4Addresses = addressList.filter(addr => addr.family === 4);\n        let ip6Addresses;\n\n        if (semver.satisfies(process.version, IPV6_SUPPORT_RANGE)) {\n          ip6Addresses = addressList.filter(addr => addr.family === 6);\n        } else {\n          ip6Addresses = [];\n        }\n\n        const allAddresses = mergeArrays(ip4Addresses, ip6Addresses).map(addr => ({\n          host: addr.address,\n          port: +this.port\n        }));\n        const allAddressesString = '[' + allAddresses.map(addr => addr.host + ':' + addr.port).join(',') + ']';\n        trace('Resolved addresses for target ' + this.target + ': ' + allAddressesString);\n\n        if (allAddresses.length === 0) {\n          this.listener.onError(this.defaultResolutionError);\n          return;\n        }\n\n        let serviceConfig = null;\n        let serviceConfigError = null;\n\n        if (txtRecord instanceof Error) {\n          serviceConfigError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'TXT query failed',\n            metadata: new metadata_1.Metadata()\n          };\n        } else {\n          try {\n            serviceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n          } catch (err) {\n            serviceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'Parsing service config failed',\n              metadata: new metadata_1.Metadata()\n            };\n          }\n        }\n\n        this.listener.onSuccessfulResolution(allAddresses, serviceConfig, serviceConfigError);\n      }, err => {\n        trace('Resolution error for target ' + this.target + ': ' + err.message);\n        this.pendingResultPromise = null;\n        this.listener.onError(this.defaultResolutionError);\n      });\n    }\n  }\n\n  updateResolution() {\n    trace('Resolution update requested for target ' + this.target);\n\n    if (this.pendingResultPromise === null) {\n      this.startResolution();\n    }\n  }\n  /**\n   * Get the default authority for the given target. For IP targets, that is\n   * the IP address. For DNS targets, it is the hostname.\n   * @param target\n   */\n\n\n  static getDefaultAuthority(target) {\n    const ipMatch = IPV4_REGEX.exec(target) || IPV6_REGEX.exec(target) || IPV6_BRACKET_REGEX.exec(target);\n\n    if (ipMatch) {\n      return ipMatch[1];\n    }\n\n    const dnsMatch = DNS_REGEX.exec(target);\n\n    if (dnsMatch) {\n      return dnsMatch[1];\n    }\n\n    throw new Error(`Failed to parse target ${target}`);\n  }\n\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\n\n\nfunction setup() {\n  resolver_1.registerResolver('dns:', DnsResolver);\n  resolver_1.registerDefaultResolver(DnsResolver);\n}\n\nexports.setup = setup;","map":{"version":3,"sources":["../../src/resolver-dns.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolver_1 = require(\"./resolver\");\nconst dns = require(\"dns\");\nconst semver = require(\"semver\");\nconst util = require(\"util\");\nconst service_config_1 = require(\"./service-config\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/* These regular expressions match IP addresses with optional ports in different\n * formats. In each case, capture group 1 contains the address, and capture\n * group 2 contains the port number, if present */\n/**\n * Matches 4 groups of up to 3 digits each, separated by periods, optionally\n * followed by a colon and a number.\n */\nconst IPV4_REGEX = /^(\\d{1,3}(?:\\.\\d{1,3}){3})(?::(\\d+))?$/;\n/**\n * Matches any number of groups of up to 4 hex digits (case insensitive)\n * separated by 1 or more colons. This variant does not match a port number.\n */\nconst IPV6_REGEX = /^([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)$/i;\n/**\n * Matches the same as the IPv6_REGEX, surrounded by square brackets, and\n * optionally followed by a colon and a number.\n */\nconst IPV6_BRACKET_REGEX = /^\\[([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)\\](?::(\\d+))?$/i;\n/**\n * Matches `[dns:][//authority/]host[:port]`, where `authority` and `host` are\n * both arbitrary sequences of dot-separated strings of alphanumeric characters\n * and `port` is a sequence of digits. Group 1 contains the hostname and group\n * 2 contains the port number if provided.\n */\nconst DNS_REGEX = /^(?:dns:)?(?:\\/\\/(?:[a-zA-Z0-9-]+\\.?)+\\/)?((?:[a-zA-Z0-9-]+\\.?)+)(?::(\\d+))?$/;\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = '443';\n/**\n * The range of Node versions in which the Node issue\n * https://github.com/nodejs/node/issues/28216 has been fixed. In other\n * versions, IPv6 literal addresses cannot be used to establish HTTP/2\n * connections.\n */\nconst IPV6_SUPPORT_RANGE = '>= 12.6';\n/**\n * Get a promise that always resolves with either the result of the function\n * or the error if it failed.\n * @param fn\n */\nfunction resolvePromisify(fn) {\n    return arg => new Promise((resolve, reject) => {\n        fn(arg, (error, result) => {\n            if (error) {\n                resolve(error);\n            }\n            else {\n                resolve(result);\n            }\n        });\n    });\n}\nconst resolveTxtPromise = resolvePromisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Attempt to parse a target string as an IP address\n * @param target\n * @return An \"IP:port\" string in an array if parsing was successful, `null` otherwise\n */\nfunction parseIP(target) {\n    /* These three regular expressions are all mutually exclusive, so we just\n     * want the first one that matches the target string, if any do. */\n    const ipv4Match = IPV4_REGEX.exec(target);\n    const match = ipv4Match || IPV6_REGEX.exec(target) || IPV6_BRACKET_REGEX.exec(target);\n    if (match === null) {\n        return null;\n    }\n    // ipv6 addresses should be bracketed\n    const addr = match[1];\n    let port;\n    if (match[2]) {\n        port = match[2];\n    }\n    else {\n        port = DEFAULT_PORT;\n    }\n    return [{ host: addr, port: +port }];\n}\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map(array => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener) {\n        this.target = target;\n        this.listener = listener;\n        /* The promise results here contain, in order, the A record, the AAAA record,\n         * and either the TXT record or an error if TXT resolution failed */\n        this.pendingResultPromise = null;\n        trace('Resolver constructed for target ' + target);\n        this.ipResult = parseIP(target);\n        const dnsMatch = DNS_REGEX.exec(target);\n        if (dnsMatch === null) {\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            this.dnsHostname = dnsMatch[1];\n            if (dnsMatch[2]) {\n                this.port = dnsMatch[2];\n            }\n            else {\n                this.port = DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${this.target}`,\n            metadata: new metadata_1.Metadata(),\n        };\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            trace('Returning IP address for target ' + this.target);\n            setImmediate(() => {\n                this.listener.onSuccessfulResolution(this.ipResult, null, null);\n            });\n            return;\n        }\n        if (this.dnsHostname !== null) {\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            const addressResult = dnsLookupPromise(hostname, { all: true });\n            /* We handle the TXT query promise differently than the others because\n             * the name resolution attempt as a whole is a success even if the TXT\n             * lookup fails */\n            const txtResult = resolveTxtPromise(hostname);\n            this.pendingResultPromise = Promise.all([addressResult, txtResult]);\n            this.pendingResultPromise.then(([addressList, txtRecord]) => {\n                this.pendingResultPromise = null;\n                const ip4Addresses = addressList.filter(addr => addr.family === 4);\n                let ip6Addresses;\n                if (semver.satisfies(process.version, IPV6_SUPPORT_RANGE)) {\n                    ip6Addresses = addressList.filter(addr => addr.family === 6);\n                }\n                else {\n                    ip6Addresses = [];\n                }\n                const allAddresses = mergeArrays(ip4Addresses, ip6Addresses).map(addr => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    allAddresses.map(addr => addr.host + ':' + addr.port).join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    this.target +\n                    ': ' +\n                    allAddressesString);\n                if (allAddresses.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                let serviceConfig = null;\n                let serviceConfigError = null;\n                if (txtRecord instanceof Error) {\n                    serviceConfigError = {\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'TXT query failed',\n                        metadata: new metadata_1.Metadata(),\n                    };\n                }\n                else {\n                    try {\n                        serviceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        serviceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: 'Parsing service config failed',\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                }\n                this.listener.onSuccessfulResolution(allAddresses, serviceConfig, serviceConfigError);\n            }, err => {\n                trace('Resolution error for target ' +\n                    this.target +\n                    ': ' +\n                    err.message);\n                this.pendingResultPromise = null;\n                this.listener.onError(this.defaultResolutionError);\n            });\n        }\n    }\n    updateResolution() {\n        trace('Resolution update requested for target ' + this.target);\n        if (this.pendingResultPromise === null) {\n            this.startResolution();\n        }\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        const ipMatch = IPV4_REGEX.exec(target) ||\n            IPV6_REGEX.exec(target) ||\n            IPV6_BRACKET_REGEX.exec(target);\n        if (ipMatch) {\n            return ipMatch[1];\n        }\n        const dnsMatch = DNS_REGEX.exec(target);\n        if (dnsMatch) {\n            return dnsMatch[1];\n        }\n        throw new Error(`Failed to parse target ${target}`);\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    resolver_1.registerResolver('dns:', DnsResolver);\n    resolver_1.registerDefaultResolver(DnsResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-dns.js.map"]},"metadata":{},"sourceType":"script"}