{"ast":null,"code":"\"use strict\";\n\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n  keepCase: false\n};\n\nvar tokenize = require(\"./tokenize\"),\n    Root = require(\"./root\"),\n    Type = require(\"./type\"),\n    Field = require(\"./field\"),\n    MapField = require(\"./mapfield\"),\n    OneOf = require(\"./oneof\"),\n    Enum = require(\"./enum\"),\n    Service = require(\"./service\"),\n    Method = require(\"./method\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n\nvar base10Re = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re = /^0[0-7]+$/,\n    base8NegRe = /^-?0[0-7]+$/,\n    numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n/**\r\n * Result object returned from {@link parse}.\r\n * @interface IParserResult\r\n * @property {string|undefined} package Package name, if declared\r\n * @property {string[]|undefined} imports Imports, if any\r\n * @property {string[]|undefined} weakImports Weak imports, if any\r\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\r\n * @property {Root} root Populated root instance\r\n */\n\n/**\r\n * Options modifying the behavior of {@link parse}.\r\n * @interface IParseOptions\r\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\r\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\r\n */\n\n/**\r\n * Options modifying the behavior of JSON serialization.\r\n * @interface IToJSONOptions\r\n * @property {boolean} [keepComments=false] Serializes comments.\r\n */\n\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @param {string} source Source contents\r\n * @param {Root} root Root to populate\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n */\n\nfunction parse(source, root, options) {\n  /* eslint-disable callback-return */\n  if (!(root instanceof Root)) {\n    options = root;\n    root = new Root();\n  }\n\n  if (!options) options = parse.defaults;\n  var tn = tokenize(source, options.alternateCommentMode || false),\n      next = tn.next,\n      push = tn.push,\n      peek = tn.peek,\n      skip = tn.skip,\n      cmnt = tn.cmnt;\n  var head = true,\n      pkg,\n      imports,\n      weakImports,\n      syntax,\n      isProto3 = false;\n  var ptr = root;\n  var applyCase = options.keepCase ? function (name) {\n    return name;\n  } : util.camelCase;\n  /* istanbul ignore next */\n\n  function illegal(token, name, insideTryCatch) {\n    var filename = parse.filename;\n    if (!insideTryCatch) parse.filename = null;\n    return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n  }\n\n  function readString() {\n    var values = [],\n        token;\n\n    do {\n      /* istanbul ignore if */\n      if ((token = next()) !== \"\\\"\" && token !== \"'\") throw illegal(token);\n      values.push(next());\n      skip(token);\n      token = peek();\n    } while (token === \"\\\"\" || token === \"'\");\n\n    return values.join(\"\");\n  }\n\n  function readValue(acceptTypeRef) {\n    var token = next();\n\n    switch (token) {\n      case \"'\":\n      case \"\\\"\":\n        push(token);\n        return readString();\n\n      case \"true\":\n      case \"TRUE\":\n        return true;\n\n      case \"false\":\n      case \"FALSE\":\n        return false;\n    }\n\n    try {\n      return parseNumber(token,\n      /* insideTryCatch */\n      true);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (acceptTypeRef && typeRefRe.test(token)) return token;\n      /* istanbul ignore next */\n\n      throw illegal(token, \"value\");\n    }\n  }\n\n  function readRanges(target, acceptStrings) {\n    var token, start;\n\n    do {\n      if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\")) target.push(readString());else target.push([start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start]);\n    } while (skip(\",\", true));\n\n    skip(\";\");\n  }\n\n  function parseNumber(token, insideTryCatch) {\n    var sign = 1;\n\n    if (token.charAt(0) === \"-\") {\n      sign = -1;\n      token = token.substring(1);\n    }\n\n    switch (token) {\n      case \"inf\":\n      case \"INF\":\n      case \"Inf\":\n        return sign * Infinity;\n\n      case \"nan\":\n      case \"NAN\":\n      case \"Nan\":\n      case \"NaN\":\n        return NaN;\n\n      case \"0\":\n        return 0;\n    }\n\n    if (base10Re.test(token)) return sign * parseInt(token, 10);\n    if (base16Re.test(token)) return sign * parseInt(token, 16);\n    if (base8Re.test(token)) return sign * parseInt(token, 8);\n    /* istanbul ignore else */\n\n    if (numberRe.test(token)) return sign * parseFloat(token);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"number\", insideTryCatch);\n  }\n\n  function parseId(token, acceptNegative) {\n    switch (token) {\n      case \"max\":\n      case \"MAX\":\n      case \"Max\":\n        return 536870911;\n\n      case \"0\":\n        return 0;\n    }\n    /* istanbul ignore if */\n\n\n    if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n    if (base10NegRe.test(token)) return parseInt(token, 10);\n    if (base16NegRe.test(token)) return parseInt(token, 16);\n    /* istanbul ignore else */\n\n    if (base8NegRe.test(token)) return parseInt(token, 8);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"id\");\n  }\n\n  function parsePackage() {\n    /* istanbul ignore if */\n    if (pkg !== undefined) throw illegal(\"package\");\n    pkg = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n    ptr = ptr.define(pkg);\n    skip(\";\");\n  }\n\n  function parseImport() {\n    var token = peek();\n    var whichImports;\n\n    switch (token) {\n      case \"weak\":\n        whichImports = weakImports || (weakImports = []);\n        next();\n        break;\n\n      case \"public\":\n        next();\n      // eslint-disable-line no-fallthrough\n\n      default:\n        whichImports = imports || (imports = []);\n        break;\n    }\n\n    token = readString();\n    skip(\";\");\n    whichImports.push(token);\n  }\n\n  function parseSyntax() {\n    skip(\"=\");\n    syntax = readString();\n    isProto3 = syntax === \"proto3\";\n    /* istanbul ignore if */\n\n    if (!isProto3 && syntax !== \"proto2\") throw illegal(syntax, \"syntax\");\n    skip(\";\");\n  }\n\n  function parseCommon(parent, token) {\n    switch (token) {\n      case \"option\":\n        parseOption(parent, token);\n        skip(\";\");\n        return true;\n\n      case \"message\":\n        parseType(parent, token);\n        return true;\n\n      case \"enum\":\n        parseEnum(parent, token);\n        return true;\n\n      case \"service\":\n        parseService(parent, token);\n        return true;\n\n      case \"extend\":\n        parseExtension(parent, token);\n        return true;\n    }\n\n    return false;\n  }\n\n  function ifBlock(obj, fnIf, fnElse) {\n    var trailingLine = tn.line;\n\n    if (obj) {\n      obj.comment = cmnt(); // try block-type comment\n\n      obj.filename = parse.filename;\n    }\n\n    if (skip(\"{\", true)) {\n      var token;\n\n      while ((token = next()) !== \"}\") fnIf(token);\n\n      skip(\";\", true);\n    } else {\n      if (fnElse) fnElse();\n      skip(\";\");\n      if (obj && typeof obj.comment !== \"string\") obj.comment = cmnt(trailingLine); // try line-type comment if no block\n    }\n  }\n\n  function parseType(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n    var type = new Type(token);\n    ifBlock(type, function parseType_block(token) {\n      if (parseCommon(type, token)) return;\n\n      switch (token) {\n        case \"map\":\n          parseMapField(type, token);\n          break;\n\n        case \"required\":\n        case \"optional\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        case \"oneof\":\n          parseOneOf(type, token);\n          break;\n\n        case \"extensions\":\n          readRanges(type.extensions || (type.extensions = []));\n          break;\n\n        case \"reserved\":\n          readRanges(type.reserved || (type.reserved = []), true);\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(type, \"optional\");\n          break;\n      }\n    });\n    parent.add(type);\n  }\n\n  function parseField(parent, rule, extend) {\n    var type = next();\n\n    if (type === \"group\") {\n      parseGroup(parent, rule);\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    name = applyCase(name);\n    skip(\"=\");\n    var field = new Field(name, parseId(next()), type, rule, extend);\n    ifBlock(field, function parseField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field); // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n    // parsing proto2 descriptors without the option, where applicable. This must be done for\n    // all known packable types and anything that could be an enum (= is not a basic type).\n\n    if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption(\"packed\", false,\n    /* ifNotSet */\n    true);\n  }\n\n  function parseGroup(parent, rule) {\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    var fieldName = util.lcFirst(name);\n    if (name === fieldName) name = util.ucFirst(name);\n    skip(\"=\");\n    var id = parseId(next());\n    var type = new Type(name);\n    type.group = true;\n    var field = new Field(fieldName, id, name, rule);\n    field.filename = parse.filename;\n    ifBlock(type, function parseGroup_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(type, token);\n          skip(\";\");\n          break;\n\n        case \"required\":\n        case \"optional\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw illegal(token);\n        // there are no groups with proto3 semantics\n      }\n    });\n    parent.add(type).add(field);\n  }\n\n  function parseMapField(parent) {\n    skip(\"<\");\n    var keyType = next();\n    /* istanbul ignore if */\n\n    if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n    skip(\",\");\n    var valueType = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n    skip(\">\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    skip(\"=\");\n    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n    ifBlock(field, function parseMapField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseMapField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field);\n  }\n\n  function parseOneOf(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var oneof = new OneOf(applyCase(token));\n    ifBlock(oneof, function parseOneOf_block(token) {\n      if (token === \"option\") {\n        parseOption(oneof, token);\n        skip(\";\");\n      } else {\n        push(token);\n        parseField(oneof, \"optional\");\n      }\n    });\n    parent.add(oneof);\n  }\n\n  function parseEnum(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var enm = new Enum(token);\n    ifBlock(enm, function parseEnum_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(enm, token);\n          skip(\";\");\n          break;\n\n        case \"reserved\":\n          readRanges(enm.reserved || (enm.reserved = []), true);\n          break;\n\n        default:\n          parseEnumValue(enm, token);\n      }\n    });\n    parent.add(enm);\n  }\n\n  function parseEnumValue(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token)) throw illegal(token, \"name\");\n    skip(\"=\");\n    var value = parseId(next(), true),\n        dummy = {};\n    ifBlock(dummy, function parseEnumValue_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(dummy, token); // skip\n\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseEnumValue_line() {\n      parseInlineOptions(dummy); // skip\n    });\n    parent.add(token, value, dummy.comment);\n  }\n\n  function parseOption(parent, token) {\n    var isCustom = skip(\"(\", true);\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token;\n\n    if (isCustom) {\n      skip(\")\");\n      name = \"(\" + name + \")\";\n      token = peek();\n\n      if (fqTypeRefRe.test(token)) {\n        name += token;\n        next();\n      }\n    }\n\n    skip(\"=\");\n    parseOptionValue(parent, name);\n  }\n\n  function parseOptionValue(parent, name) {\n    if (skip(\"{\", true)) {\n      // { a: \"foo\" b { c: \"bar\" } }\n      do {\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        if (peek() === \"{\") parseOptionValue(parent, name + \".\" + token);else {\n          skip(\":\");\n          if (peek() === \"{\") parseOptionValue(parent, name + \".\" + token);else setOption(parent, name + \".\" + token, readValue(true));\n        }\n        skip(\",\", true);\n      } while (!skip(\"}\", true));\n    } else setOption(parent, name, readValue(true)); // Does not enforce a delimiter to be universal\n\n  }\n\n  function setOption(parent, name, value) {\n    if (parent.setOption) parent.setOption(name, value);\n  }\n\n  function parseInlineOptions(parent) {\n    if (skip(\"[\", true)) {\n      do {\n        parseOption(parent, \"option\");\n      } while (skip(\",\", true));\n\n      skip(\"]\");\n    }\n\n    return parent;\n  }\n\n  function parseService(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n    var service = new Service(token);\n    ifBlock(service, function parseService_block(token) {\n      if (parseCommon(service, token)) return;\n      /* istanbul ignore else */\n\n      if (token === \"rpc\") parseMethod(service, token);else throw illegal(token);\n    });\n    parent.add(service);\n  }\n\n  function parseMethod(parent, token) {\n    var type = token;\n    /* istanbul ignore if */\n\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token,\n        requestType,\n        requestStream,\n        responseType,\n        responseStream;\n    skip(\"(\");\n    if (skip(\"stream\", true)) requestStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    requestType = token;\n    skip(\")\");\n    skip(\"returns\");\n    skip(\"(\");\n    if (skip(\"stream\", true)) responseStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    responseType = token;\n    skip(\")\");\n    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n    ifBlock(method, function parseMethod_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(method, token);\n        skip(\";\");\n      } else throw illegal(token);\n    });\n    parent.add(method);\n  }\n\n  function parseExtension(parent, token) {\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n    var reference = token;\n    ifBlock(null, function parseExtension_block(token) {\n      switch (token) {\n        case \"required\":\n        case \"repeated\":\n        case \"optional\":\n          parseField(parent, token, reference);\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(parent, \"optional\", reference);\n          break;\n      }\n    });\n  }\n\n  var token;\n\n  while ((token = next()) !== null) {\n    switch (token) {\n      case \"package\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parsePackage();\n        break;\n\n      case \"import\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseImport();\n        break;\n\n      case \"syntax\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseSyntax();\n        break;\n\n      case \"option\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseOption(ptr, token);\n        skip(\";\");\n        break;\n\n      default:\n        /* istanbul ignore else */\n        if (parseCommon(ptr, token)) {\n          head = false;\n          continue;\n        }\n        /* istanbul ignore next */\n\n\n        throw illegal(token);\n    }\n  }\n\n  parse.filename = null;\n  return {\n    \"package\": pkg,\n    \"imports\": imports,\n    weakImports: weakImports,\n    syntax: syntax,\n    root: root\n  };\n}\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @name parse\r\n * @function\r\n * @param {string} source Source contents\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n * @variation 2\r\n */","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/protobufjs/src/parse.js"],"names":["module","exports","parse","filename","defaults","keepCase","tokenize","require","Root","Type","Field","MapField","OneOf","Enum","Service","Method","types","util","base10Re","base10NegRe","base16Re","base16NegRe","base8Re","base8NegRe","numberRe","nameRe","typeRefRe","fqTypeRefRe","source","root","options","tn","alternateCommentMode","next","push","peek","skip","cmnt","head","pkg","imports","weakImports","syntax","isProto3","ptr","applyCase","name","camelCase","illegal","token","insideTryCatch","Error","line","readString","values","join","readValue","acceptTypeRef","parseNumber","e","test","readRanges","target","acceptStrings","start","parseId","sign","charAt","substring","Infinity","NaN","parseInt","parseFloat","acceptNegative","parsePackage","undefined","define","parseImport","whichImports","parseSyntax","parseCommon","parent","parseOption","parseType","parseEnum","parseService","parseExtension","ifBlock","obj","fnIf","fnElse","trailingLine","comment","type","parseType_block","parseMapField","parseField","parseOneOf","extensions","reserved","add","rule","extend","parseGroup","field","parseField_block","parseField_line","parseInlineOptions","repeated","packed","basic","setOption","fieldName","lcFirst","ucFirst","id","group","parseGroup_block","keyType","mapKey","valueType","parseMapField_block","parseMapField_line","oneof","parseOneOf_block","enm","parseEnum_block","parseEnumValue","value","dummy","parseEnumValue_block","parseEnumValue_line","isCustom","parseOptionValue","service","parseService_block","parseMethod","requestType","requestStream","responseType","responseStream","method","parseMethod_block","reference","parseExtension_block"],"mappings":"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","sourcesContent":["\"use strict\";\r\nmodule.exports = parse;\r\n\r\nparse.filename = null;\r\nparse.defaults = { keepCase: false };\r\n\r\nvar tokenize  = require(\"./tokenize\"),\r\n    Root      = require(\"./root\"),\r\n    Type      = require(\"./type\"),\r\n    Field     = require(\"./field\"),\r\n    MapField  = require(\"./mapfield\"),\r\n    OneOf     = require(\"./oneof\"),\r\n    Enum      = require(\"./enum\"),\r\n    Service   = require(\"./service\"),\r\n    Method    = require(\"./method\"),\r\n    types     = require(\"./types\"),\r\n    util      = require(\"./util\");\r\n\r\nvar base10Re    = /^[1-9][0-9]*$/,\r\n    base10NegRe = /^-?[1-9][0-9]*$/,\r\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\r\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\r\n    base8Re     = /^0[0-7]+$/,\r\n    base8NegRe  = /^-?0[0-7]+$/,\r\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\r\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\r\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\r\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\r\n\r\n/**\r\n * Result object returned from {@link parse}.\r\n * @interface IParserResult\r\n * @property {string|undefined} package Package name, if declared\r\n * @property {string[]|undefined} imports Imports, if any\r\n * @property {string[]|undefined} weakImports Weak imports, if any\r\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\r\n * @property {Root} root Populated root instance\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of {@link parse}.\r\n * @interface IParseOptions\r\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\r\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of JSON serialization.\r\n * @interface IToJSONOptions\r\n * @property {boolean} [keepComments=false] Serializes comments.\r\n */\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @param {string} source Source contents\r\n * @param {Root} root Root to populate\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n */\r\nfunction parse(source, root, options) {\r\n    /* eslint-disable callback-return */\r\n    if (!(root instanceof Root)) {\r\n        options = root;\r\n        root = new Root();\r\n    }\r\n    if (!options)\r\n        options = parse.defaults;\r\n\r\n    var tn = tokenize(source, options.alternateCommentMode || false),\r\n        next = tn.next,\r\n        push = tn.push,\r\n        peek = tn.peek,\r\n        skip = tn.skip,\r\n        cmnt = tn.cmnt;\r\n\r\n    var head = true,\r\n        pkg,\r\n        imports,\r\n        weakImports,\r\n        syntax,\r\n        isProto3 = false;\r\n\r\n    var ptr = root;\r\n\r\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\r\n\r\n    /* istanbul ignore next */\r\n    function illegal(token, name, insideTryCatch) {\r\n        var filename = parse.filename;\r\n        if (!insideTryCatch)\r\n            parse.filename = null;\r\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\r\n    }\r\n\r\n    function readString() {\r\n        var values = [],\r\n            token;\r\n        do {\r\n            /* istanbul ignore if */\r\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\r\n                throw illegal(token);\r\n\r\n            values.push(next());\r\n            skip(token);\r\n            token = peek();\r\n        } while (token === \"\\\"\" || token === \"'\");\r\n        return values.join(\"\");\r\n    }\r\n\r\n    function readValue(acceptTypeRef) {\r\n        var token = next();\r\n        switch (token) {\r\n            case \"'\":\r\n            case \"\\\"\":\r\n                push(token);\r\n                return readString();\r\n            case \"true\": case \"TRUE\":\r\n                return true;\r\n            case \"false\": case \"FALSE\":\r\n                return false;\r\n        }\r\n        try {\r\n            return parseNumber(token, /* insideTryCatch */ true);\r\n        } catch (e) {\r\n\r\n            /* istanbul ignore else */\r\n            if (acceptTypeRef && typeRefRe.test(token))\r\n                return token;\r\n\r\n            /* istanbul ignore next */\r\n            throw illegal(token, \"value\");\r\n        }\r\n    }\r\n\r\n    function readRanges(target, acceptStrings) {\r\n        var token, start;\r\n        do {\r\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\r\n                target.push(readString());\r\n            else\r\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\r\n        } while (skip(\",\", true));\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseNumber(token, insideTryCatch) {\r\n        var sign = 1;\r\n        if (token.charAt(0) === \"-\") {\r\n            sign = -1;\r\n            token = token.substring(1);\r\n        }\r\n        switch (token) {\r\n            case \"inf\": case \"INF\": case \"Inf\":\r\n                return sign * Infinity;\r\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\r\n                return NaN;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n        if (base10Re.test(token))\r\n            return sign * parseInt(token, 10);\r\n        if (base16Re.test(token))\r\n            return sign * parseInt(token, 16);\r\n        if (base8Re.test(token))\r\n            return sign * parseInt(token, 8);\r\n\r\n        /* istanbul ignore else */\r\n        if (numberRe.test(token))\r\n            return sign * parseFloat(token);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"number\", insideTryCatch);\r\n    }\r\n\r\n    function parseId(token, acceptNegative) {\r\n        switch (token) {\r\n            case \"max\": case \"MAX\": case \"Max\":\r\n                return 536870911;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!acceptNegative && token.charAt(0) === \"-\")\r\n            throw illegal(token, \"id\");\r\n\r\n        if (base10NegRe.test(token))\r\n            return parseInt(token, 10);\r\n        if (base16NegRe.test(token))\r\n            return parseInt(token, 16);\r\n\r\n        /* istanbul ignore else */\r\n        if (base8NegRe.test(token))\r\n            return parseInt(token, 8);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"id\");\r\n    }\r\n\r\n    function parsePackage() {\r\n\r\n        /* istanbul ignore if */\r\n        if (pkg !== undefined)\r\n            throw illegal(\"package\");\r\n\r\n        pkg = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(pkg))\r\n            throw illegal(pkg, \"name\");\r\n\r\n        ptr = ptr.define(pkg);\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseImport() {\r\n        var token = peek();\r\n        var whichImports;\r\n        switch (token) {\r\n            case \"weak\":\r\n                whichImports = weakImports || (weakImports = []);\r\n                next();\r\n                break;\r\n            case \"public\":\r\n                next();\r\n                // eslint-disable-line no-fallthrough\r\n            default:\r\n                whichImports = imports || (imports = []);\r\n                break;\r\n        }\r\n        token = readString();\r\n        skip(\";\");\r\n        whichImports.push(token);\r\n    }\r\n\r\n    function parseSyntax() {\r\n        skip(\"=\");\r\n        syntax = readString();\r\n        isProto3 = syntax === \"proto3\";\r\n\r\n        /* istanbul ignore if */\r\n        if (!isProto3 && syntax !== \"proto2\")\r\n            throw illegal(syntax, \"syntax\");\r\n\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseCommon(parent, token) {\r\n        switch (token) {\r\n\r\n            case \"option\":\r\n                parseOption(parent, token);\r\n                skip(\";\");\r\n                return true;\r\n\r\n            case \"message\":\r\n                parseType(parent, token);\r\n                return true;\r\n\r\n            case \"enum\":\r\n                parseEnum(parent, token);\r\n                return true;\r\n\r\n            case \"service\":\r\n                parseService(parent, token);\r\n                return true;\r\n\r\n            case \"extend\":\r\n                parseExtension(parent, token);\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function ifBlock(obj, fnIf, fnElse) {\r\n        var trailingLine = tn.line;\r\n        if (obj) {\r\n            obj.comment = cmnt(); // try block-type comment\r\n            obj.filename = parse.filename;\r\n        }\r\n        if (skip(\"{\", true)) {\r\n            var token;\r\n            while ((token = next()) !== \"}\")\r\n                fnIf(token);\r\n            skip(\";\", true);\r\n        } else {\r\n            if (fnElse)\r\n                fnElse();\r\n            skip(\";\");\r\n            if (obj && typeof obj.comment !== \"string\")\r\n                obj.comment = cmnt(trailingLine); // try line-type comment if no block\r\n        }\r\n    }\r\n\r\n    function parseType(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"type name\");\r\n\r\n        var type = new Type(token);\r\n        ifBlock(type, function parseType_block(token) {\r\n            if (parseCommon(type, token))\r\n                return;\r\n\r\n            switch (token) {\r\n\r\n                case \"map\":\r\n                    parseMapField(type, token);\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"optional\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                case \"oneof\":\r\n                    parseOneOf(type, token);\r\n                    break;\r\n\r\n                case \"extensions\":\r\n                    readRanges(type.extensions || (type.extensions = []));\r\n                    break;\r\n\r\n                case \"reserved\":\r\n                    readRanges(type.reserved || (type.reserved = []), true);\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n\r\n                    push(token);\r\n                    parseField(type, \"optional\");\r\n                    break;\r\n            }\r\n        });\r\n        parent.add(type);\r\n    }\r\n\r\n    function parseField(parent, rule, extend) {\r\n        var type = next();\r\n        if (type === \"group\") {\r\n            parseGroup(parent, rule);\r\n            return;\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(type))\r\n            throw illegal(type, \"type\");\r\n\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        name = applyCase(name);\r\n        skip(\"=\");\r\n\r\n        var field = new Field(name, parseId(next()), type, rule, extend);\r\n        ifBlock(field, function parseField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n        parent.add(field);\r\n\r\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\r\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\r\n        // all known packable types and anything that could be an enum (= is not a basic type).\r\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\r\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\r\n    }\r\n\r\n    function parseGroup(parent, rule) {\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        var fieldName = util.lcFirst(name);\r\n        if (name === fieldName)\r\n            name = util.ucFirst(name);\r\n        skip(\"=\");\r\n        var id = parseId(next());\r\n        var type = new Type(name);\r\n        type.group = true;\r\n        var field = new Field(fieldName, id, name, rule);\r\n        field.filename = parse.filename;\r\n        ifBlock(type, function parseGroup_block(token) {\r\n            switch (token) {\r\n\r\n                case \"option\":\r\n                    parseOption(type, token);\r\n                    skip(\";\");\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"optional\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw illegal(token); // there are no groups with proto3 semantics\r\n            }\r\n        });\r\n        parent.add(type)\r\n              .add(field);\r\n    }\r\n\r\n    function parseMapField(parent) {\r\n        skip(\"<\");\r\n        var keyType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (types.mapKey[keyType] === undefined)\r\n            throw illegal(keyType, \"type\");\r\n\r\n        skip(\",\");\r\n        var valueType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(valueType))\r\n            throw illegal(valueType, \"type\");\r\n\r\n        skip(\">\");\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        skip(\"=\");\r\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\r\n        ifBlock(field, function parseMapField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseMapField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n        parent.add(field);\r\n    }\r\n\r\n    function parseOneOf(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var oneof = new OneOf(applyCase(token));\r\n        ifBlock(oneof, function parseOneOf_block(token) {\r\n            if (token === \"option\") {\r\n                parseOption(oneof, token);\r\n                skip(\";\");\r\n            } else {\r\n                push(token);\r\n                parseField(oneof, \"optional\");\r\n            }\r\n        });\r\n        parent.add(oneof);\r\n    }\r\n\r\n    function parseEnum(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var enm = new Enum(token);\r\n        ifBlock(enm, function parseEnum_block(token) {\r\n          switch(token) {\r\n            case \"option\":\r\n              parseOption(enm, token);\r\n              skip(\";\");\r\n              break;\r\n\r\n            case \"reserved\":\r\n              readRanges(enm.reserved || (enm.reserved = []), true);\r\n              break;\r\n\r\n            default:\r\n              parseEnumValue(enm, token);\r\n          }\r\n        });\r\n        parent.add(enm);\r\n    }\r\n\r\n    function parseEnumValue(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token))\r\n            throw illegal(token, \"name\");\r\n\r\n        skip(\"=\");\r\n        var value = parseId(next(), true),\r\n            dummy = {};\r\n        ifBlock(dummy, function parseEnumValue_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(dummy, token); // skip\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseEnumValue_line() {\r\n            parseInlineOptions(dummy); // skip\r\n        });\r\n        parent.add(token, value, dummy.comment);\r\n    }\r\n\r\n    function parseOption(parent, token) {\r\n        var isCustom = skip(\"(\", true);\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token;\r\n        if (isCustom) {\r\n            skip(\")\");\r\n            name = \"(\" + name + \")\";\r\n            token = peek();\r\n            if (fqTypeRefRe.test(token)) {\r\n                name += token;\r\n                next();\r\n            }\r\n        }\r\n        skip(\"=\");\r\n        parseOptionValue(parent, name);\r\n    }\r\n\r\n    function parseOptionValue(parent, name) {\r\n        if (skip(\"{\", true)) { // { a: \"foo\" b { c: \"bar\" } }\r\n            do {\r\n                /* istanbul ignore if */\r\n                if (!nameRe.test(token = next()))\r\n                    throw illegal(token, \"name\");\r\n\r\n                if (peek() === \"{\")\r\n                    parseOptionValue(parent, name + \".\" + token);\r\n                else {\r\n                    skip(\":\");\r\n                    if (peek() === \"{\")\r\n                        parseOptionValue(parent, name + \".\" + token);\r\n                    else\r\n                        setOption(parent, name + \".\" + token, readValue(true));\r\n                }\r\n                skip(\",\", true);\r\n            } while (!skip(\"}\", true));\r\n        } else\r\n            setOption(parent, name, readValue(true));\r\n        // Does not enforce a delimiter to be universal\r\n    }\r\n\r\n    function setOption(parent, name, value) {\r\n        if (parent.setOption)\r\n            parent.setOption(name, value);\r\n    }\r\n\r\n    function parseInlineOptions(parent) {\r\n        if (skip(\"[\", true)) {\r\n            do {\r\n                parseOption(parent, \"option\");\r\n            } while (skip(\",\", true));\r\n            skip(\"]\");\r\n        }\r\n        return parent;\r\n    }\r\n\r\n    function parseService(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"service name\");\r\n\r\n        var service = new Service(token);\r\n        ifBlock(service, function parseService_block(token) {\r\n            if (parseCommon(service, token))\r\n                return;\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"rpc\")\r\n                parseMethod(service, token);\r\n            else\r\n                throw illegal(token);\r\n        });\r\n        parent.add(service);\r\n    }\r\n\r\n    function parseMethod(parent, token) {\r\n        var type = token;\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token,\r\n            requestType, requestStream,\r\n            responseType, responseStream;\r\n\r\n        skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            requestStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        requestType = token;\r\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            responseStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        responseType = token;\r\n        skip(\")\");\r\n\r\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\r\n        ifBlock(method, function parseMethod_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(method, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        });\r\n        parent.add(method);\r\n    }\r\n\r\n    function parseExtension(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"reference\");\r\n\r\n        var reference = token;\r\n        ifBlock(null, function parseExtension_block(token) {\r\n            switch (token) {\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                case \"optional\":\r\n                    parseField(parent, token, reference);\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n                    push(token);\r\n                    parseField(parent, \"optional\", reference);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    var token;\r\n    while ((token = next()) !== null) {\r\n        switch (token) {\r\n\r\n            case \"package\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parsePackage();\r\n                break;\r\n\r\n            case \"import\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseImport();\r\n                break;\r\n\r\n            case \"syntax\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseSyntax();\r\n                break;\r\n\r\n            case \"option\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseOption(ptr, token);\r\n                skip(\";\");\r\n                break;\r\n\r\n            default:\r\n\r\n                /* istanbul ignore else */\r\n                if (parseCommon(ptr, token)) {\r\n                    head = false;\r\n                    continue;\r\n                }\r\n\r\n                /* istanbul ignore next */\r\n                throw illegal(token);\r\n        }\r\n    }\r\n\r\n    parse.filename = null;\r\n    return {\r\n        \"package\"     : pkg,\r\n        \"imports\"     : imports,\r\n         weakImports  : weakImports,\r\n         syntax       : syntax,\r\n         root         : root\r\n    };\r\n}\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @name parse\r\n * @function\r\n * @param {string} source Source contents\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n * @variation 2\r\n */\r\n"]},"metadata":{},"sourceType":"script"}