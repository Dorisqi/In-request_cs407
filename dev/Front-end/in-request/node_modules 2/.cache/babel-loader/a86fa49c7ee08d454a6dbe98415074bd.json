{"ast":null,"code":"/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nmodule.exports = (() => {\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = 'SyntaxError';\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    const options = arguments.length > 1 ? arguments[1] : {};\n    const parser = this;\n    const peg$FAILED = {};\n    const peg$startRuleFunctions = {\n      template: peg$parsetemplate\n    };\n    let peg$startRuleFunction = peg$parsetemplate;\n    const peg$c0 = '/';\n    const peg$c1 = {\n      type: 'literal',\n      value: '/',\n      description: '\"/\"'\n    };\n\n    const peg$c2 = segments => {\n      return segments;\n    };\n\n    const peg$c3 = (s, segments) => {\n      return s.concat(segments);\n    };\n\n    const peg$c4 = s => {\n      return s;\n    };\n\n    const peg$c5 = '{';\n    const peg$c6 = {\n      type: 'literal',\n      value: '{',\n      description: '\"{\"'\n    };\n    const peg$c7 = '=';\n    const peg$c8 = {\n      type: 'literal',\n      value: '=',\n      description: '\"=\"'\n    };\n    const peg$c9 = '}';\n    const peg$c10 = {\n      type: 'literal',\n      value: '}',\n      description: '\"}\"'\n    };\n\n    const peg$c11 = (l, segments) => {\n      return [{\n        kind: extras.BINDING,\n        literal: l\n      }, segments, {\n        kind: extras.END_BINDING,\n        literal: ''\n      }].reduce((a, b) => a.concat(b), []);\n    };\n\n    const peg$c12 = l => {\n      return [{\n        kind: extras.BINDING,\n        literal: l\n      }, {\n        kind: extras.TERMINAL,\n        literal: '*'\n      }, {\n        kind: extras.END_BINDING,\n        literal: ''\n      }];\n    };\n\n    const peg$c13 = (t, segments) => {\n      return t.concat(segments);\n    };\n\n    const peg$c14 = t => {\n      if (t[0].literal === '*' || t[0].literal === '**') {\n        return [{\n          kind: extras.BINDING\n        }, t[0], {\n          kind: extras.END_BINDING,\n          literal: ''\n        }];\n      } else {\n        return t;\n      }\n    };\n\n    const peg$c15 = '**';\n    const peg$c16 = {\n      type: 'literal',\n      value: '**',\n      description: '\"**\"'\n    };\n    const peg$c17 = '*';\n    const peg$c18 = {\n      type: 'literal',\n      value: '*',\n      description: '\"*\"'\n    };\n\n    const peg$c19 = l => {\n      return [{\n        kind: extras.TERMINAL,\n        literal: l\n      }];\n    };\n\n    const peg$c20 = /^[^*=}{\\/]/;\n    const peg$c21 = {\n      type: 'class',\n      value: '[^*=}{/]',\n      description: '[^*=}{/]'\n    };\n\n    const peg$c22 = cs => {\n      return cs.join('');\n    };\n\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [{\n      line: 1,\n      column: 1,\n      seenCR: false\n    }];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    const peg$silentFails = 0;\n    let peg$result;\n\n    if ('startRule' in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(null, [{\n        type: 'other',\n        description\n      }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function peg$computePosDetails(pos) {\n      let details = peg$posDetailsCache[pos],\n          p,\n          ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n\n          if (ch === '\\n') {\n            if (!details.seenCR) {\n              details.line++;\n            }\n\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === '\\r' || ch === '\\u2028' || ch === '\\u2029') {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      const startPosDetails = peg$computePosDetails(startPos),\n            endPosDetails = peg$computePosDetails(endPos);\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        let i = 1;\n        expected.sort((a, b) => {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n          }\n\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, ch => {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, ch => {\n            return '\\\\x' + hex(ch);\n          }).replace(/[\\u0100-\\u0FFF]/g, ch => {\n            return '\\\\u0' + hex(ch);\n          }).replace(/[\\u1000-\\uFFFF]/g, ch => {\n            return '\\\\u' + hex(ch);\n          });\n        }\n\n        const expectedDescs = new Array(expected.length);\n        let expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(', ') + ' or ' + expectedDescs[expected.length - 1] : expectedDescs[0];\n        foundDesc = found ? '\"' + stringEscape(found) + '\"' : 'end of input';\n        return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);\n    }\n\n    function peg$parsetemplate() {\n      let s0, s1, s2;\n      s0 = peg$currPos;\n\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c1);\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebound_segments();\n\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsebound_segments();\n\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s1);\n        }\n\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segments() {\n      let s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsebound_segment();\n\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebound_segments();\n\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebound_segment();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segment() {\n      let s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parsebound_terminal();\n\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsevariable();\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      let s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c6);\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseliteral();\n\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseunbound_segments();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s5 = peg$c9;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c10);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c11(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c6);\n          }\n        }\n\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseliteral();\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c10);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunbound_segments() {\n      let s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunbound_segments();\n\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseunbound_terminal();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_terminal() {\n      let s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c14(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parseunbound_terminal() {\n      let s0, s1;\n      s0 = peg$currPos;\n\n      if (input.substr(peg$currPos, 2) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c16);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c18);\n          }\n        }\n\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliteral();\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c19(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      let s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n\n      if (peg$c20.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c21);\n        }\n      }\n\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c21);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c22(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    const extras = require('./parserExtras');\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({\n          type: 'end',\n          description: 'end of input'\n        });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n})();","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/google-gax/build/src/pathTemplateParser.js"],"names":["module","exports","peg$subclass","child","parent","ctor","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","peg$parse","input","options","arguments","length","parser","peg$FAILED","peg$startRuleFunctions","template","peg$parsetemplate","peg$startRuleFunction","peg$c0","peg$c1","type","value","description","peg$c2","segments","peg$c3","s","concat","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","l","kind","extras","BINDING","literal","END_BINDING","reduce","a","b","peg$c12","TERMINAL","peg$c13","t","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","cs","join","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","seenCR","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","text","substring","peg$computeLocation","peg$buildException","error","peg$computePosDetails","pos","details","p","ch","charAt","startPos","endPos","startPosDetails","endPosDetails","start","offset","end","peg$fail","push","cleanupExpected","i","sort","splice","buildMessage","stringEscape","hex","charCodeAt","toString","toUpperCase","replace","expectedDescs","Array","expectedDesc","foundDesc","slice","s0","s1","s2","peg$parsebound_segments","s3","peg$parsebound_segment","peg$parsebound_terminal","peg$parsevariable","s4","s5","peg$parseliteral","peg$parseunbound_segments","peg$parseunbound_terminal","substr","test","require","SyntaxError","parse"],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nmodule.exports = (() => {\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = 'SyntaxError';\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    const options = arguments.length > 1 ? arguments[1] : {};\n    const parser = this;\n    const peg$FAILED = {};\n    const peg$startRuleFunctions = {template: peg$parsetemplate};\n    let peg$startRuleFunction = peg$parsetemplate;\n    const peg$c0 = '/';\n    const peg$c1 = {type: 'literal', value: '/', description: '\"/\"'};\n    const peg$c2 = segments => {\n      return segments;\n    };\n    const peg$c3 = (s, segments) => {\n      return s.concat(segments);\n    };\n    const peg$c4 = s => {\n      return s;\n    };\n    const peg$c5 = '{';\n    const peg$c6 = {type: 'literal', value: '{', description: '\"{\"'};\n    const peg$c7 = '=';\n    const peg$c8 = {type: 'literal', value: '=', description: '\"=\"'};\n    const peg$c9 = '}';\n    const peg$c10 = {type: 'literal', value: '}', description: '\"}\"'};\n    const peg$c11 = (l, segments) => {\n      return [\n        {kind: extras.BINDING, literal: l},\n        segments,\n        {kind: extras.END_BINDING, literal: ''},\n      ].reduce((a, b) => a.concat(b), []);\n    };\n    const peg$c12 = l => {\n      return [\n        {kind: extras.BINDING, literal: l},\n        {kind: extras.TERMINAL, literal: '*'},\n        {kind: extras.END_BINDING, literal: ''},\n      ];\n    };\n    const peg$c13 = (t, segments) => {\n      return t.concat(segments);\n    };\n    const peg$c14 = t => {\n      if (t[0].literal === '*' || t[0].literal === '**') {\n        return [\n          {\n            kind: extras.BINDING,\n          },\n          t[0],\n          {kind: extras.END_BINDING, literal: ''},\n        ];\n      } else {\n        return t;\n      }\n    };\n    const peg$c15 = '**';\n    const peg$c16 = {type: 'literal', value: '**', description: '\"**\"'};\n    const peg$c17 = '*';\n    const peg$c18 = {type: 'literal', value: '*', description: '\"*\"'};\n    const peg$c19 = l => {\n      return [{kind: extras.TERMINAL, literal: l}];\n    };\n    const peg$c20 = /^[^*=}{\\/]/;\n    const peg$c21 = {type: 'class', value: '[^*=}{/]', description: '[^*=}{/]'};\n    const peg$c22 = cs => {\n      return cs.join('');\n    };\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [{line: 1, column: 1, seenCR: false}];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    const peg$silentFails = 0;\n    let peg$result;\n\n    if ('startRule' in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\n          'Can\\'t start parsing from rule \"' + options.startRule + '\".'\n        );\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{type: 'other', description}],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      let details = peg$posDetailsCache[pos],\n        p,\n        ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column,\n          seenCR: details.seenCR,\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === '\\n') {\n            if (!details.seenCR) {\n              details.line++;\n            }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === '\\r' || ch === '\\u2028' || ch === '\\u2029') {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      const startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column,\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column,\n        },\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        let i = 1;\n\n        expected.sort((a, b) => {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) {\n            return ch\n              .charCodeAt(0)\n              .toString(16)\n              .toUpperCase();\n          }\n\n          return s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\"/g, '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\f/g, '\\\\f')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, ch => {\n              return '\\\\x0' + hex(ch);\n            })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g, ch => {\n              return '\\\\x' + hex(ch);\n            })\n            .replace(/[\\u0100-\\u0FFF]/g, ch => {\n              return '\\\\u0' + hex(ch);\n            })\n            .replace(/[\\u1000-\\uFFFF]/g, ch => {\n              return '\\\\u' + hex(ch);\n            });\n        }\n\n        const expectedDescs = new Array(expected.length);\n        let expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc =\n          expected.length > 1\n            ? expectedDescs.slice(0, -1).join(', ') +\n              ' or ' +\n              expectedDescs[expected.length - 1]\n            : expectedDescs[0];\n\n        foundDesc = found ? '\"' + stringEscape(found) + '\"' : 'end of input';\n\n        return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsetemplate() {\n      let s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c1);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebound_segments();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsebound_segments();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segments() {\n      let s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsebound_segment();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebound_segments();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebound_segment();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segment() {\n      let s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsebound_terminal();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsevariable();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      let s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c6);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseliteral();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseunbound_segments();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s5 = peg$c9;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c10);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c11(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c6);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseliteral();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c10);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunbound_segments() {\n      let s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunbound_segments();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseunbound_terminal();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_terminal() {\n      let s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseunbound_terminal() {\n      let s0, s1;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c16);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c18);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliteral();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      let s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c20.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c21);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c21);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    const extras = require('./parserExtras');\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({type: 'end', description: 'end of input'});\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse,\n  };\n})();\n"]},"metadata":{},"sourceType":"script"}