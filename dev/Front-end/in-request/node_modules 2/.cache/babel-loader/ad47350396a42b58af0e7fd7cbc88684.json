{"ast":null,"code":"\"use strict\";\n\nvar util = exports; // used to return a Promise where callback is omitted\n\nutil.asPromise = require(\"@protobufjs/aspromise\"); // converts to / from base64 encoded strings\n\nutil.base64 = require(\"@protobufjs/base64\"); // base class of rpc.Service\n\nutil.EventEmitter = require(\"@protobufjs/eventemitter\"); // float handling accross browsers\n\nutil.float = require(\"@protobufjs/float\"); // requires modules optionally and hides the call from bundlers\n\nutil.inquire = require(\"@protobufjs/inquire\"); // converts to / from utf8 encoded strings\n\nutil.utf8 = require(\"@protobufjs/utf8\"); // provides a node-like buffer pool in the browser\n\nutil.pool = require(\"@protobufjs/pool\"); // utility to work with the low and high bits of a 64 bit value\n\nutil.LongBits = require(\"./longbits\"); // global object reference\n\nutil.global = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\n\nutil.emptyArray = Object.freeze ? Object.freeze([]) :\n/* istanbul ignore next */\n[]; // used on prototypes\n\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\n\nutil.emptyObject = Object.freeze ? Object.freeze({}) :\n/* istanbul ignore next */\n{}; // used on prototypes\n\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\n\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\n\nutil.isInteger = Number.isInteger ||\n/* istanbul ignore next */\nfunction isInteger(value) {\n  return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\n\n\nutil.isString = function isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n};\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\n\n\nutil.isObject = function isObject(value) {\n  return value && typeof value === \"object\";\n};\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\n\n\nutil.isset =\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\nutil.isSet = function isSet(obj, prop) {\n  var value = obj[prop];\n  if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n    return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n  return false;\n};\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\n\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\n\n\nutil.Buffer = function () {\n  try {\n    var Buffer = util.inquire(\"buffer\").Buffer; // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n\n    return Buffer.prototype.utf8Write ? Buffer :\n    /* istanbul ignore next */\n    null;\n  } catch (e) {\n    /* istanbul ignore next */\n    return null;\n  }\n}(); // Internal alias of or polyfull for Buffer.from.\n\n\nutil._Buffer_from = null; // Internal alias of or polyfill for Buffer.allocUnsafe.\n\nutil._Buffer_allocUnsafe = null;\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\n\nutil.newBuffer = function newBuffer(sizeOrArray) {\n  /* istanbul ignore next */\n  return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\n\n\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array\n/* istanbul ignore next */\n: Array;\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\n\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\n\nutil.Long =\n/* istanbul ignore next */\nutil.global.dcodeIO &&\n/* istanbul ignore next */\nutil.global.dcodeIO.Long ||\n/* istanbul ignore next */\nutil.global.Long || util.inquire(\"long\");\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\n\nutil.key2Re = /^true|false|0|1$/;\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\n\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\n\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\n\nutil.longToHash = function longToHash(value) {\n  return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\n\n\nutil.longFromHash = function longFromHash(hash, unsigned) {\n  var bits = util.LongBits.fromHash(hash);\n  if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n  return bits.toNumber(Boolean(unsigned));\n};\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\n\n\nfunction merge(dst, src, ifNotSet) {\n  // used by converters\n  for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n\n  return dst;\n}\n\nutil.merge = merge;\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\n\nutil.lcFirst = function lcFirst(str) {\n  return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\n\n\nfunction newError(name) {\n  function CustomError(message, properties) {\n    if (!(this instanceof CustomError)) return new CustomError(message, properties); // Error.call(this, message);\n    // ^ just returns a new error instance because the ctor can be called as a function\n\n    Object.defineProperty(this, \"message\", {\n      get: function () {\n        return message;\n      }\n    });\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) // node\n      Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, \"stack\", {\n      value: new Error().stack || \"\"\n    });\n    if (properties) merge(this, properties);\n  }\n\n  (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n  Object.defineProperty(CustomError.prototype, \"name\", {\n    get: function () {\n      return name;\n    }\n  });\n\n  CustomError.prototype.toString = function toString() {\n    return this.name + \": \" + this.message;\n  };\n\n  return CustomError;\n}\n\nutil.newError = newError;\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\n\nutil.ProtocolError = newError(\"ProtocolError\");\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\n\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\n\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\n\nutil.oneOfGetter = function getOneOf(fieldNames) {\n  var fieldMap = {};\n\n  for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;\n  /**\r\n   * @returns {string|undefined} Set field name, if any\r\n   * @this Object\r\n   * @ignore\r\n   */\n\n\n  return function () {\n    // eslint-disable-line consistent-return\n    for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n  };\n};\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\n\n\nutil.oneOfSetter = function setOneOf(fieldNames) {\n  /**\r\n   * @param {string} name Field name\r\n   * @returns {undefined}\r\n   * @this Object\r\n   * @ignore\r\n   */\n  return function (name) {\n    for (var i = 0; i < fieldNames.length; ++i) if (fieldNames[i] !== name) delete this[fieldNames[i]];\n  };\n};\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\n\n\nutil.toJSONOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  json: true\n}; // Sets up buffer utility according to the environment (called in index-minimal)\n\nutil._configure = function () {\n  var Buffer = util.Buffer;\n  /* istanbul ignore if */\n\n  if (!Buffer) {\n    util._Buffer_from = util._Buffer_allocUnsafe = null;\n    return;\n  } // because node 4.x buffers are incompatible & immutable\n  // see: https://github.com/dcodeIO/protobuf.js/pull/665\n\n\n  util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n  /* istanbul ignore next */\n  function Buffer_from(value, encoding) {\n    return new Buffer(value, encoding);\n  };\n\n  util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n  /* istanbul ignore next */\n  function Buffer_allocUnsafe(size) {\n    return new Buffer(size);\n  };\n};","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/protobufjs/src/util/minimal.js"],"names":["util","exports","asPromise","require","base64","EventEmitter","float","inquire","utf8","pool","LongBits","global","window","self","emptyArray","Object","freeze","emptyObject","isNode","Boolean","process","versions","node","isInteger","Number","value","isFinite","Math","floor","isString","String","isObject","isset","isSet","obj","prop","hasOwnProperty","Array","isArray","length","keys","Buffer","prototype","utf8Write","e","_Buffer_from","_Buffer_allocUnsafe","newBuffer","sizeOrArray","Uint8Array","Long","dcodeIO","key2Re","key32Re","key64Re","longToHash","from","toHash","zeroHash","longFromHash","hash","unsigned","bits","fromHash","fromBits","lo","hi","toNumber","merge","dst","src","ifNotSet","i","undefined","lcFirst","str","charAt","toLowerCase","substring","newError","name","CustomError","message","properties","defineProperty","get","Error","captureStackTrace","stack","create","constructor","toString","ProtocolError","oneOfGetter","getOneOf","fieldNames","fieldMap","oneOfSetter","setOneOf","toJSONOptions","longs","enums","bytes","json","_configure","Buffer_from","encoding","allocUnsafe","Buffer_allocUnsafe","size"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = require(\"@protobufjs/aspromise\");\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = require(\"@protobufjs/base64\");\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\r\n\r\n// float handling accross browsers\r\nutil.float = require(\"@protobufjs/float\");\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = require(\"@protobufjs/inquire\");\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = require(\"@protobufjs/utf8\");\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = require(\"@protobufjs/pool\");\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = require(\"./longbits\");\r\n\r\n// global object reference\r\nutil.global = typeof window !== \"undefined\" && window\r\n           || typeof global !== \"undefined\" && global\r\n           || typeof self   !== \"undefined\" && self\r\n           || this; // eslint-disable-line no-invalid-this\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\r\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === \"string\" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === \"object\";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire(\"buffer\").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === \"number\"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === \"undefined\"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\r\n         || /* istanbul ignore next */ util.global.Long\r\n         || util.inquire(\"long\");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\r\n\r\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\r\n\r\n    CustomError.prototype.toString = function toString() {\r\n        return this.name + \": \" + this.message;\r\n    };\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError(\"ProtocolError\");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\n// Sets up buffer utility according to the environment (called in index-minimal)\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}