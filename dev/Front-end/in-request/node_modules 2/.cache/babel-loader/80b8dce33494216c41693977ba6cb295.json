{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nconst units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\n\nfunction getDeadline(deadline) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n\n  throw new Error('Deadline is too far in the future');\n}\n\nclass DeadlineFilter extends filter_1.BaseFilter {\n  constructor(channel, callStream) {\n    super();\n    this.channel = channel;\n    this.callStream = callStream;\n    this.timer = null;\n    const callDeadline = callStream.getDeadline();\n\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n\n    const now = new Date().getTime();\n    let timeout = this.deadline - now;\n\n    if (timeout < 0) {\n      timeout = 0;\n    }\n\n    if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      callStream.on('status', () => clearTimeout(this.timer));\n    }\n  }\n\n  async sendMetadata(metadata) {\n    if (this.deadline === Infinity) {\n      return metadata;\n    }\n    /* The input metadata promise depends on the original channel.connect()\n     * promise, so when it is complete that implies that the channel is\n     * connected */\n\n\n    const finalMetadata = await metadata;\n    const timeoutString = getDeadline(this.deadline);\n    finalMetadata.set('grpc-timeout', timeoutString);\n    return finalMetadata;\n  }\n\n}\n\nexports.DeadlineFilter = DeadlineFilter;\n\nclass DeadlineFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n\n}\n\nexports.DeadlineFilterFactory = DeadlineFilterFactory;","map":{"version":3,"sources":["../../src/deadline-filter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAmBA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAGA,MAAM,KAAK,GAA4B,CACrC,CAAC,GAAD,EAAM,CAAN,CADqC,EAErC,CAAC,GAAD,EAAM,IAAN,CAFqC,EAGrC,CAAC,GAAD,EAAM,KAAK,IAAX,CAHqC,EAIrC,CAAC,GAAD,EAAM,KAAK,EAAL,GAAU,IAAhB,CAJqC,CAAvC;;AAOA,SAAS,WAAT,CAAqB,QAArB,EAAqC;AACnC,QAAM,GAAG,GAAG,IAAI,IAAJ,GAAW,OAAX,EAAZ;AACA,QAAM,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,GAApB,EAAyB,CAAzB,CAAlB;;AACA,OAAK,MAAM,CAAC,IAAD,EAAO,MAAP,CAAX,IAA6B,KAA7B,EAAoC;AAClC,UAAM,MAAM,GAAG,SAAS,GAAG,MAA3B;;AACA,QAAI,MAAM,GAAG,GAAb,EAAkB;AAChB,aAAO,MAAM,CAAC,IAAI,CAAC,IAAL,CAAU,MAAV,CAAD,CAAN,GAA4B,IAAnC;AACD;AACF;;AACD,QAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;AACD;;AAED,MAAa,cAAb,SAAoC,QAAA,CAAA,UAApC,CAA8C;AAG5C,EAAA,WAAA,CACmB,OADnB,EAEmB,UAFnB,EAEmC;AAEjC;AAHiB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,UAAA,GAAA,UAAA;AAJX,SAAA,KAAA,GAA6B,IAA7B;AAON,UAAM,YAAY,GAAG,UAAU,CAAC,WAAX,EAArB;;AACA,QAAI,YAAY,YAAY,IAA5B,EAAkC;AAChC,WAAK,QAAL,GAAgB,YAAY,CAAC,OAAb,EAAhB;AACD,KAFD,MAEO;AACL,WAAK,QAAL,GAAgB,YAAhB;AACD;;AACD,UAAM,GAAG,GAAW,IAAI,IAAJ,GAAW,OAAX,EAApB;AACA,QAAI,OAAO,GAAG,KAAK,QAAL,GAAgB,GAA9B;;AACA,QAAI,OAAO,GAAG,CAAd,EAAiB;AACf,MAAA,OAAO,GAAG,CAAV;AACD;;AACD,QAAI,KAAK,QAAL,KAAkB,QAAtB,EAAgC;AAC9B,WAAK,KAAL,GAAa,UAAU,CAAC,MAAK;AAC3B,QAAA,UAAU,CAAC,gBAAX,CACE,WAAA,CAAA,MAAA,CAAO,iBADT,EAEE,mBAFF;AAID,OALsB,EAKpB,OALoB,CAAvB;AAMA,MAAA,UAAU,CAAC,EAAX,CAAc,QAAd,EAAwB,MAAM,YAAY,CAAC,KAAK,KAAN,CAA1C;AACD;AACF;;AAED,QAAM,YAAN,CAAmB,QAAnB,EAA8C;AAC5C,QAAI,KAAK,QAAL,KAAkB,QAAtB,EAAgC;AAC9B,aAAO,QAAP;AACD;AACD;;;;;AAGA,UAAM,aAAa,GAAG,MAAM,QAA5B;AACA,UAAM,aAAa,GAAG,WAAW,CAAC,KAAK,QAAN,CAAjC;AACA,IAAA,aAAa,CAAC,GAAd,CAAkB,cAAlB,EAAkC,aAAlC;AACA,WAAO,aAAP;AACD;;AAzC2C;;AAA9C,OAAA,CAAA,cAAA,GAAA,cAAA;;AA4CA,MAAa,qBAAb,CAAkC;AAChC,EAAA,WAAA,CAA6B,OAA7B,EAA6C;AAAhB,SAAA,OAAA,GAAA,OAAA;AAAoB;;AAEjD,EAAA,YAAY,CAAC,UAAD,EAAiB;AAC3B,WAAO,IAAI,cAAJ,CAAmB,KAAK,OAAxB,EAAiC,UAAjC,CAAP;AACD;;AAL+B;;AAAlC,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./constants\");\nconst filter_1 = require(\"./filter\");\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadline(deadline) {\n    const now = new Date().getTime();\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n    constructor(channel, callStream) {\n        super();\n        this.channel = channel;\n        this.callStream = callStream;\n        this.timer = null;\n        const callDeadline = callStream.getDeadline();\n        if (callDeadline instanceof Date) {\n            this.deadline = callDeadline.getTime();\n        }\n        else {\n            this.deadline = callDeadline;\n        }\n        const now = new Date().getTime();\n        let timeout = this.deadline - now;\n        if (timeout < 0) {\n            timeout = 0;\n        }\n        if (this.deadline !== Infinity) {\n            this.timer = setTimeout(() => {\n                callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            }, timeout);\n            callStream.on('status', () => clearTimeout(this.timer));\n        }\n    }\n    async sendMetadata(metadata) {\n        if (this.deadline === Infinity) {\n            return metadata;\n        }\n        /* The input metadata promise depends on the original channel.connect()\n         * promise, so when it is complete that implies that the channel is\n         * connected */\n        const finalMetadata = await metadata;\n        const timeoutString = getDeadline(this.deadline);\n        finalMetadata.set('grpc-timeout', timeoutString);\n        return finalMetadata;\n    }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new DeadlineFilter(this.channel, callStream);\n    }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory;\n//# sourceMappingURL=deadline-filter.js.map"]},"metadata":{},"sourceType":"script"}