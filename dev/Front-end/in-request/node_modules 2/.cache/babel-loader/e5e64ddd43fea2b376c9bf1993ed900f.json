{"ast":null,"code":"/*! firebase-admin v8.9.2 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\n\n\nfunction getNumberField(obj, key) {\n  if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n    return parseInt(obj[key].toString(), 10);\n  }\n\n  return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\n\n\nfunction populateUploadAccountUser(user, userValidator) {\n  var result = {\n    localId: user.uid,\n    email: user.email,\n    emailVerified: user.emailVerified,\n    displayName: user.displayName,\n    disabled: user.disabled,\n    photoUrl: user.photoURL,\n    phoneNumber: user.phoneNumber,\n    providerUserInfo: [],\n    tenantId: user.tenantId,\n    customAttributes: user.customClaims && JSON.stringify(user.customClaims)\n  };\n\n  if (typeof user.passwordHash !== 'undefined') {\n    if (!validator.isBuffer(user.passwordHash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n\n    result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n  }\n\n  if (typeof user.passwordSalt !== 'undefined') {\n    if (!validator.isBuffer(user.passwordSalt)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n\n    result.salt = utils.toWebSafeBase64(user.passwordSalt);\n  }\n\n  if (validator.isNonNullObject(user.metadata)) {\n    if (validator.isNonEmptyString(user.metadata.creationTime)) {\n      result.createdAt = new Date(user.metadata.creationTime).getTime();\n    }\n\n    if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n      result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n    }\n  }\n\n  if (validator.isArray(user.providerData)) {\n    user.providerData.forEach(function (providerData) {\n      result.providerUserInfo.push({\n        providerId: providerData.providerId,\n        rawId: providerData.uid,\n        email: providerData.email,\n        displayName: providerData.displayName,\n        photoUrl: providerData.photoURL\n      });\n    });\n  } // Remove blank fields.\n\n\n  var key;\n\n  for (key in result) {\n    if (typeof result[key] === 'undefined') {\n      delete result[key];\n    }\n  }\n\n  if (result.providerUserInfo.length === 0) {\n    delete result.providerUserInfo;\n  } // Validate the constructured user individual request. This will throw if an error\n  // is detected.\n\n\n  if (typeof userValidator === 'function') {\n    userValidator(result);\n  }\n\n  return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\n\n\nvar UserImportBuilder =\n/** @class */\nfunction () {\n  /**\n   * @param {UserImportRecord[]} users The list of user records to import.\n   * @param {UserImportOptions=} options The import options which includes hashing\n   *     algorithm details.\n   * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n   * @constructor\n   */\n  function UserImportBuilder(users, options, userRequestValidator) {\n    this.requiresHashOptions = false;\n    this.validatedUsers = [];\n    this.userImportResultErrors = [];\n    this.indexMap = {};\n    this.validatedUsers = this.populateUsers(users, userRequestValidator);\n    this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n  }\n  /**\n   * Returns the corresponding constructed uploadAccount request.\n   * @return {UploadAccountRequest} The constructed uploadAccount request.\n   */\n\n\n  UserImportBuilder.prototype.buildRequest = function () {\n    var users = this.validatedUsers.map(function (user) {\n      return deep_copy_1.deepCopy(user);\n    });\n    return deep_copy_1.deepExtend({\n      users: users\n    }, deep_copy_1.deepCopy(this.validatedOptions));\n  };\n  /**\n   * Populates the UserImportResult using the client side detected errors and the server\n   * side returned errors.\n   * @return {UserImportResult} The user import result based on the returned failed\n   *     uploadAccount response.\n   */\n\n\n  UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n    var _this = this; // Initialize user import result.\n\n\n    var importResult = {\n      successCount: this.validatedUsers.length,\n      failureCount: this.userImportResultErrors.length,\n      errors: deep_copy_1.deepCopy(this.userImportResultErrors)\n    };\n    importResult.failureCount += failedUploads.length;\n    importResult.successCount -= failedUploads.length;\n    failedUploads.forEach(function (failedUpload) {\n      importResult.errors.push({\n        // Map backend request index to original developer provided array index.\n        index: _this.indexMap[failedUpload.index],\n        error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)\n      });\n    }); // Sort errors by index.\n\n    importResult.errors.sort(function (a, b) {\n      return a.index - b.index;\n    }); // Return sorted result.\n\n    return importResult;\n  };\n  /**\n   * Validates and returns the hashing options of the uploadAccount request.\n   * Throws an error whenever an invalid or missing options is detected.\n   * @param {UserImportOptions} options The UserImportOptions.\n   * @param {boolean} requiresHashOptions Whether to require hash options.\n   * @return {UploadAccountOptions} The populated UploadAccount options.\n   */\n\n\n  UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n    var populatedOptions;\n\n    if (!requiresHashOptions) {\n      return {};\n    }\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n    }\n\n    if (!validator.isNonNullObject(options.hash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" is missing from the provided \\\"UserImportOptions\\\".\");\n    }\n\n    if (typeof options.hash.algorithm === 'undefined' || !validator.isNonEmptyString(options.hash.algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" must be a string matching the list of supported algorithms.\");\n    }\n\n    var rounds;\n\n    switch (options.hash.algorithm) {\n      case 'HMAC_SHA512':\n      case 'HMAC_SHA256':\n      case 'HMAC_SHA1':\n      case 'HMAC_MD5':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A non-empty \\\"hash.key\\\" byte buffer must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key)\n        };\n        break;\n\n      case 'MD5':\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n        rounds = getNumberField(options.hash, 'rounds');\n        var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n\n        if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds: rounds\n        };\n        break;\n\n      case 'PBKDF_SHA1':\n      case 'PBKDF2_SHA256':\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 0 and 120000 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds: rounds\n        };\n        break;\n\n      case 'SCRYPT':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A \\\"hash.key\\\" byte buffer must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 1 and 8 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var memoryCost = getNumberField(options.hash, 'memoryCost');\n\n        if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number between 1 and 14 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        if (typeof options.hash.saltSeparator !== 'undefined' && !validator.isBuffer(options.hash.saltSeparator)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, \"\\\"hash.saltSeparator\\\" must be a byte buffer.\");\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key),\n          rounds: rounds,\n          memoryCost: memoryCost,\n          saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(''))\n        };\n        break;\n\n      case 'BCRYPT':\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm\n        };\n        break;\n\n      case 'STANDARD_SCRYPT':\n        var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n\n        if (isNaN(cpuMemCost)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var parallelization = getNumberField(options.hash, 'parallelization');\n\n        if (isNaN(parallelization)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, \"A valid \\\"hash.parallelization\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var blockSize = getNumberField(options.hash, 'blockSize');\n\n        if (isNaN(blockSize)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, \"A valid \\\"hash.blockSize\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n\n        if (isNaN(dkLen)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, \"A valid \\\"hash.derivedKeyLength\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          cpuMemCost: cpuMemCost,\n          parallelization: parallelization,\n          blockSize: blockSize,\n          dkLen: dkLen\n        };\n        break;\n\n      default:\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n    }\n\n    return populatedOptions;\n  };\n  /**\n   * Validates and returns the users list of the uploadAccount request.\n   * Whenever a user with an error is detected, the error is cached and will later be\n   * merged into the user import result. This allows the processing of valid users without\n   * failing early on the first error detected.\n   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n   *     objects.\n   * @param {ValidatorFunction=} userValidator The user validator function.\n   * @return {UploadAccountUser[]} The populated uploadAccount users.\n   */\n\n\n  UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n    var _this = this;\n\n    var populatedUsers = [];\n    users.forEach(function (user, index) {\n      try {\n        var result = populateUploadAccountUser(user, userValidator);\n\n        if (typeof result.passwordHash !== 'undefined') {\n          _this.requiresHashOptions = true;\n        } // Only users that pass client screening will be passed to backend for processing.\n\n\n        populatedUsers.push(result); // Map user's index (the one to be sent to backend) to original developer provided array.\n\n        _this.indexMap[populatedUsers.length - 1] = index;\n      } catch (error) {\n        // Save the client side error with respect to the developer provided array.\n        _this.userImportResultErrors.push({\n          index: index,\n          error: error\n        });\n      }\n    });\n    return populatedUsers;\n  };\n\n  return UserImportBuilder;\n}();\n\nexports.UserImportBuilder = UserImportBuilder;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/firebase-admin/lib/auth/user-import-builder.js"],"names":["Object","defineProperty","exports","value","deep_copy_1","require","utils","validator","error_1","getNumberField","obj","key","parseInt","toString","NaN","populateUploadAccountUser","user","userValidator","result","localId","uid","email","emailVerified","displayName","disabled","photoUrl","photoURL","phoneNumber","providerUserInfo","tenantId","customAttributes","customClaims","JSON","stringify","passwordHash","isBuffer","FirebaseAuthError","AuthClientErrorCode","INVALID_PASSWORD_HASH","toWebSafeBase64","passwordSalt","INVALID_PASSWORD_SALT","salt","isNonNullObject","metadata","isNonEmptyString","creationTime","createdAt","Date","getTime","lastSignInTime","lastLoginAt","isArray","providerData","forEach","push","providerId","rawId","length","UserImportBuilder","users","options","userRequestValidator","requiresHashOptions","validatedUsers","userImportResultErrors","indexMap","populateUsers","validatedOptions","populateOptions","prototype","buildRequest","map","deepCopy","deepExtend","buildResponse","failedUploads","_this","importResult","successCount","failureCount","errors","failedUpload","index","error","INVALID_USER_IMPORT","message","sort","a","b","populatedOptions","INVALID_ARGUMENT","hash","MISSING_HASH_ALGORITHM","algorithm","INVALID_HASH_ALGORITHM","rounds","INVALID_HASH_KEY","hashAlgorithm","signerKey","minRounds","isNaN","INVALID_HASH_ROUNDS","memoryCost","INVALID_HASH_MEMORY_COST","saltSeparator","INVALID_HASH_SALT_SEPARATOR","Buffer","from","cpuMemCost","parallelization","INVALID_HASH_PARALLELIZATION","blockSize","INVALID_HASH_BLOCK_SIZE","dkLen","INVALID_HASH_DERIVED_KEY_LENGTH","populatedUsers"],"mappings":"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","sourcesContent":["/*! firebase-admin v8.9.2 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar deep_copy_1 = require(\"../utils/deep-copy\");\nvar utils = require(\"../utils\");\nvar validator = require(\"../utils/validator\");\nvar error_1 = require(\"../utils/error\");\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\nfunction getNumberField(obj, key) {\n    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n        return parseInt(obj[key].toString(), 10);\n    }\n    return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\nfunction populateUploadAccountUser(user, userValidator) {\n    var result = {\n        localId: user.uid,\n        email: user.email,\n        emailVerified: user.emailVerified,\n        displayName: user.displayName,\n        disabled: user.disabled,\n        photoUrl: user.photoURL,\n        phoneNumber: user.phoneNumber,\n        providerUserInfo: [],\n        tenantId: user.tenantId,\n        customAttributes: user.customClaims && JSON.stringify(user.customClaims),\n    };\n    if (typeof user.passwordHash !== 'undefined') {\n        if (!validator.isBuffer(user.passwordHash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n        }\n        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n    }\n    if (typeof user.passwordSalt !== 'undefined') {\n        if (!validator.isBuffer(user.passwordSalt)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n        }\n        result.salt = utils.toWebSafeBase64(user.passwordSalt);\n    }\n    if (validator.isNonNullObject(user.metadata)) {\n        if (validator.isNonEmptyString(user.metadata.creationTime)) {\n            result.createdAt = new Date(user.metadata.creationTime).getTime();\n        }\n        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n        }\n    }\n    if (validator.isArray(user.providerData)) {\n        user.providerData.forEach(function (providerData) {\n            result.providerUserInfo.push({\n                providerId: providerData.providerId,\n                rawId: providerData.uid,\n                email: providerData.email,\n                displayName: providerData.displayName,\n                photoUrl: providerData.photoURL,\n            });\n        });\n    }\n    // Remove blank fields.\n    var key;\n    for (key in result) {\n        if (typeof result[key] === 'undefined') {\n            delete result[key];\n        }\n    }\n    if (result.providerUserInfo.length === 0) {\n        delete result.providerUserInfo;\n    }\n    // Validate the constructured user individual request. This will throw if an error\n    // is detected.\n    if (typeof userValidator === 'function') {\n        userValidator(result);\n    }\n    return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\nvar UserImportBuilder = /** @class */ (function () {\n    /**\n     * @param {UserImportRecord[]} users The list of user records to import.\n     * @param {UserImportOptions=} options The import options which includes hashing\n     *     algorithm details.\n     * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n     * @constructor\n     */\n    function UserImportBuilder(users, options, userRequestValidator) {\n        this.requiresHashOptions = false;\n        this.validatedUsers = [];\n        this.userImportResultErrors = [];\n        this.indexMap = {};\n        this.validatedUsers = this.populateUsers(users, userRequestValidator);\n        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n    }\n    /**\n     * Returns the corresponding constructed uploadAccount request.\n     * @return {UploadAccountRequest} The constructed uploadAccount request.\n     */\n    UserImportBuilder.prototype.buildRequest = function () {\n        var users = this.validatedUsers.map(function (user) {\n            return deep_copy_1.deepCopy(user);\n        });\n        return deep_copy_1.deepExtend({ users: users }, deep_copy_1.deepCopy(this.validatedOptions));\n    };\n    /**\n     * Populates the UserImportResult using the client side detected errors and the server\n     * side returned errors.\n     * @return {UserImportResult} The user import result based on the returned failed\n     *     uploadAccount response.\n     */\n    UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n        var _this = this;\n        // Initialize user import result.\n        var importResult = {\n            successCount: this.validatedUsers.length,\n            failureCount: this.userImportResultErrors.length,\n            errors: deep_copy_1.deepCopy(this.userImportResultErrors),\n        };\n        importResult.failureCount += failedUploads.length;\n        importResult.successCount -= failedUploads.length;\n        failedUploads.forEach(function (failedUpload) {\n            importResult.errors.push({\n                // Map backend request index to original developer provided array index.\n                index: _this.indexMap[failedUpload.index],\n                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),\n            });\n        });\n        // Sort errors by index.\n        importResult.errors.sort(function (a, b) {\n            return a.index - b.index;\n        });\n        // Return sorted result.\n        return importResult;\n    };\n    /**\n     * Validates and returns the hashing options of the uploadAccount request.\n     * Throws an error whenever an invalid or missing options is detected.\n     * @param {UserImportOptions} options The UserImportOptions.\n     * @param {boolean} requiresHashOptions Whether to require hash options.\n     * @return {UploadAccountOptions} The populated UploadAccount options.\n     */\n    UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n        var populatedOptions;\n        if (!requiresHashOptions) {\n            return {};\n        }\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n        }\n        if (!validator.isNonNullObject(options.hash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" is missing from the provided \\\"UserImportOptions\\\".\");\n        }\n        if (typeof options.hash.algorithm === 'undefined' ||\n            !validator.isNonEmptyString(options.hash.algorithm)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" must be a string matching the list of supported algorithms.\");\n        }\n        var rounds;\n        switch (options.hash.algorithm) {\n            case 'HMAC_SHA512':\n            case 'HMAC_SHA256':\n            case 'HMAC_SHA1':\n            case 'HMAC_MD5':\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A non-empty \\\"hash.key\\\" byte buffer must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                };\n                break;\n            case 'MD5':\n            case 'SHA1':\n            case 'SHA256':\n            case 'SHA512':\n                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n                rounds = getNumberField(options.hash, 'rounds');\n                var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            case 'PBKDF_SHA1':\n            case 'PBKDF2_SHA256':\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 0 and 120000 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            case 'SCRYPT':\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A \\\"hash.key\\\" byte buffer must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 1 and 8 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var memoryCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number between 1 and 14 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                if (typeof options.hash.saltSeparator !== 'undefined' &&\n                    !validator.isBuffer(options.hash.saltSeparator)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, \"\\\"hash.saltSeparator\\\" must be a byte buffer.\");\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                    rounds: rounds,\n                    memoryCost: memoryCost,\n                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),\n                };\n                break;\n            case 'BCRYPT':\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                };\n                break;\n            case 'STANDARD_SCRYPT':\n                var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(cpuMemCost)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var parallelization = getNumberField(options.hash, 'parallelization');\n                if (isNaN(parallelization)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, \"A valid \\\"hash.parallelization\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var blockSize = getNumberField(options.hash, 'blockSize');\n                if (isNaN(blockSize)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, \"A valid \\\"hash.blockSize\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n                if (isNaN(dkLen)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, \"A valid \\\"hash.derivedKeyLength\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    cpuMemCost: cpuMemCost,\n                    parallelization: parallelization,\n                    blockSize: blockSize,\n                    dkLen: dkLen,\n                };\n                break;\n            default:\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n        }\n        return populatedOptions;\n    };\n    /**\n     * Validates and returns the users list of the uploadAccount request.\n     * Whenever a user with an error is detected, the error is cached and will later be\n     * merged into the user import result. This allows the processing of valid users without\n     * failing early on the first error detected.\n     * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n     *     objects.\n     * @param {ValidatorFunction=} userValidator The user validator function.\n     * @return {UploadAccountUser[]} The populated uploadAccount users.\n     */\n    UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n        var _this = this;\n        var populatedUsers = [];\n        users.forEach(function (user, index) {\n            try {\n                var result = populateUploadAccountUser(user, userValidator);\n                if (typeof result.passwordHash !== 'undefined') {\n                    _this.requiresHashOptions = true;\n                }\n                // Only users that pass client screening will be passed to backend for processing.\n                populatedUsers.push(result);\n                // Map user's index (the one to be sent to backend) to original developer provided array.\n                _this.indexMap[populatedUsers.length - 1] = index;\n            }\n            catch (error) {\n                // Save the client side error with respect to the developer provided array.\n                _this.userImportResultErrors.push({\n                    index: index,\n                    error: error,\n                });\n            }\n        });\n        return populatedUsers;\n    };\n    return UserImportBuilder;\n}());\nexports.UserImportBuilder = UserImportBuilder;\n"]},"metadata":{},"sourceType":"script"}