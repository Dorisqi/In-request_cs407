{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst logger_1 = require(\"./logger\");\n\nconst util_1 = require(\"./util\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\n\n\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param maxIdleClients The maximum number of idle clients to keep before\n   * garbage collecting.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   * @param clientDestructor A cleanup function that is called when a client is\n   * disposed of.\n   */\n  constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.maxIdleClients = maxIdleClients;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     * @private\n     */\n\n    this.activeClients = new Map();\n    /**\n     * Whether the Firestore instance has been terminated. Once terminated, the\n     * ClientPool can longer schedule new operations.\n     */\n\n    this.terminated = false;\n    /**\n     * Deferred promise that is resolved when there are no active operations on\n     * the client pool after terminate() has been called.\n     */\n\n    this.terminateDeferred = new util_1.Deferred();\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   */\n\n\n  acquire(requestTag) {\n    let selectedClient = null;\n    let selectedClientRequestCount = -1;\n\n    for (const [client, requestCount] of this.activeClients) {\n      // Use the \"most-full\" client that can still accommodate the request\n      // in order to maximize the number of idle clients as operations start to\n      // complete.\n      if (requestCount > selectedClientRequestCount && requestCount < this.concurrentOperationLimit) {\n        selectedClient = client;\n        selectedClientRequestCount = requestCount;\n      }\n    }\n\n    if (selectedClient) {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n    } else {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n      selectedClient = this.clientFactory();\n      selectedClientRequestCount = 0;\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n\n    this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   */\n\n\n  async release(requestTag, client) {\n    const requestCount = this.activeClients.get(client) || 0;\n    assert(requestCount > 0, 'No active requests');\n    this.activeClients.set(client, requestCount - 1);\n\n    if (this.terminated && this.opCount === 0) {\n      this.terminateDeferred.resolve();\n    }\n\n    if (this.shouldGarbageCollectClient(client)) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n      logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n    }\n  }\n  /**\n   * Given the current operation counts, determines if the given client should\n   * be garbage collected.\n   * @private\n   */\n\n\n  shouldGarbageCollectClient(client) {\n    if (this.activeClients.get(client) !== 0) {\n      return false;\n    }\n\n    let idleCapacityCount = 0;\n\n    for (const [_, count] of this.activeClients) {\n      idleCapacityCount += this.concurrentOperationLimit - count;\n    }\n\n    return idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit;\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(count => activeOperationCount += count);\n    return activeOperationCount;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   */\n\n\n  run(requestTag, op) {\n    if (this.terminated) {\n      return Promise.reject('The client has already been terminated');\n    }\n\n    const client = this.acquire(requestTag);\n    return op(client).catch(async err => {\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n\n  async terminate() {\n    this.terminated = true; // Wait for all pending operations to complete before terminating.\n\n    if (this.opCount > 0) {\n      logger_1.logger('ClientPool.terminate',\n      /* requestTag= */\n      null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n      await this.terminateDeferred.promise;\n    }\n\n    for (const [client, _requestCount] of this.activeClients) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n\n}\n\nexports.ClientPool = ClientPool;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/@google-cloud/firestore/build/src/pool.js"],"names":["Object","defineProperty","exports","value","assert","require","logger_1","util_1","ClientPool","constructor","concurrentOperationLimit","maxIdleClients","clientFactory","clientDestructor","Promise","resolve","activeClients","Map","terminated","terminateDeferred","Deferred","acquire","requestTag","selectedClient","selectedClientRequestCount","client","requestCount","logger","has","set","release","get","opCount","shouldGarbageCollectClient","delete","idleCapacityCount","_","count","size","activeOperationCount","forEach","run","op","reject","catch","err","then","res","terminate","promise","_requestCount"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param maxIdleClients The maximum number of idle clients to keep before\n     * garbage collecting.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.maxIdleClients = maxIdleClients;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         * @private\n         */\n        this.activeClients = new Map();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n        /**\n         * Deferred promise that is resolved when there are no active operations on\n         * the client pool after terminate() has been called.\n         */\n        this.terminateDeferred = new util_1.Deferred();\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     */\n    acquire(requestTag) {\n        let selectedClient = null;\n        let selectedClientRequestCount = -1;\n        for (const [client, requestCount] of this.activeClients) {\n            // Use the \"most-full\" client that can still accommodate the request\n            // in order to maximize the number of idle clients as operations start to\n            // complete.\n            if (requestCount > selectedClientRequestCount &&\n                requestCount < this.concurrentOperationLimit) {\n                selectedClient = client;\n                selectedClientRequestCount = requestCount;\n            }\n        }\n        if (selectedClient) {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n        }\n        else {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n            selectedClient = this.clientFactory();\n            selectedClientRequestCount = 0;\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     */\n    async release(requestTag, client) {\n        const requestCount = this.activeClients.get(client) || 0;\n        assert(requestCount > 0, 'No active requests');\n        this.activeClients.set(client, requestCount - 1);\n        if (this.terminated && this.opCount === 0) {\n            this.terminateDeferred.resolve();\n        }\n        if (this.shouldGarbageCollectClient(client)) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n            logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n        }\n    }\n    /**\n     * Given the current operation counts, determines if the given client should\n     * be garbage collected.\n     * @private\n     */\n    shouldGarbageCollectClient(client) {\n        if (this.activeClients.get(client) !== 0) {\n            return false;\n        }\n        let idleCapacityCount = 0;\n        for (const [_, count] of this.activeClients) {\n            idleCapacityCount += this.concurrentOperationLimit - count;\n        }\n        return (idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit);\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(count => (activeOperationCount += count));\n        return activeOperationCount;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     */\n    run(requestTag, op) {\n        if (this.terminated) {\n            return Promise.reject('The client has already been terminated');\n        }\n        const client = this.acquire(requestTag);\n        return op(client)\n            .catch(async (err) => {\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        // Wait for all pending operations to complete before terminating.\n        if (this.opCount > 0) {\n            logger_1.logger('ClientPool.terminate', \n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n            await this.terminateDeferred.promise;\n        }\n        for (const [client, _requestCount] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"script"}