{"ast":null,"code":"\"use strict\"; // Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/util\n */\n\nconst projectify_1 = require(\"@google-cloud/projectify\");\n\nconst ent = require(\"ent\");\n\nconst extend = require(\"extend\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst retryRequest = require(\"retry-request\");\n\nconst stream_1 = require(\"stream\");\n\nconst teeny_request_1 = require(\"teeny-request\");\n\nconst duplexify = require('duplexify');\n\nconst requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\n\nclass ApiError extends Error {\n  constructor(errorBodyOrMessage) {\n    super();\n\n    if (typeof errorBodyOrMessage !== 'object') {\n      this.message = errorBodyOrMessage || '';\n      return;\n    }\n\n    const errorBody = errorBodyOrMessage;\n    this.code = errorBody.code;\n    this.errors = errorBody.errors;\n    this.response = errorBody.response;\n\n    try {\n      this.errors = JSON.parse(this.response.body).error.errors;\n    } catch (e) {\n      this.errors = errorBody.errors;\n    }\n\n    this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n    Error.captureStackTrace(this);\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n\n\n  static createMultiErrorMessage(err, errors) {\n    const messages = new Set();\n\n    if (err.message) {\n      messages.add(err.message);\n    }\n\n    if (errors && errors.length) {\n      errors.forEach(({\n        message\n      }) => messages.add(message));\n    } else if (err.response && err.response.body) {\n      messages.add(ent.decode(err.response.body.toString()));\n    } else if (!err.message) {\n      messages.add('A failure occurred during this request.');\n    }\n\n    let messageArr = Array.from(messages);\n\n    if (messageArr.length > 1) {\n      messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n      messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n      messageArr.push('\\n');\n    }\n\n    return messageArr.join('\\n');\n  }\n\n}\n\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\n\nclass PartialFailureError extends Error {\n  constructor(b) {\n    super();\n    const errorObject = b;\n    this.errors = errorObject.errors;\n    this.name = 'PartialFailureError';\n    this.response = errorObject.response;\n    this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n  }\n\n}\n\nexports.PartialFailureError = PartialFailureError;\n\nclass Util {\n  constructor() {\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n\n\n  noop() {}\n  /**\n   * Uniformly process an API response.\n   *\n   * @param {*} err - Error value.\n   * @param {*} resp - Response value.\n   * @param {*} body - Body value.\n   * @param {function} callback - The callback function.\n   */\n\n\n  handleResp(err, resp, body, callback) {\n    callback = callback || util.noop;\n    const parsedResp = extend(true, {\n      err: err || null\n    }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body)); // Assign the parsed body to resp.body, even if { json: false } was passed\n    // as a request option.\n    // We assume that nobody uses the previously unparsed value of resp.body.\n\n    if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n      parsedResp.resp.body = parsedResp.body;\n    }\n\n    if (parsedResp.err && resp) {\n      parsedResp.err.response = resp;\n    }\n\n    callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n  }\n  /**\n   * Sniff an incoming HTTP response message for errors.\n   *\n   * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.resp - The original response object.\n   */\n\n\n  parseHttpRespMessage(httpRespMessage) {\n    const parsedHttpRespMessage = {\n      resp: httpRespMessage\n    };\n\n    if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n      // Unknown error. Format according to ApiError standard.\n      parsedHttpRespMessage.err = new ApiError({\n        errors: new Array(),\n        code: httpRespMessage.statusCode,\n        message: httpRespMessage.statusMessage,\n        response: httpRespMessage\n      });\n    }\n\n    return parsedHttpRespMessage;\n  }\n  /**\n   * Parse the response body from an HTTP request.\n   *\n   * @param {object} body - The response body.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.body - The original body value provided\n   *     will try to be JSON.parse'd. If it's successful, the parsed value will\n   * be returned here, otherwise the original value and an error will be returned.\n   */\n\n\n  parseHttpRespBody(body) {\n    const parsedHttpRespBody = {\n      body\n    };\n\n    if (typeof body === 'string') {\n      try {\n        parsedHttpRespBody.body = JSON.parse(body);\n      } catch (err) {\n        parsedHttpRespBody.err = new ApiError(`Cannot parse response as JSON: ${body}`);\n      }\n    }\n\n    if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n      // Error from JSON API.\n      parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n    }\n\n    return parsedHttpRespBody;\n  }\n  /**\n   * Take a Duplexify stream, fetch an authenticated connection header, and\n   * create an outgoing writable stream.\n   *\n   * @param {Duplexify} dup - Duplexify stream.\n   * @param {object} options - Configuration object.\n   * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n   * @param {object} options.metadata - Metadata to send at the head of the request.\n   * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n   * @param {string=} options.request.method - Default: \"POST\".\n   * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n   * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n   * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n   */\n\n\n  makeWritableStream(dup, options, onComplete) {\n    onComplete = onComplete || util.noop;\n    const writeStream = new stream_1.PassThrough();\n    dup.setWritable(writeStream);\n    const defaultReqOpts = {\n      method: 'POST',\n      qs: {\n        uploadType: 'multipart'\n      },\n      timeout: 0,\n      maxRetries: 0\n    };\n    const metadata = options.metadata || {};\n    const reqOpts = extend(true, defaultReqOpts, options.request, {\n      multipart: [{\n        'Content-Type': 'application/json',\n        body: JSON.stringify(metadata)\n      }, {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        body: writeStream\n      }]\n    });\n    options.makeAuthenticatedRequest(reqOpts, {\n      onAuthenticated(err, authenticatedReqOpts) {\n        if (err) {\n          dup.destroy(err);\n          return;\n        }\n\n        const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n        request(authenticatedReqOpts, (err, resp, body) => {\n          util.handleResp(err, resp, body, (err, data) => {\n            if (err) {\n              dup.destroy(err);\n              return;\n            }\n\n            dup.emit('response', resp);\n            onComplete(data);\n          });\n        });\n      }\n\n    });\n  }\n  /**\n   * Returns true if the API request should be retried, given the error that was\n   * given the first time the request was attempted. This is used for rate limit\n   * related errors as well as intermittent server errors.\n   *\n   * @param {error} err - The API error to check if it is appropriate to retry.\n   * @return {boolean} True if the API request should be retried, false otherwise.\n   */\n\n\n  shouldRetryRequest(err) {\n    if (err) {\n      if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n        return true;\n      }\n\n      if (err.errors) {\n        for (const e of err.errors) {\n          const reason = e.reason;\n\n          if (reason === 'rateLimitExceeded') {\n            return true;\n          }\n\n          if (reason === 'userRateLimitExceeded') {\n            return true;\n          }\n\n          if (reason && reason.includes('EAI_AGAIN')) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a function for making authenticated requests.\n   *\n   * @param {object} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {object=} config.credentials - Credentials object.\n   * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n   * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n   * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n   * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n   * @param {array} config.scopes - Array of scopes required for the API.\n   */\n\n\n  makeAuthenticatedRequestFactory(config) {\n    const googleAutoAuthConfig = extend({}, config);\n\n    if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n      delete googleAutoAuthConfig.projectId;\n    }\n\n    const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n\n    function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n      let stream;\n      const reqConfig = extend({}, config);\n      let activeRequest_;\n\n      if (!optionsOrCallback) {\n        stream = duplexify();\n        reqConfig.stream = stream;\n      }\n\n      const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n      const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n\n      const onAuthenticated = (err, authenticatedReqOpts) => {\n        const authLibraryError = err;\n        const autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n\n        if (autoAuthFailed) {\n          // Even though authentication failed, the API might not actually\n          // care.\n          authenticatedReqOpts = reqOpts;\n        }\n\n        if (!err || autoAuthFailed) {\n          // tslint:disable-next-line:no-any\n          let projectId = authClient._cachedProjectId;\n\n          if (config.projectId && config.projectId !== '{{projectId}}') {\n            projectId = config.projectId;\n          }\n\n          try {\n            authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n            err = null;\n          } catch (e) {\n            // A projectId was required, but we don't have one.\n            // Re-use the \"Could not load the default credentials error\" if\n            // auto auth failed.\n            err = err || e;\n          }\n        }\n\n        if (err) {\n          if (stream) {\n            stream.destroy(err);\n          } else {\n            const fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n            fn(err);\n          }\n\n          return;\n        }\n\n        if (options && options.onAuthenticated) {\n          options.onAuthenticated(null, authenticatedReqOpts);\n        } else {\n          activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => {\n            if (apiResponseError && apiResponseError.code === 401 && authLibraryError) {\n              // Re-use the \"Could not load the default credentials error\" if\n              // the API request failed due to missing credentials.\n              apiResponseError = authLibraryError;\n            }\n\n            callback(apiResponseError, ...params);\n          });\n        }\n      };\n\n      if (reqConfig.customEndpoint) {\n        // Using a custom API override. Do not use `google-auth-library` for\n        // authentication. (ex: connecting to a local Datastore server)\n        onAuthenticated(null, reqOpts);\n      } else {\n        authClient.authorizeRequest(reqOpts).then(res => {\n          const opts = extend(true, {}, reqOpts, res);\n          onAuthenticated(null, opts);\n        }, err => {\n          onAuthenticated(err);\n        });\n      }\n\n      if (stream) {\n        return stream;\n      }\n\n      return {\n        abort() {\n          setImmediate(() => {\n            if (activeRequest_) {\n              activeRequest_.abort();\n              activeRequest_ = null;\n            }\n          });\n        }\n\n      };\n    }\n\n    const mar = makeAuthenticatedRequest;\n    mar.getCredentials = authClient.getCredentials.bind(authClient);\n    mar.authClient = authClient;\n    return mar;\n  }\n  /**\n   * Make a request through the `retryRequest` module with built-in error\n   * handling and exponential back off.\n   *\n   * @param {object} reqOpts - Request options in the format `request` expects.\n   * @param {object=} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {number=} config.maxRetries - Maximum number of automatic retries\n   *     attempted before returning the error. (default: 3)\n   * @param {object=} config.request - HTTP module for request calls.\n   * @param {function} callback - The callback function.\n   */\n\n\n  makeRequest(reqOpts, config, callback) {\n    const options = {\n      request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n      retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n\n      shouldRetryFn(httpRespMessage) {\n        const err = util.parseHttpRespMessage(httpRespMessage).err;\n        return err && util.shouldRetryRequest(err);\n      }\n\n    };\n\n    if (typeof reqOpts.maxRetries === 'number') {\n      options.retries = reqOpts.maxRetries;\n    }\n\n    if (!config.stream) {\n      return retryRequest(reqOpts, options, (err, response, body) => {\n        util.handleResp(err, response, body, callback);\n      });\n    }\n\n    const dup = config.stream; // tslint:disable-next-line:no-any\n\n    let requestStream;\n    const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = options.request(reqOpts);\n      dup.setWritable(requestStream);\n    } // Replay the Request events back to the stream.\n\n\n    requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n    dup.abort = requestStream.abort;\n    return dup;\n  }\n  /**\n   * Decorate the options about to be made in a request.\n   *\n   * @param {object} reqOpts - The options to be passed to `request`.\n   * @param {string} projectId - The project ID.\n   * @return {object} reqOpts - The decorated reqOpts.\n   */\n\n\n  decorateRequest(reqOpts, projectId) {\n    delete reqOpts.autoPaginate;\n    delete reqOpts.autoPaginateVal;\n    delete reqOpts.objectMode;\n\n    if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n      delete reqOpts.qs.autoPaginate;\n      delete reqOpts.qs.autoPaginateVal;\n      reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n    }\n\n    if (Array.isArray(reqOpts.multipart)) {\n      reqOpts.multipart = reqOpts.multipart.map(part => {\n        return projectify_1.replaceProjectIdToken(part, projectId);\n      });\n    }\n\n    if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n      delete reqOpts.json.autoPaginate;\n      delete reqOpts.json.autoPaginateVal;\n      reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n    }\n\n    reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n    return reqOpts;\n  } // tslint:disable-next-line:no-any\n\n\n  isCustomType(unknown, module) {\n    function getConstructorName(obj) {\n      return obj.constructor && obj.constructor.name.toLowerCase();\n    }\n\n    const moduleNameParts = module.split('/');\n    const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n    const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n\n    if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n      return false;\n    }\n\n    let walkingModule = unknown;\n\n    while (true) {\n      if (getConstructorName(walkingModule) === parentModuleName) {\n        return true;\n      }\n\n      walkingModule = walkingModule.parent;\n\n      if (!walkingModule) {\n        return false;\n      }\n    }\n  }\n  /**\n   * Create a properly-formatted User-Agent string from a package.json file.\n   *\n   * @param {object} packageJson - A module's package.json file.\n   * @return {string} userAgent - The formatted User-Agent string.\n   */\n\n\n  getUserAgentFromPackageJson(packageJson) {\n    const hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n    .replace('/', '-'); // For UA spec-compliance purposes.\n\n    return hyphenatedPackageName + '/' + packageJson.version;\n  }\n  /**\n   * Given two parameters, figure out if this is either:\n   *  - Just a callback function\n   *  - An options object, and then a callback function\n   * @param optionsOrCallback An options object or callback.\n   * @param cb A potentially undefined callback.\n   */\n\n\n  maybeOptionsOrCallback(optionsOrCallback, cb) {\n    return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n  }\n\n}\n\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;","map":{"version":3,"sources":["/Users/qier/Documents/cs407/In-request_cs407/dev/Front-end/in-request/node_modules/@google-cloud/common/build/src/util.js"],"names":["Object","defineProperty","exports","value","projectify_1","require","ent","extend","google_auth_library_1","retryRequest","stream_1","teeny_request_1","duplexify","requestDefaults","timeout","gzip","forever","pool","maxSockets","Infinity","ApiError","Error","constructor","errorBodyOrMessage","message","errorBody","code","errors","response","JSON","parse","body","error","e","createMultiErrorMessage","captureStackTrace","err","messages","Set","add","length","forEach","decode","toString","messageArr","Array","from","map","i","unshift","push","join","PartialFailureError","b","errorObject","name","Util","noop","handleResp","resp","callback","util","parsedResp","parseHttpRespMessage","parseHttpRespBody","httpRespMessage","parsedHttpRespMessage","statusCode","statusMessage","parsedHttpRespBody","makeWritableStream","dup","options","onComplete","writeStream","PassThrough","setWritable","defaultReqOpts","method","qs","uploadType","maxRetries","metadata","reqOpts","request","multipart","stringify","contentType","makeAuthenticatedRequest","onAuthenticated","authenticatedReqOpts","destroy","teenyRequest","defaults","data","emit","shouldRetryRequest","indexOf","reason","includes","makeAuthenticatedRequestFactory","config","googleAutoAuthConfig","projectId","authClient","GoogleAuth","optionsOrCallback","stream","reqConfig","activeRequest_","undefined","authLibraryError","autoAuthFailed","_cachedProjectId","decorateRequest","fn","makeRequest","apiResponseError","params","customEndpoint","authorizeRequest","then","res","opts","abort","setImmediate","mar","getCredentials","bind","retries","autoRetry","shouldRetryFn","requestStream","isGetRequest","toUpperCase","setReadable","on","autoPaginate","autoPaginateVal","objectMode","replaceProjectIdToken","isArray","part","json","uri","isCustomType","unknown","module","getConstructorName","obj","toLowerCase","moduleNameParts","split","parentModuleName","subModuleName","walkingModule","parent","getUserAgentFromPackageJson","packageJson","hyphenatedPackageName","replace","version","maybeOptionsOrCallback","cb"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n * @module common/util\n */\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst ent = require(\"ent\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst retryRequest = require(\"retry-request\");\nconst stream_1 = require(\"stream\");\nconst teeny_request_1 = require(\"teeny-request\");\nconst duplexify = require('duplexify');\nconst requestDefaults = {\n    timeout: 60000,\n    gzip: true,\n    forever: true,\n    pool: {\n        maxSockets: Infinity,\n    },\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n    constructor(errorBodyOrMessage) {\n        super();\n        if (typeof errorBodyOrMessage !== 'object') {\n            this.message = errorBodyOrMessage || '';\n            return;\n        }\n        const errorBody = errorBodyOrMessage;\n        this.code = errorBody.code;\n        this.errors = errorBody.errors;\n        this.response = errorBody.response;\n        try {\n            this.errors = JSON.parse(this.response.body).error.errors;\n        }\n        catch (e) {\n            this.errors = errorBody.errors;\n        }\n        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n        Error.captureStackTrace(this);\n    }\n    /**\n     * Pieces together an error message by combining all unique error messages\n     * returned from a single GoogleError\n     *\n     * @private\n     *\n     * @param {GoogleErrorBody} err The original error.\n     * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n     * @returns {string}\n     */\n    static createMultiErrorMessage(err, errors) {\n        const messages = new Set();\n        if (err.message) {\n            messages.add(err.message);\n        }\n        if (errors && errors.length) {\n            errors.forEach(({ message }) => messages.add(message));\n        }\n        else if (err.response && err.response.body) {\n            messages.add(ent.decode(err.response.body.toString()));\n        }\n        else if (!err.message) {\n            messages.add('A failure occurred during this request.');\n        }\n        let messageArr = Array.from(messages);\n        if (messageArr.length > 1) {\n            messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n            messageArr.push('\\n');\n        }\n        return messageArr.join('\\n');\n    }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n    constructor(b) {\n        super();\n        const errorObject = b;\n        this.errors = errorObject.errors;\n        this.name = 'PartialFailureError';\n        this.response = errorObject.response;\n        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n    }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n    constructor() {\n        this.ApiError = ApiError;\n        this.PartialFailureError = PartialFailureError;\n    }\n    /**\n     * No op.\n     *\n     * @example\n     * function doSomething(callback) {\n     *   callback = callback || noop;\n     * }\n     */\n    noop() { }\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n    handleResp(err, resp, body, callback) {\n        callback = callback || util.noop;\n        const parsedResp = extend(true, { err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n        // Assign the parsed body to resp.body, even if { json: false } was passed\n        // as a request option.\n        // We assume that nobody uses the previously unparsed value of resp.body.\n        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n            parsedResp.resp.body = parsedResp.body;\n        }\n        if (parsedResp.err && resp) {\n            parsedResp.err.response = resp;\n        }\n        callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n    parseHttpRespMessage(httpRespMessage) {\n        const parsedHttpRespMessage = {\n            resp: httpRespMessage,\n        };\n        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n            // Unknown error. Format according to ApiError standard.\n            parsedHttpRespMessage.err = new ApiError({\n                errors: new Array(),\n                code: httpRespMessage.statusCode,\n                message: httpRespMessage.statusMessage,\n                response: httpRespMessage,\n            });\n        }\n        return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value and an error will be returned.\n     */\n    parseHttpRespBody(body) {\n        const parsedHttpRespBody = {\n            body,\n        };\n        if (typeof body === 'string') {\n            try {\n                parsedHttpRespBody.body = JSON.parse(body);\n            }\n            catch (err) {\n                parsedHttpRespBody.err = new ApiError(`Cannot parse response as JSON: ${body}`);\n            }\n        }\n        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n            // Error from JSON API.\n            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n        }\n        return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n    makeWritableStream(dup, options, onComplete) {\n        onComplete = onComplete || util.noop;\n        const writeStream = new stream_1.PassThrough();\n        dup.setWritable(writeStream);\n        const defaultReqOpts = {\n            method: 'POST',\n            qs: {\n                uploadType: 'multipart',\n            },\n            timeout: 0,\n            maxRetries: 0,\n        };\n        const metadata = options.metadata || {};\n        const reqOpts = extend(true, defaultReqOpts, options.request, {\n            multipart: [\n                {\n                    'Content-Type': 'application/json',\n                    body: JSON.stringify(metadata),\n                },\n                {\n                    'Content-Type': metadata.contentType || 'application/octet-stream',\n                    body: writeStream,\n                },\n            ],\n        });\n        options.makeAuthenticatedRequest(reqOpts, {\n            onAuthenticated(err, authenticatedReqOpts) {\n                if (err) {\n                    dup.destroy(err);\n                    return;\n                }\n                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n                request(authenticatedReqOpts, (err, resp, body) => {\n                    util.handleResp(err, resp, body, (err, data) => {\n                        if (err) {\n                            dup.destroy(err);\n                            return;\n                        }\n                        dup.emit('response', resp);\n                        onComplete(data);\n                    });\n                });\n            },\n        });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n    shouldRetryRequest(err) {\n        if (err) {\n            if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n                return true;\n            }\n            if (err.errors) {\n                for (const e of err.errors) {\n                    const reason = e.reason;\n                    if (reason === 'rateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason === 'userRateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason && reason.includes('EAI_AGAIN')) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n    makeAuthenticatedRequestFactory(config) {\n        const googleAutoAuthConfig = extend({}, config);\n        if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n            delete googleAutoAuthConfig.projectId;\n        }\n        const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n            let stream;\n            const reqConfig = extend({}, config);\n            let activeRequest_;\n            if (!optionsOrCallback) {\n                stream = duplexify();\n                reqConfig.stream = stream;\n            }\n            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n            const onAuthenticated = (err, authenticatedReqOpts) => {\n                const authLibraryError = err;\n                const autoAuthFailed = err &&\n                    err.message.indexOf('Could not load the default credentials') > -1;\n                if (autoAuthFailed) {\n                    // Even though authentication failed, the API might not actually\n                    // care.\n                    authenticatedReqOpts = reqOpts;\n                }\n                if (!err || autoAuthFailed) {\n                    // tslint:disable-next-line:no-any\n                    let projectId = authClient._cachedProjectId;\n                    if (config.projectId && config.projectId !== '{{projectId}}') {\n                        projectId = config.projectId;\n                    }\n                    try {\n                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                        err = null;\n                    }\n                    catch (e) {\n                        // A projectId was required, but we don't have one.\n                        // Re-use the \"Could not load the default credentials error\" if\n                        // auto auth failed.\n                        err = err || e;\n                    }\n                }\n                if (err) {\n                    if (stream) {\n                        stream.destroy(err);\n                    }\n                    else {\n                        const fn = options && options.onAuthenticated\n                            ? options.onAuthenticated\n                            : callback;\n                        fn(err);\n                    }\n                    return;\n                }\n                if (options && options.onAuthenticated) {\n                    options.onAuthenticated(null, authenticatedReqOpts);\n                }\n                else {\n                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => {\n                        if (apiResponseError &&\n                            apiResponseError.code === 401 &&\n                            authLibraryError) {\n                            // Re-use the \"Could not load the default credentials error\" if\n                            // the API request failed due to missing credentials.\n                            apiResponseError = authLibraryError;\n                        }\n                        callback(apiResponseError, ...params);\n                    });\n                }\n            };\n            if (reqConfig.customEndpoint) {\n                // Using a custom API override. Do not use `google-auth-library` for\n                // authentication. (ex: connecting to a local Datastore server)\n                onAuthenticated(null, reqOpts);\n            }\n            else {\n                authClient.authorizeRequest(reqOpts).then(res => {\n                    const opts = extend(true, {}, reqOpts, res);\n                    onAuthenticated(null, opts);\n                }, err => {\n                    onAuthenticated(err);\n                });\n            }\n            if (stream) {\n                return stream;\n            }\n            return {\n                abort() {\n                    setImmediate(() => {\n                        if (activeRequest_) {\n                            activeRequest_.abort();\n                            activeRequest_ = null;\n                        }\n                    });\n                },\n            };\n        }\n        const mar = makeAuthenticatedRequest;\n        mar.getCredentials = authClient.getCredentials.bind(authClient);\n        mar.authClient = authClient;\n        return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n    makeRequest(reqOpts, config, callback) {\n        const options = {\n            request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n            retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n            shouldRetryFn(httpRespMessage) {\n                const err = util.parseHttpRespMessage(httpRespMessage).err;\n                return err && util.shouldRetryRequest(err);\n            },\n        };\n        if (typeof reqOpts.maxRetries === 'number') {\n            options.retries = reqOpts.maxRetries;\n        }\n        if (!config.stream) {\n            return retryRequest(reqOpts, options, (err, response, body) => {\n                util.handleResp(err, response, body, callback);\n            });\n        }\n        const dup = config.stream;\n        // tslint:disable-next-line:no-any\n        let requestStream;\n        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n        if (isGetRequest) {\n            requestStream = retryRequest(reqOpts, options);\n            dup.setReadable(requestStream);\n        }\n        else {\n            // Streaming writable HTTP requests cannot be retried.\n            requestStream = options.request(reqOpts);\n            dup.setWritable(requestStream);\n        }\n        // Replay the Request events back to the stream.\n        requestStream\n            .on('error', dup.destroy.bind(dup))\n            .on('response', dup.emit.bind(dup, 'response'))\n            .on('complete', dup.emit.bind(dup, 'complete'));\n        dup.abort = requestStream.abort;\n        return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n    decorateRequest(reqOpts, projectId) {\n        delete reqOpts.autoPaginate;\n        delete reqOpts.autoPaginateVal;\n        delete reqOpts.objectMode;\n        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n            delete reqOpts.qs.autoPaginate;\n            delete reqOpts.qs.autoPaginateVal;\n            reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n        }\n        if (Array.isArray(reqOpts.multipart)) {\n            reqOpts.multipart = reqOpts.multipart.map(part => {\n                return projectify_1.replaceProjectIdToken(part, projectId);\n            });\n        }\n        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n            delete reqOpts.json.autoPaginate;\n            delete reqOpts.json.autoPaginateVal;\n            reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n        }\n        reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n        return reqOpts;\n    }\n    // tslint:disable-next-line:no-any\n    isCustomType(unknown, module) {\n        function getConstructorName(obj) {\n            return obj.constructor && obj.constructor.name.toLowerCase();\n        }\n        const moduleNameParts = module.split('/');\n        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n        if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n            return false;\n        }\n        let walkingModule = unknown;\n        while (true) {\n            if (getConstructorName(walkingModule) === parentModuleName) {\n                return true;\n            }\n            walkingModule = walkingModule.parent;\n            if (!walkingModule) {\n                return false;\n            }\n        }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n    getUserAgentFromPackageJson(packageJson) {\n        const hyphenatedPackageName = packageJson.name\n            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n            .replace('/', '-'); // For UA spec-compliance purposes.\n        return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n    maybeOptionsOrCallback(optionsOrCallback, cb) {\n        return typeof optionsOrCallback === 'function'\n            ? [{}, optionsOrCallback]\n            : [optionsOrCallback, cb];\n    }\n}\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}