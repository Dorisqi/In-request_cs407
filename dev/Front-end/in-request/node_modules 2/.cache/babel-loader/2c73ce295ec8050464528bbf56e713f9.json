{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\n\n\nfunction callErrorFromStatus(status) {\n  const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n  return Object.assign(new Error(message), status);\n}\n\nexports.callErrorFromStatus = callErrorFromStatus;\n\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call) {\n    super();\n    this.call = call;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    call.on('status', status => {\n      this.emit('status', status);\n    });\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n}\n\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\n\nfunction setUpReadableStream(stream, call, deserialize) {\n  let statusEmitted = false;\n  call.on('data', data => {\n    let deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      return;\n    }\n\n    if (!stream.push(deserialized)) {\n      call.pause();\n    }\n  });\n  call.on('end', () => {\n    if (statusEmitted) {\n      stream.push(null);\n    } else {\n      call.once('status', () => {\n        stream.push(null);\n      });\n    }\n  });\n  call.on('status', status => {\n    if (status.code !== constants_1.Status.OK) {\n      stream.emit('error', callErrorFromStatus(status));\n    }\n\n    stream.emit('status', status);\n    statusEmitted = true;\n  });\n  call.pause();\n}\n\nclass ClientReadableStreamImpl extends stream_1.Readable {\n  constructor(call, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.deserialize = deserialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    setUpReadableStream(this, call, deserialize);\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _read(_size) {\n    this.call.resume();\n  }\n\n}\n\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\n\nfunction tryWrite(call, serialize, chunk, encoding, cb) {\n  let message;\n  const flags = Number(encoding);\n\n  try {\n    message = serialize(chunk);\n  } catch (e) {\n    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n    cb(e);\n    return;\n  }\n\n  const writeObj = {\n    message\n  };\n\n  if (!Number.isNaN(flags)) {\n    writeObj.flags = flags;\n  }\n\n  call.write(writeObj, cb);\n}\n\nclass ClientWritableStreamImpl extends stream_1.Writable {\n  constructor(call, serialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.serialize = serialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    call.on('status', status => {\n      this.emit('status', status);\n    });\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _write(chunk, encoding, cb) {\n    tryWrite(this.call, this.serialize, chunk, encoding, cb);\n  }\n\n  _final(cb) {\n    this.call.end();\n    cb();\n  }\n\n}\n\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\n\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    call.on('metadata', metadata => {\n      this.emit('metadata', metadata);\n    });\n    setUpReadableStream(this, call, deserialize);\n  }\n\n  cancel() {\n    this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  _read(_size) {\n    this.call.resume();\n  }\n\n  _write(chunk, encoding, cb) {\n    tryWrite(this.call, this.serialize, chunk, encoding, cb);\n  }\n\n  _final(cb) {\n    this.call.end();\n    cb();\n  }\n\n}\n\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":{"version":3,"sources":["../../src/call.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    return Object.assign(new Error(message), status);\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call) {\n        super();\n        this.call = call;\n        call.on('metadata', (metadata) => {\n            this.emit('metadata', metadata);\n        });\n        call.on('status', (status) => {\n            this.emit('status', status);\n        });\n    }\n    cancel() {\n        this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nfunction setUpReadableStream(stream, call, deserialize) {\n    let statusEmitted = false;\n    call.on('data', (data) => {\n        let deserialized;\n        try {\n            deserialized = deserialize(data);\n        }\n        catch (e) {\n            call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n            return;\n        }\n        if (!stream.push(deserialized)) {\n            call.pause();\n        }\n    });\n    call.on('end', () => {\n        if (statusEmitted) {\n            stream.push(null);\n        }\n        else {\n            call.once('status', () => {\n                stream.push(null);\n            });\n        }\n    });\n    call.on('status', (status) => {\n        if (status.code !== constants_1.Status.OK) {\n            stream.emit('error', callErrorFromStatus(status));\n        }\n        stream.emit('status', status);\n        statusEmitted = true;\n    });\n    call.pause();\n}\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(call, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.deserialize = deserialize;\n        call.on('metadata', (metadata) => {\n            this.emit('metadata', metadata);\n        });\n        setUpReadableStream(this, call, deserialize);\n    }\n    cancel() {\n        this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    _read(_size) {\n        this.call.resume();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nfunction tryWrite(call, serialize, chunk, encoding, cb) {\n    let message;\n    const flags = Number(encoding);\n    try {\n        message = serialize(chunk);\n    }\n    catch (e) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n        cb(e);\n        return;\n    }\n    const writeObj = { message };\n    if (!Number.isNaN(flags)) {\n        writeObj.flags = flags;\n    }\n    call.write(writeObj, cb);\n}\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(call, serialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.serialize = serialize;\n        call.on('metadata', (metadata) => {\n            this.emit('metadata', metadata);\n        });\n        call.on('status', (status) => {\n            this.emit('status', status);\n        });\n    }\n    cancel() {\n        this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    _write(chunk, encoding, cb) {\n        tryWrite(this.call, this.serialize, chunk, encoding, cb);\n    }\n    _final(cb) {\n        this.call.end();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, serialize, deserialize) {\n        super({ objectMode: true });\n        this.call = call;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        call.on('metadata', (metadata) => {\n            this.emit('metadata', metadata);\n        });\n        setUpReadableStream(this, call, deserialize);\n    }\n    cancel() {\n        this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    _read(_size) {\n        this.call.resume();\n    }\n    _write(chunk, encoding, cb) {\n        tryWrite(this.call, this.serialize, chunk, encoding, cb);\n    }\n    _final(cb) {\n        this.call.end();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map"]},"metadata":{},"sourceType":"script"}