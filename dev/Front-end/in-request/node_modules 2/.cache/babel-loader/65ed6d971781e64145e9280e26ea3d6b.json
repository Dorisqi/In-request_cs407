{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst channel_1 = require(\"./channel\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinPicker {\n  constructor(subchannelList, nextIndex = 0) {\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n\n  pick(pickArgs) {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null\n    };\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n\n\n  peekNextSubchannel() {\n    return this.subchannelList[this.nextIndex];\n  }\n\n}\n\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.subchannelStateCounts = {\n      [channel_1.ConnectivityState.CONNECTING]: 0,\n      [channel_1.ConnectivityState.IDLE]: 0,\n      [channel_1.ConnectivityState.READY]: 0,\n      [channel_1.ConnectivityState.SHUTDOWN]: 0,\n      [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n\n      if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.channelControlHelper.requestReresolution();\n      }\n\n      if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE || newState === channel_1.ConnectivityState.IDLE) {\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  calculateAndUpdateState() {\n    if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);\n      let index = 0;\n\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n\n        if (index < 0) {\n          index = 0;\n        }\n      }\n\n      this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n    } else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n      this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n      this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    } else {\n      this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateState(newState, picker) {\n    trace(channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[newState]);\n\n    if (newState === channel_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n    }\n\n    this.subchannelStateCounts = {\n      [channel_1.ConnectivityState.CONNECTING]: 0,\n      [channel_1.ConnectivityState.IDLE]: 0,\n      [channel_1.ConnectivityState.READY]: 0,\n      [channel_1.ConnectivityState.SHUTDOWN]: 0,\n      [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + addressList.map(address => subchannel_1.subchannelAddressToString(address)));\n    this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n\n    for (const subchannel of this.subchannels) {\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n\n      if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        subchannel.startConnecting();\n      }\n    }\n\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n  replaceChannelControlHelper(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n  }\n\n}\n\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer);\n}\n\nexports.setup = setup;","map":{"version":3,"sources":["../../src/load-balancer-round-robin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst load_balancer_1 = require(\"./load-balancer\");\nconst channel_1 = require(\"./channel\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_1 = require(\"./subchannel\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0) {\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = channel_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.subchannelStateCounts = {\n            [channel_1.ConnectivityState.CONNECTING]: 0,\n            [channel_1.ConnectivityState.IDLE]: 0,\n            [channel_1.ConnectivityState.READY]: 0,\n            [channel_1.ConnectivityState.SHUTDOWN]: 0,\n            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            this.calculateAndUpdateState();\n            if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.channelControlHelper.requestReresolution();\n            }\n            if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE ||\n                newState === channel_1.ConnectivityState.IDLE) {\n                subchannel.startConnecting();\n            }\n        };\n    }\n    calculateAndUpdateState() {\n        if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {\n            const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        }\n        else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n            this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n        else {\n            this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(channel_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            channel_1.ConnectivityState[newState]);\n        if (newState === channel_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n        }\n        this.subchannelStateCounts = {\n            [channel_1.ConnectivityState.CONNECTING]: 0,\n            [channel_1.ConnectivityState.IDLE]: 0,\n            [channel_1.ConnectivityState.READY]: 0,\n            [channel_1.ConnectivityState.SHUTDOWN]: 0,\n            [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            addressList.map(address => subchannel_1.subchannelAddressToString(address)));\n        this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            const subchannelState = subchannel.getConnectivityState();\n            this.subchannelStateCounts[subchannelState] += 1;\n            if (subchannelState === channel_1.ConnectivityState.IDLE ||\n                subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n    replaceChannelControlHelper(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-round-robin.js.map"]},"metadata":{},"sourceType":"script"}